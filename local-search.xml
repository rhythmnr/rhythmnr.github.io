<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>javascript项目配置 CI=false 时的作用</title>
    <link href="/2025/01/10/javascript%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%20CI=false%20%E6%97%B6%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2025/01/10/javascript%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%20CI=false%20%E6%97%B6%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>背景：</p><p>开发的一个前端项目，在本地执行npm build没有问题，打印了一些eslint的warning。但是在github runner上报错了，报错内容为所有的warning。</p><p>其实报错的都是eslint的一些警告，应该是github runner上所谓类似等级的东西比较高，所以把eslint的警告视为错误。而我的本地等级比较低，所以不会把eslint的警告视为错误</p><p>对于这种场景，需要修改一个配置，修改为CI&#x3D;false，参考修改如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&quot;build:dev&quot;: &quot;cross-env REACT_APP_APP_ENV=dev react-app-rewired build CI=false&quot;,<br>&quot;build:qa&quot;: &quot;cross-env REACT_APP_APP_ENV=qa react-app-rewired build CI=false&quot;,<br>&quot;build:prod&quot;: &quot;cross-env REACT_APP_APP_ENV=prod react-app-rewired build CI=false&quot;,<br></code></pre></td></tr></table></figure><p><code>CI</code> 是一个常见的环境变量，代表 “Continuous Integration”（持续集成）。在一些持续集成环境中（如Jenkins、Travis CI等），<code>CI</code> 环境变量通常被设置为 <code>true</code>，以便在<strong>严格模式</strong>下运行，比如在测试失败时阻止构建的继续。严格模式下如果有eslint warning就会直接程序exit。</p><p>一些工具和库在检测到 <code>CI=true</code> 时会执行额外的检查和验证。例如，某些测试框架可能会在CI环境中强制所有测试通过，而不会允许任何警告或错误。某些构建工具和脚本在CI环境中可能会有特定行为。例如，Create React App（CRA）在CI环境中会将构建的所有警告视为错误，导致构建失败。</p><p>在这个脚本中，<code>CI=false</code> 是将 <code>CI</code> 环境变量设置为 <code>false</code>，通常用于在本地开发或非CI环境中运行构建过程。这可能会禁用某些CI特有的行为，比如严格的错误检查。</p><p>设置 <code>CI=false</code> 环境变量，以确保在构建过程中不会触发某些CI特有的行为。</p><p>这对于在本地开发环境中进行构建特别有用，因为你可能不希望在本地构建时触发。</p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeQL介绍与配置</title>
    <link href="/2025/01/06/CodeQL%E4%BB%8B%E7%BB%8D%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/01/06/CodeQL%E4%BB%8B%E7%BB%8D%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="CodeQL"><a href="#CodeQL" class="headerlink" title="CodeQL"></a>CodeQL</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://codeql.github.com/">CodeQL</a>是Github出品的代码分析引擎，全称Code Query Language，顾名思义就是通过规定的语法查询代码中可能出现的安全隐患。CodeQL可以通过扫描一个项目的源代码，发现源代码存在的安全漏洞，然后自动将扫描结果上传给Github以便将结果在pull request中或者repository的Security Tab中展示。</p><p>CodeQL运行时的操作步骤如下：</p><ul><li>init：即初始化操作，在该操作中进行CodeQL的设置，设置CodeQL要分析的编程语言，设置查询集（查询集可以根据自己的规则和模式分析代码，识别潜在的安全漏洞，每个查询集的规则和模式都不一样。比如security-extended<code>、</code>security-and-quality等），设置CodeQL需要使用的数据库（CodeQL之后会往里写入AST、代码相关元数据等）。init中也可以配置编译操作。</li><li>analyze：扫描代码并分析，将分析结果上传给Github。对于编译型语言，analyze依赖编译信息，所以需要在analyze之前执行编译操作（可以设置init中auto build，也可以在init之后手动指定编译命令）</li></ul><p>CodeQL支持分析多种编程语言的源代码，即时一个源代码里有多种变成语言。CodeQL所有支持的编程语言可以参考 <a href="https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/codeql-code-scanning-for-compiled-languages%E3%80%82%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E4%B8%A4%E7%B1%BB%EF%BC%8C">https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/codeql-code-scanning-for-compiled-languages。编程语言可以分为两类，</a> 编译型和解释型，对于解释型语言，CodeQL直接分析源代码文件即可以检测出漏洞，对于编译型语言，则需要先执行编译操作（不管是CodeQL在init中auto build还是自定义编译的命令），因为CodeQL的分析依赖完整的编译信息。具体参见下文的<code>使用/init/build-mode</code>模块。</p><blockquote><p>操作步骤提到的数据库是一个比较重要的概念，衔接了init和analyze。对于解释型语言可以忽略这块，对于编译型语言这块很重要。数据库无论什么情况下都会被创建，analyze的分析依赖数据库，数据库存储了<strong>编译信息</strong>和其他内容（其他内容无论是什么语言，只要运行了init就都会被创建）。对于编译型语言，如果analyze部分要运行分析，那么数据库的编译信息部分必须存在，如果要有编译信息，就一定要在analyze之前运行编译命令，否则会直接报错。</p></blockquote><h2 id="官方配置文档"><a href="#官方配置文档" class="headerlink" title="官方配置文档"></a>官方配置文档</h2><p>下面介绍如何将CodeQL集成到Github Action中。</p><p>CodeQL运行时的两个操作步骤：init和analyze，分别对应了一个三方github action，init对应了github&#x2F;codeql-action&#x2F;init@v3，analyze对应了github&#x2F;codeql-action&#x2F;analyze@v3。这两个三方action在使用时根据官方文档，可以自定义一些参数</p><h3 id="全局workflow参数配置"><a href="#全局workflow参数配置" class="headerlink" title="全局workflow参数配置"></a>全局workflow参数配置</h3><p>主要就是permission里的参数配置，一般配置成如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">permissions:</span><br>  <span class="hljs-attr">actions:</span> <span class="hljs-string">read</span> <span class="hljs-comment"># 定义工作流所需的权限</span><br>  <span class="hljs-attr">contents:</span> <span class="hljs-string">read</span> <span class="hljs-comment"># 设置CodeQL是否允许读取仓库源代码。对于私有仓库，需要设置为read，共有仓库不需要设置</span><br>  <span class="hljs-attr">security-events:</span> <span class="hljs-string">write</span> <span class="hljs-comment"># 允许codeql向github write分析结果</span><br></code></pre></td></tr></table></figure><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>所有可以传的参数参考官方文档：<a href="https://github.com/github/codeql-action/blob/main/init/action.yml">https://github.com/github/codeql-action/blob/main/init/action.yml</a> 的inputs部分</p><h3 id="analyze"><a href="#analyze" class="headerlink" title="analyze"></a>analyze</h3><p>所有可以传的参数参考官方文档：<a href="https://github.com/github/codeql-action/blob/main/analyze/action.yml">https://github.com/github/codeql-action/blob/main/analyze/action.yml</a> 的inputs部分，下面介绍其中比较重要的配置：</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>下面介绍如何将CodeQL集成到Github Action中。</p><p>CodeQL运行时的两个操作步骤：init和analyze，分别对应了一个三方github action，init对应了github&#x2F;codeql-action&#x2F;init@v3，analyze对应了github&#x2F;codeql-action&#x2F;analyze@v3。这两个三方action在使用时根据官方文档，可以自定义一些参数，下面介绍两个步骤中一些比较重要的参数。</p><h3 id="全局workflow参数配置-1"><a href="#全局workflow参数配置-1" class="headerlink" title="全局workflow参数配置"></a>全局workflow参数配置</h3><p>主要就是permission里的参数配置，一般配置成如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">permissions:</span><br>  <span class="hljs-attr">actions:</span> <span class="hljs-string">read</span> <span class="hljs-comment"># 定义工作流所需的权限</span><br>  <span class="hljs-attr">contents:</span> <span class="hljs-string">read</span> <span class="hljs-comment"># 设置CodeQL是否允许读取仓库源代码。对于私有仓库，需要设置为read，共有仓库不需要设置contents项</span><br>  <span class="hljs-attr">security-events:</span> <span class="hljs-string">write</span> <span class="hljs-comment"># 允许codeql向github security 报告分析结果</span><br></code></pre></td></tr></table></figure><h3 id="init-1"><a href="#init-1" class="headerlink" title="init"></a>init</h3><p>所有可以传的参数参考官方文档：<a href="https://github.com/github/codeql-action/blob/main/init/action.yml">https://github.com/github/codeql-action/blob/main/init/action.yml</a> 的inputs部分，下面介绍其中比较重要的配置：</p><h4 id="languages"><a href="#languages" class="headerlink" title="languages"></a><strong>languages</strong></h4><p>该文档里官方写的注释为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">languages:<br>  description: &gt;-<br>    A comma-separated list of CodeQL languages to analyze.<br><br>    Due to the performance benefit of parallelizing builds, we recommend specifying languages to<br>    analyze using a matrix and providing `\$\&#123;&#123; matrix.language &#125;&#125;` as this input.<br><br>    For more information, see<br>    https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/customizing-your-advanced-setup-for-code-scanning#changing-the-languages-that-are-analyzed.<br></code></pre></td></tr></table></figure><p>顾名思义，该参数用于设置CodeQL对于当前源代码应该分析哪些编程语言的漏洞。源代码中涉及java语言，此处填写java即可，如果涉及其他语言，则填写其他语言，如果有多种编程语言，则填写多种即可。建议手动填写。虽然CodeQL可以根据源代码各文件的后缀名分析出当前源代码使用了哪些编程语言，但是此操作消耗性能，故建议手动填写，通过$的方式填写。</p><h4 id="build-mode"><a href="#build-mode" class="headerlink" title="build-mode"></a>build-mode</h4><p>该文档里官方写的注释为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">build-mode:<br>  description: &gt;-<br>    The build mode that will be used to analyze the language. This input is only available when<br>    analyzing a single CodeQL language per job, for example using a matrix.<br><br>    Available build modes will differ based on the language being analyzed. One of:<br><br>    - `none`:      The database will be created without building the source code.<br>                   Available for all interpreted languages and some compiled languages.<br>    - `autobuild`: The database will be created by attempting to automatically build the source<br>                   code. Available for all compiled languages.<br>    - `manual`:   The database will be created by building the source code using a manually<br>                   specified build command. To use this build mode, specify manual build steps in<br>                   your workflow between the `init` and `analyze` steps. Available for all<br>                   compiled languages.<br></code></pre></td></tr></table></figure><p>在使用matrix传递输入的时候，可以设置该参数。一般不需要额外设置build-mode，一般CodeQL都会选择当前场景下合适的参数。所有可以设置的值如下：</p><ul><li><p>none：codeql不会尝试去编译源代码，database被创建了，但是不会存储编译相关信息。对于编译型语言，设置该模式时需要保证所有的编译操作都在init之前完成，且编译操作命令需要手动指定，比如：</p><blockquote><p>不是所有编译型语言这个参数都可以设置为none，比如golang就不可以，我测试了一下，设置了就会报错：</p><p><img src="/../images/image-20241103191546363.png" alt="image-20241103191546363"></p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">jobs:</span><br> <span class="hljs-attr">analyze:</span><br>   <span class="hljs-attr">name:</span> <span class="hljs-string">Analyze</span><br>   <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>   <span class="hljs-attr">steps:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">repository</span><br>     <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">JDK</span> <span class="hljs-number">11</span><br>     <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-java@v2</span><br>     <span class="hljs-attr">with:</span><br>       <span class="hljs-attr">java-version:</span> <span class="hljs-string">&#x27;11&#x27;</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">project</span><br>     <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">       mvn clean install # 手动指定的编译命令</span><br><span class="hljs-string"></span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Initialize</span> <span class="hljs-string">CodeQL</span><br>     <span class="hljs-attr">uses:</span> <span class="hljs-string">github/codeql-action/init@v1</span><br>     <span class="hljs-attr">with:</span><br>       <span class="hljs-attr">languages:</span> <span class="hljs-string">java</span><br>       <span class="hljs-attr">build-mode:</span> <span class="hljs-string">none</span>  <span class="hljs-comment"># 指定为 none 模式</span><br></code></pre></td></tr></table></figure></li><li><p>autobuild：CodeQL会努力去自动编译源代码生成数据库，比如对于maven项目，会运行maven构建命令。database会存储编译相关信息。</p></li><li><p>manual：编译命令不再是CodeQL自己检测分析出来的，而是手动指定的，可以在init之后指定，指定之后运行到编译命令时CodeQL会将编译信息存储到数据库中。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">- name: Initialize CodeQL<br>  uses: github/codeql-action/init@v1<br>  with:<br>    languages: java<br>    build-mode: manual  # 指定为 manual 模式<br>  <br>- name: Build project<br>  run: |<br>    # 在这里添加你的编译命令，例如使用 Maven 进行构建<br>    mvn clean install<br>  <br>- name: Perform CodeQL Analysis<br>  uses: github/codeql-action/analyze@v1<br></code></pre></td></tr></table></figure></li></ul><h3 id="analyze-1"><a href="#analyze-1" class="headerlink" title="analyze"></a>analyze</h3><p>所有可以传的参数参考官方文档：<a href="https://github.com/github/codeql-action/blob/main/analyze/action.yml">https://github.com/github/codeql-action/blob/main/analyze/action.yml</a> 的inputs部分，下面介绍其中比较重要的配置：</p><h4 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h4><p>其官方文档上的注释为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">upload:</span><br>  <span class="hljs-attr">description:</span> <span class="hljs-string">&gt;-</span><br><span class="hljs-string">    Upload the SARIF file to Code Scanning.</span><br><span class="hljs-string">    Defaults to &#x27;always&#x27; which uploads the SARIF file to Code Scanning for successful and failed runs.</span><br><span class="hljs-string">    &#x27;failure-only&#x27; only uploads debugging information to Code Scanning if the workflow run fails, for users post-processing the SARIF file before uploading it to Code Scanning.</span><br><span class="hljs-string">    &#x27;never&#x27; avoids uploading the SARIF file to Code Scanning, even if the code scanning run fails. This is not recommended for external users since it complicates debugging.</span><br></code></pre></td></tr></table></figure><p>该参数用于设置CodeQL是否会将结果上传到github上，默认为always，即CodeQL会将结果上传到github上，这样在pull request中或者repository的Security Tab中可以看到CodeQL分析的结果。如果设置为failure-only，则只会在workflow运行失败的时候CodeQL才将自己debug的信息上传到github便于分析。never即在不管成功还是失败的时候都不上传上去。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>下面以最常见的javascript项目和java项目为例子，分别为编译型语言和解释型语言，</strong></p><h3 id="javascript项目（前端）"><a href="#javascript项目（前端）" class="headerlink" title="javascript项目（前端）"></a>javascript项目（前端）</h3><p>解释型语言比较简单，在CodeQL中不用关心编译问题，以javascript为例，在<code>.github/workflows/codeql.yml</code>下创建如下内容，更新至github仓库。</p><p>可以配置为如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">&quot;CodeQL&quot;</span><br><br><span class="hljs-attr">on:</span><br> <span class="hljs-attr">push:</span><br>   <span class="hljs-attr">branches:</span> <br>     <span class="hljs-bullet">-</span> <span class="hljs-string">develop</span> <span class="hljs-comment"># 更新该分支的代码会触发codeql</span><br> <span class="hljs-attr">workflow_dispatch:</span> <span class="hljs-comment"># 手动选择分支触发</span><br> <span class="hljs-attr">schedule:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&#x27;0 14 * * *&#x27;</span> <span class="hljs-comment"># 这是需要写UTC时间，实际上会在北京时间运行每天晚上10点开始调度运行</span><br><br><span class="hljs-attr">jobs:</span><br> <span class="hljs-attr">analyze:</span><br>   <span class="hljs-attr">name:</span> <span class="hljs-string">Analyze</span><br>   <span class="hljs-attr">runs-on:</span> <span class="hljs-string">self-hosted</span><br>   <span class="hljs-attr">permissions:</span><br>     <span class="hljs-attr">actions:</span> <span class="hljs-string">read</span><br>     <span class="hljs-attr">contents:</span> <span class="hljs-string">read</span><br>     <span class="hljs-attr">security-events:</span> <span class="hljs-string">write</span><br><br>   <span class="hljs-attr">strategy:</span><br>     <span class="hljs-attr">fail-fast:</span> <span class="hljs-literal">false</span><br>     <span class="hljs-attr">matrix:</span><br>       <span class="hljs-attr">language:</span> [ <span class="hljs-string">&#x27;typescript&#x27;</span> ] <span class="hljs-comment"># typescript 支持扫描分析.ts, .tsx, .mts, .cts后缀的文件</span><br><br>   <span class="hljs-attr">steps:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">repository</span><br>     <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Get</span> <span class="hljs-string">latest</span> <span class="hljs-string">commit</span> <span class="hljs-string">info</span><br>     <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">      CURRENT_BRANCH=$(git branch --show-current)</span><br><span class="hljs-string">      echo &quot;Using branch: $CURRENT_BRANCH&quot;</span><br><span class="hljs-string">      COMMIT_ID=$(git log -1 --format=&quot;%H&quot;)</span><br><span class="hljs-string">      echo &quot;Latest Commit ID: $COMMIT_ID&quot;</span><br><span class="hljs-string">      COMMIT_MESSAGE=$(git log -1 --format=&quot;%s&quot;)</span><br><span class="hljs-string">      echo &quot;Latest Commit Message: $COMMIT_MESSAGE&quot;</span><br><span class="hljs-string">      COMMIT_AUTHOR=$(git log -1 --format=&quot;%an&quot;)</span><br><span class="hljs-string">      echo &quot;Latest Commit Author: $COMMIT_AUTHOR&quot;</span><br><span class="hljs-string"></span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Initialize</span> <span class="hljs-string">CodeQL</span><br>     <span class="hljs-attr">uses:</span> <span class="hljs-string">github/codeql-action/init@v3</span><br>     <span class="hljs-attr">with:</span><br>       <span class="hljs-attr">languages:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.language</span> <span class="hljs-string">&#125;&#125;</span><br><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Perform</span> <span class="hljs-string">CodeQL</span> <span class="hljs-string">Analysis</span><br>     <span class="hljs-attr">uses:</span> <span class="hljs-string">github/codeql-action/analyze@v3</span><br>     <span class="hljs-attr">with:</span><br>       <span class="hljs-attr">category:</span> <span class="hljs-string">&quot;/language:$<span class="hljs-template-variable">&#123;&#123;matrix.language&#125;&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="java项目（后端）"><a href="#java项目（后端）" class="headerlink" title="java项目（后端）"></a>java项目（后端）</h3><p>java用了自定义的编译命令gradle，运行这个命令之前需要设置java环境和gradle环境，这个分别是通过了actions&#x2F;setup-java@v4和gradle&#x2F;actions&#x2F;setup-gradle@v3实现的。</p><p>可以参考如下写法：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">&quot;CodeQL&quot;</span><br><br><span class="hljs-attr">on:</span><br> <span class="hljs-attr">push:</span><br>   <span class="hljs-attr">branches:</span> <br>     <span class="hljs-bullet">-</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 更新该分支的代码会触发codeql流程</span><br> <span class="hljs-attr">workflow_dispatch:</span> <span class="hljs-comment"># 手动选择分支触发codeql流程</span><br> <span class="hljs-attr">schedule:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&#x27;0 14 * * *&#x27;</span> <span class="hljs-comment"># 这是需要写UTC时间，实际上会在北京时间运行每天晚上10点开始调度运行</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">analyze:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">Analyze</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">self-hosted</span><br>    <span class="hljs-attr">permissions:</span><br>      <span class="hljs-attr">actions:</span> <span class="hljs-string">read</span><br>      <span class="hljs-attr">contents:</span> <span class="hljs-string">read</span><br>      <span class="hljs-attr">security-events:</span> <span class="hljs-string">write</span><br><br>    <span class="hljs-attr">strategy:</span><br>      <span class="hljs-attr">fail-fast:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">matrix:</span><br>        <span class="hljs-attr">language:</span> [<span class="hljs-string">&#x27;java&#x27;</span>] <span class="hljs-comment"># 支持扫描分析 .java 后缀的文件</span><br><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">repository</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Java</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-java@v4</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">distribution:</span> <span class="hljs-string">&#x27;oracle&#x27;</span><br>        <span class="hljs-attr">java-version:</span> <span class="hljs-number">17.0</span><span class="hljs-number">.12</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Gradle</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">gradle/actions/setup-gradle@v3</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">gradle-version:</span> <span class="hljs-number">8.5</span><br><br>    <span class="hljs-comment"># Initializes the CodeQL tools for scanning.</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Initialize</span> <span class="hljs-string">CodeQL</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">github/codeql-action/init@v3</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">languages:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.language</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">queries:</span> <span class="hljs-string">security-extended</span><br>        <br>    <span class="hljs-comment"># run 里写的是打包jar包的命令</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        gradle clean jar -x test</span><br><span class="hljs-string"></span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Perform</span> <span class="hljs-string">CodeQL</span> <span class="hljs-string">Analysis</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">github/codeql-action/analyze@v3</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">category:</span> <span class="hljs-string">&quot;/language:$<span class="hljs-template-variable">&#123;&#123;matrix.language&#125;&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>提交代码或者在Github Action中手动选择分支运行CodeQL后，查看项目的Security Tab，点击Code scanning，所有的漏洞都会类似如下显示：</p><p><img src="/../images/image-20250124164202031.png" alt="image-20250124164202031"></p><p>如果项目Code scanning没有显示任何Open的漏洞，想查看效果的话可以自行搜索“codeql xx语言 漏洞模拟”提交漏洞代码等CodeQL运行完毕后查看Security Tab。</p><p>当漏洞修复后，重新运行codeql则漏洞会自动从Open状态变为Closed状态。</p><p>下面模拟一个漏洞：</p><p>假如我想手动模拟typescript的漏洞，让codeql检测出来，模拟方法就是新建一个tsx文件，写上如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Client</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pg&#x27;</span>;<br><br><span class="hljs-comment">// 创建 PostgreSQL 客户端</span><br><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>(&#123;<br> <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;dbuser&#x27;</span>,<br> <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;database.server.com&#x27;</span>,<br> <span class="hljs-attr">database</span>: <span class="hljs-string">&#x27;mydb&#x27;</span>,<br> <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;secretpassword&#x27;</span>,<br> <span class="hljs-attr">port</span>: <span class="hljs-number">5432</span>,<br>&#125;);<br><br>client.<span class="hljs-title function_">connect</span>();<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserByUsername</span>(<span class="hljs-params">username: string</span>) &#123;<br> <span class="hljs-comment">// 不安全的查询，直接使用用户输入构建 SQL 查询</span><br> <span class="hljs-keyword">const</span> query = <span class="hljs-string">`SELECT * FROM users WHERE username = &#x27;<span class="hljs-subst">$&#123;username&#125;</span>&#x27;`</span>;<br> <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">query</span>(query);<br> <span class="hljs-keyword">return</span> res.<span class="hljs-property">rows</span>;<br>&#125;<br><br><span class="hljs-comment">// 模拟用户输入</span><br><span class="hljs-keyword">const</span> userInput = <span class="hljs-string">&quot;admin&#x27; OR &#x27;1&#x27;=&#x27;1&quot;</span>;<br><span class="hljs-title function_">getUserByUsername</span>(userInput).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error executing query&#x27;</span>, err.<span class="hljs-property">stack</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>codeql会报出如下错误：</p><p><img src="/../images/image-20241103191628919.png" alt="image-20241103191628919"></p><p>且可以在项目的Security下看到codeql的反馈：</p><p><img src="/../images/image-20241103191644156.png" alt="image-20241103191644156"></p><p>java模拟的话，可以参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendNotification</span><span class="hljs-params">(String subject, Map&lt;String, Object&gt; paramMap)</span> &#123;<br>       <span class="hljs-type">NotificationRequest</span> <span class="hljs-variable">notificationRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotificationRequest</span>();<br>       notificationRequest.setTemplateId(templateId);<br>       notificationRequest.setParamMap(paramMap);<br>       notificationRequest.setTitle(subject + <span class="hljs-string">&quot;[&quot;</span> + profile + <span class="hljs-string">&quot;]&quot;</span>);<br>       <span class="hljs-type">NotificationResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> notificationService.sendNotification(notificationRequest);<br>       log.info(<span class="hljs-string">&quot;SystemErrorSender.sendNotification, response=&#123;&#125;&quot;</span>, response);<br>       <span class="hljs-keyword">if</span> (response == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br></code></pre></td></tr></table></figure><p>主要是log那一行，会通过codeql被检测出来。检测效果参考</p><p><img src="/../images/image-20241103191657228.png" alt="image-20241103191657228"></p><h2 id="配置忽略一些规则"><a href="#配置忽略一些规则" class="headerlink" title="配置忽略一些规则"></a>配置忽略一些规则</h2><p>默认情况下，codeql会使用很多规则查询，然后将检查出来的所有漏洞在Security Tab的Open下展示。理论上所有的漏洞都是需要修复的，但是如果有一些漏洞是团队允许的，或者是该漏洞代码太多短时间没有时间修复，可以配置codeql忽略该漏洞，配置完毕之后重新运行codeql则被配置的漏洞不会显示在Open下。下面介绍如何配置。本次介绍使用的只是一个简单的项目，不是当前团队正在开发的项目，只是作为参考。</p><h3 id="配置前codeql运行"><a href="#配置前codeql运行" class="headerlink" title="配置前codeql运行"></a>配置前codeql运行</h3><p>比如某次运行codeql后，运行结果如图，假设开发人员没有时间修复红框内的“Incomplete string escaping or encoding”类型的漏洞，想配置该中漏洞不被检查出来，即让该漏洞不在Open下显示。下面介绍如何配置。</p><p><img src="/../images/image-20250124164224047.png" alt="image-20250124164224047"></p><h3 id="确定Rule-ID"><a href="#确定Rule-ID" class="headerlink" title="确定Rule ID"></a>确定Rule ID</h3><p>点击“Incomplete string escaping or encoding”查看具体内容，查看其Rule ID，由图上可见“Incomplete string escaping or encoding”类型的漏洞的Rule ID为js&#x2F;incomplete-sanitization</p><p><img src="/../images/image-20241115154138669.png" alt="image-20241115154138669"></p><h3 id="codeql的配置文件"><a href="#codeql的配置文件" class="headerlink" title="codeql的配置文件"></a>codeql的配置文件</h3><p>在<code>.github</code>下新建<code>codeql</code>目录，在<code>codeql</code>下新建codeql-config.yml文件，填写如下内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">queries:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">security-extended</span><br><span class="hljs-attr">query-filters:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">exclude:</span><br>      <span class="hljs-attr">id:</span> <span class="hljs-string">js/incomplete-sanitization</span> <span class="hljs-comment"># 即上述提到的 Rule ID</span><br></code></pre></td></tr></table></figure><p>最终的效果为：</p><p><img src="/../images/image-20241115154310182.png" alt="image-20241115154310182"></p><p>再在workflow的配置文件添加对应的配置文件配置，即编辑<code>/github/workflows/codeql.yml</code>文件，在init action中添加配置文件参数，效果如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Initialize</span> <span class="hljs-string">CodeQL</span><br>  <span class="hljs-attr">uses:</span> <span class="hljs-string">github/codeql-action/init@v3</span><br>  <span class="hljs-attr">with:</span><br>    <span class="hljs-attr">languages:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.language</span> <span class="hljs-string">&#125;&#125;</span><br>    <span class="hljs-attr">config-file:</span> <span class="hljs-string">./.github/codeql/codeql-config.yml</span> <span class="hljs-comment"># 添加该行</span><br></code></pre></td></tr></table></figure><h3 id="配置后codeql运行"><a href="#配置后codeql运行" class="headerlink" title="配置后codeql运行"></a>配置后codeql运行</h3><p>提交上述变更，在github action中手动触发codeql的运行，执行完毕后结果为：</p><p><img src="/../images/image-20241115154701786.png" alt="image-20241115154701786"></p><p>可见刚刚的漏洞已经被移动到了Closed下。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>多条代码可能会触发同一个规则</strong>：补充：在上述的yml中配置的<code>id: js/incomplete-sanitization</code>会把所有触发该规则ID的代码都忽略掉，不让其在Open下显示。实际开发的代码中可能有多行代码都触发了<code>id: js/incomplete-sanitization</code>规则，配置了<code>id: js/incomplete-sanitization</code>后Closed下会新增多条，对应触发规则的多行代码。</p><p><strong>忽略多条规则：</strong>假设开发想配置忽略多条规则，在query-filters:下追加即可，参考如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">query-filters:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">exclude:</span><br>      <span class="hljs-attr">id:</span> <span class="hljs-string">js/incomplete-sanitization</span> <span class="hljs-comment"># 即上述提到的 Rule ID</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">exclude:</span><br>      <span class="hljs-attr">id:</span> &#123;<span class="hljs-string">rule2</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>后续修复</strong>：假设开发人员后续有空修复了上述的“Incomplete string escaping or encoding”类型的漏洞代码，则只需要将<code>id: js/incomplete-sanitization</code>从query-filters删除，如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">query-filters:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">exclude:</span><br>      <span class="hljs-attr">id:</span> &#123;<span class="hljs-string">rule2</span>&#125;<br></code></pre></td></tr></table></figure><p>然后在github action中手动触发codeql运行，则漏洞代码会从Closed下回到Open下。</p><p>漏洞代码修复完毕后，重新在github action中手动触发codeql运行，运行完毕后漏洞代码会自动从Open下转移到Closed下，表示漏洞代码修复完成。</p><h3 id="下载插件源代码"><a href="#下载插件源代码" class="headerlink" title="下载插件源代码"></a>下载插件源代码</h3><p>除了直接指定uses: github&#x2F;codeql-action&#x2F;init@v3，也可以下载codeql的源代码，使用源代码检查，参考如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs shell">name: &quot;CodeQL&quot;<br><br>on:<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> push:</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash"> branches:</span> <br><span class="hljs-meta prompt_">  # </span><span class="language-bash">   - develop <span class="hljs-comment"># 更新该分支的代码会触发codeql</span></span><br> workflow_dispatch: # 手动选择分支触发<br> schedule:<br>    - cron: &#x27;0 2 * * *&#x27; # 这是需要写UTC时间，实际上会在北京时间每天早上10点开始调度运行<br><br>jobs:<br> analyze:<br>   name: Analyze<br>   runs-on: self-hosted<br>   permissions:<br>     actions: read<br>     contents: read<br>     security-events: write<br><br>   strategy:<br>     fail-fast: false<br>     matrix:<br>       language: [ &#x27;typescript&#x27; ] # typescript 支持扫描分析.ts, .tsx, .mts, .cts后缀的文件<br><br>   steps:<br>   - name: Checkout repository<br>     uses: actions/checkout@v4<br>   - name: Get latest commit info<br>     run: |<br>      CURRENT_BRANCH=$(git branch --show-current)<br>      echo &quot;Using branch: $CURRENT_BRANCH&quot;<br>      COMMIT_ID=$(git log -1 --format=&quot;%H&quot;)<br>      echo &quot;Latest Commit ID: $COMMIT_ID&quot;<br>      COMMIT_MESSAGE=$(git log -1 --format=&quot;%s&quot;)<br>      echo &quot;Latest Commit Message: $COMMIT_MESSAGE&quot;<br>      COMMIT_AUTHOR=$(git log -1 --format=&quot;%an&quot;)<br>      echo &quot;Latest Commit Author: $COMMIT_AUTHOR&quot;<br>   - name: Download latest CodeQL v3<br>     run: |<br>      REPO=&quot;github/codeql-action&quot;<br>      LATEST_V3_TAG=$(curl -s https://api.github.com/repos/$REPO/releases | jq -r &#x27;.[] | select(.tag_name | startswith(&quot;v3&quot;)) | .tag_name&#x27; | head -n 1) # 注意这部分❗ ❗ <br>      TAR_URL=&quot;https://github.com/$REPO/tarball/$LATEST_V3_TAG&quot;<br>      echo &quot;Latest v3 Tag: $LATEST_V3_TAG&quot;<br>      echo &quot;Downloading CodeQL Action from: $TAR_URL&quot;<br>      curl -L $TAR_URL -o codeql-action.tar.gz<br>      mkdir -p codeql-action<br>      tar -xzf codeql-action.tar.gz -C codeql-action --strip-components=1<br>      echo &quot;CodeQL Action (v3) downloaded and extracted.&quot;<br><br>   - name: Initialize CodeQL<br>     uses: ./codeql-action/init<br>     with:<br>       languages: $&#123;&#123; matrix.language &#125;&#125;<br>       queries: security-and-quality<br><br>   - name: Perform CodeQL Analysis<br>     uses: ./codeql-action/analyze<br>     with:<br>       category: &quot;/language:$&#123;&#123;matrix.language&#125;&#125;&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用chatgpt AI编程的心得总结</title>
    <link href="/2024/12/09/%E4%BD%BF%E7%94%A8chatgpt%20AI%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BF%83%E5%BE%97%E6%80%BB%E7%BB%93/"/>
    <url>/2024/12/09/%E4%BD%BF%E7%94%A8chatgpt%20AI%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BF%83%E5%BE%97%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>我使用的是chatgpt的官方AI，地址为：<a href="https://chatgpt.com/">https://chatgpt.com/</a> </p><h2 id="模型对比"><a href="#模型对比" class="headerlink" title="模型对比"></a>模型对比</h2><blockquote><p>官方文档： <a href="https://help.openai.com/en/articles/7102672-how-can-i-access-gpt-4-gpt-4-turbo-gpt-4o-and-gpt-4o-mini">https://help.openai.com/en/articles/7102672-how-can-i-access-gpt-4-gpt-4-turbo-gpt-4o-and-gpt-4o-mini</a></p></blockquote><p>GPT-3.5：支持声音的输入输出，16K上下文长度，免费</p><p>GPT-4：支持图片和声音的输入输出，128K上下文长度，收费。答案准确度比3.5更高。</p><p>GPT-4o（omni 全能型）：比GPT-4提升了速度，最新版本，支持输入和输出图片，支持输出和输入声音，可以输出视频（但是视频是从网络查找的而不是自己生成的，如下图的视频是从youtube上找的）。适合需要高精度和大量数据处理的任务。使用效果如下：</p><p><img src="/../images/image-20241218104551953.png" alt="image-20241218104551953"></p><p>GPT-4o mini：最轻量的模型，支持图片和声音的输入输出，有GPT-4o的基本功能，不像GPT-4o一样可以处理大量数据任务，适合聊天机器人会话。价格也比GPT-4o低。</p><p><strong>对于长代码，推荐使用canvas，在询问AI时指定”use canvas”即可。</strong></p><blockquote><p>HTML5 的 canvas 标签元素让开发者 可以使用 JavaScript 在网页上动态的绘制和处理图形</p><p>chagpt的canvas更有利于查看代码，Canvas在一个单独的窗口中打开。</p><p>AI会逐行修改代码。</p></blockquote><h2 id="AI项目开发步骤"><a href="#AI项目开发步骤" class="headerlink" title="AI项目开发步骤"></a>AI项目开发步骤</h2><p>先搭一个框架，显示最基础的页面，此时数据都是静态的。确保程序编译通过可以运行。</p><p>增加其他页面，实现页面之间的跳转。</p><p>将数据变成动态的，即从API获取（此时固定token）。此时代码还在一个文件里，且代码超过1000行老，让AI拆分到多个文件（可自定义哪些包，对于有些频繁执行的代码，考虑将其放到utils包里），需要注意各个文件之间如何互相引用。问AI的时候可以说当前XXX文件的代码如下。</p><blockquote><p>项目开发中的注意事项：</p><p>使用AI编程中，重点在于如何拆分项目任务，训练AI让AI给出更准确的回复，而不是自己写代码解决问题。不用太关注代码的细节，关注代码是否执行成功。</p><p>开发过程中记录完成了哪些，哪些TODO。</p><p>多写注释，注释每个文件对应的业务</p><p>在AI写代码中，在对比AI代码的改动中，有空可以关注修改的部分，这样即使对框架和编程语言不了解，但是在对比的过程中也会渐渐知道当前项目开发的一些基础知识（比如一些小的更改可能自己就知道怎么做了，某个配置文件是干什么的）。</p><p>对于项目，只关注改动部分，其他未变更的部分可暂时不用关注。</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>尽量使用英文询问，即使询问有语法错误，即使自己觉得问题都没有描述清楚，都可以先问AI</p></li><li><p>可以贴图询问，贴多张图，用红框将重点部分标出来，询问”in the red box, I did not get the expected result, I hope XXX, but now the current result is YYY, change the code and show me the full code”</p></li><li><p>对比input code和output code的更改：比如在VSCode中，git stage暂存区存放确认过的代码，工作区存放和对比正在开发的内容，对比的工作放在工作区做。建议将代码格式化排版，这样方便查看，然后再进行对比。</p></li><li><p>AI有的时候会给出错误的答案，或者听不懂，此时需要先去搜索引擎查询</p></li><li><p>AI可能会编辑代码失败，此时最好的办法就是重开一个会话</p></li></ul><p><img src="/../images/image-20241122132958097.png" alt="image-20241122132958097"></p><ul><li>输入的代码很长时，AI给的回复可能会折叠回复</li></ul><p><img src="/../images/image-20241122134114921.png" alt="image-20241122134114921"></p><ul><li><p>canvas对代码的长度有限制，canvas最长显示1160行代码</p></li><li><p>建议单个文件的代码超过1000行的话，就拆分到多个文件中</p></li><li><p>注意AI回复非代码部分，看是否其指定了修改的文件名和文件里的位置。</p></li><li><p>当AI在一个会话中持续出错时，最好的方式就是新开一个会话，AI会记住之前的内容的</p></li><li><p>AI编辑代码时，可能会删除或者修改输入的代码，如果可以自行确认关键更改部分，自行更改即可。如果不确定更改部分，可以把问题再次输入并且指定“don’t delete any code just modify”。如果再次失败，把问题再次输入并且指定“don’t give the full code just tell me which part I should modify, for those parts, tell me the previous content and the content after modifying”。如果再次失败，尝试拆分代码到多个文件。</p></li><li><p>canvas 代码编辑注意：当当前页面有右边代码框时，框里有代码A时，再给AI一段代码B让AI修改，AI可能会直接基于右边代码框里的代码A修改，而不是基于我给出的新的代码B，此时的解决办法就是重开一个会话。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSO集成介绍</title>
    <link href="/2024/12/01/SSO%E9%9B%86%E6%88%90%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/12/01/SSO%E9%9B%86%E6%88%90%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SSO是一个用户验证方式，比如可以通过微软的Azure来实现。企业可以使用微软的Azure来管理内部员工的登录。</p><h2 id="使用SSO的流程"><a href="#使用SSO的流程" class="headerlink" title="使用SSO的流程"></a>使用SSO的流程</h2><p>主要流程如下：</p><ol><li>企业管理员将企业内的各个系统的登录方式都配置为Azure SSO</li><li>当有新员工入职时，企业管理员将员工信息录入Azure，主要会录入用户名、初始密码等</li><li>新员工登录企业内<strong>管理系统</strong>，修改密码（企业内管理系统在处理修改密码请求时，会请求Azure的API，修改Azure里用户的密码）</li><li>新员工登录企业内的其他<strong>业务系统</strong>，业务系统会在登录阶段跳转到微软的Azure SSO登陆页面，用户在该页面输入用户名和密码（Azure系统检测到用户名和密码正确后，会回传一个token给业务系统，业务系统拿到该token后，使用该token请求Azure的API，获取用户信息，比如用户名、用户所在部门等），用户名和密码输入成功后，会跳回业务系统页面，用户进入业务系统正常操作</li></ol><p>综上，用户的用户名和密码会存储在Azure的数据库中，而不是公司的数据库中</p><h2 id="配置应用使用SSO"><a href="#配置应用使用SSO" class="headerlink" title="配置应用使用SSO"></a>配置应用使用SSO</h2><p>因为开发的app应用需要和公司的其他应用一样，需要配置为SSO登陆。下面介绍上面流程的第一步，如何配置应用的登陆方式为Azure SSO。</p><p>主要参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 当前域名<br>LOGIN_REDIRECT=https://xxx.com<br>// 重定向地址<br>OATH2_REDIRECT_URL=https://xxx.com/user/login_callback<br>// client_id，在app的详情中查看，由管理员给的<br>OATH2_CLIENT_ID=aaaaa-aaaa-aaaa-baaa-aaaaaa<br>// tent_id，密钥，管理员给的<br>OAUTH_TENANT_ID=42xxx-f<br>// 在Azure上生成的，验证机器是否允许登陆<br>OATH2_CLIENT_SECRET=mv~fffr<br></code></pre></td></tr></table></figure><p>上面的这些参数都是在微软的Azure后台配置的。</p><p>app应用一般会使用一些SDK来集成SSO，SDK中需要配置的参数也差不多为上述参数。</p><p>最终效果为：当用户点击登陆，即调用<strong>业务系统</strong>的登录接口时，业务系统会马上调用到Azure的服务去登陆，这是一个重定向的动作。这时候浏览器会跳出Microsoft的登陆</p><blockquote><p>比如flutter中，可以使用aad_oauth SDK来实现SSO，主要就是调用如下两个函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">  <span class="hljs-keyword">final</span> config = Config(<br>    navigatorKey: <span class="hljs-string">&quot;xxx&quot;</span>,<br>    tenant: <span class="hljs-string">&quot;xxx&quot;</span>,<br>    clientId: <span class="hljs-string">&quot;xxx&quot;</span>,<br>    redirectUri: <span class="hljs-string">&quot;xxx&quot;</span>,<br>    scope: <span class="hljs-string">&quot;xxx&quot;</span>,<br>  );<br>  _oauth = AadOAuth(config);<br><span class="hljs-keyword">await</span> oauth.login();<br>  <span class="hljs-built_in">String?</span> accessToken = <span class="hljs-keyword">await</span> oauth.getAccessToken();<br></code></pre></td></tr></table></figure><p>第二个返回的accessToken就是传给业务系统的token</p><p>总之oauth.login()和oauth.getAccessToken很神奇，他们的执行逻辑大概是：会自动使用之前在该设备上创建的accessToken，如果accessToken过期会先尝试申请新的（应该是用户名和密码都没改的情况下才能成功），如果申请新的失败会让用户重新登陆</p></blockquote><h2 id="OAuth2标准"><a href="#OAuth2标准" class="headerlink" title="OAuth2标准"></a>OAuth2标准</h2><p>微软的Azure使用的就是OAuth2标准，这是关于授权的开放网络标准，在全世界得到广泛应用。</p><p>OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用（比如上述的<strong>业务系统</strong>）进入系统（即<strong>微软的Azure系统</strong>），获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</p><p>OAuth2中有几个主要概念，</p><p>Third-party application：第三方应用程序，如上述的业务系统</p><p>Resource Owner：资源所有者，如上述的员工，员工拥有自己的个人信息资源</p><p>Authorization server：认证服务器，即专门用来处理认证的服务器，如上述的微软Azure服务</p><p>Resource server：存放Resource Owner的资源的服务器，一般指数据库的服务器</p><p>参考</p><p><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p><p><a href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">https://www.ruanyifeng.com/blog/2019/04/oauth_design.html</a></p><p><a href="https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></p>]]></content>
    
    
    <categories>
      
      <category>mobile</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>github action的一些小tips</title>
    <link href="/2024/11/10/github%20action%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8Ftips/"/>
    <url>/2024/11/10/github%20action%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8Ftips/</url>
    
    <content type="html"><![CDATA[<p>本人中都是在github action中自动化操作时的一些小tips，没有什么整体大纲，所以以平铺的标题展开。</p><h2 id="if中无法使用env"><a href="#if中无法使用env" class="headerlink" title="if中无法使用env"></a>if中无法使用env</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">env:<br>  COMMENT_TO_RELEASE: &#x27;run tests&#x27;<br>jobs:<br> pr-comment:<br>   runs-on: self-hosted<br>   if: github.event.comment.body == &#x27;$&#123;&#123;env.COMMENT_TO_RELEASE&#125;&#125;&#x27;<br></code></pre></td></tr></table></figure><p>比如这里，执行到最后一行会报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Invalid workflow file: .github/workflows/demo1.yml#L12<br>The workflow is not valid. .github/workflows/demo1.yml (Line: 12, Col: 8): Unrecognized named-value: &#x27;env&#x27;. Located at position 1 within expression: env.COMMENT_TO_RELEASE<br></code></pre></td></tr></table></figure><p>即时换成其他写法，比如<code>$&#123;&#123;env.COMMENT_TO_RELEASE&#125;&#125;</code>或者<code>env.COMMENT_TO_RELEASE</code>等等。除非我改成<code>if: github.event.comment.body == &#39;run tests&#39;</code>，搜寻了下发现，github好像不太支持：</p><p><a href="https://github.com/actions/runner/issues/1661">https://github.com/actions/runner/issues/1661</a></p><p>算了，还是在if里不用env吧。</p><h2 id="打印action里所有内容"><a href="#打印action里所有内容" class="headerlink" title="打印action里所有内容"></a>打印action里所有内容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">print-event:<br> runs-on: ubuntu-latest<br> steps:<br>   - name: Checkout repository<br>     uses: actions/checkout@v2<br><br>   - name: Dump GitHub context<br>     env:<br>       GITHUB_CONTEXT: $&#123;&#123; toJson(github) &#125;&#125;<br>     run: echo &quot;$GITHUB_CONTEXT&quot;<br><br>   - name: Dump event payload<br>     run: |<br>       echo &quot;Event payload:&quot;<br>       echo &quot;$&#123;&#123; toJson(github.event) &#125;&#125;&quot;<br></code></pre></td></tr></table></figure><h2 id="复用action"><a href="#复用action" class="headerlink" title="复用action"></a>复用action</h2><p>参考：<a href="https://stackoverflow.com/questions/71458189/github-action-workflow-call-does-not-use-up-to-date-input-values">https://stackoverflow.com/questions/71458189/github-action-workflow-call-does-not-use-up-to-date-input-values</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Main</span> <span class="hljs-string">Workflow</span><br><br><span class="hljs-attr">on:</span> [<span class="hljs-string">push</span>]<br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">use-reusable-workflow:</span><br>    <span class="hljs-attr">uses:</span> <span class="hljs-string">./.github/workflows/reusable_workflow.yml</span><br>    <span class="hljs-attr">with:</span><br>      <span class="hljs-attr">example_input:</span> <span class="hljs-string">&#x27;Hello, World!&#x27;</span><br>      <span class="hljs-attr">some_other_value:</span> <span class="hljs-string">&#x27;2323&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Reusable</span> <span class="hljs-string">Workflow</span><br><br><span class="hljs-attr">on:</span> <br>  <span class="hljs-attr">workflow_call:</span><br>    <span class="hljs-attr">inputs:</span><br>      <span class="hljs-attr">example_input:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">some_other_value:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">my-job:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Print</span> <span class="hljs-string">Inputs</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          echo &quot;Release Type: $&#123;&#123; inputs.example_input &#125;&#125;&quot;</span><br><span class="hljs-string">          echo &quot;Release Type: $&#123;&#123; inputs.some_other_value &#125;&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/../images/image-20250216162659218.png" alt="image-20250216162659218"></p><h2 id="配置定时任务"><a href="#配置定时任务" class="headerlink" title="配置定时任务"></a>配置定时任务</h2><p>Github毕竟是国外的产品，<strong>这里的定时任务指定的时间和我们中国的时区是有时差的</strong>。北京时间比Github所使用时区快8个小时。比如7月1号23点，github时间是7月1号15点。所以我们可以配置成15点或16点执行（对应北京时间的夜里11点、12点）。</p><p>github官方文档：<a href="https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#onschedule">https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#onschedule</a> You can use <code>on.schedule</code> to define a time schedule for your workflows. You can schedule a workflow to run at specific UTC times using <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/crontab.html#tag_20_25_07">POSIX cron syntax</a>. </p><p>The shortest interval you can run scheduled workflows is once every 5 minutes.</p><p>This example triggers the workflow every day at 5:30 and 17:30 UTC:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">schedule:</span><br>    <span class="hljs-comment"># * is a special character in YAML so you have to quote this string</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span>  <span class="hljs-string">&#x27;30 5,17 * * *&#x27;</span><br></code></pre></td></tr></table></figure><p>cron的写法参考 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/crontab.html#tag_20_25_07%EF%BC%8C%E6%A0%BC%E5%BC%8F%E4%B8%BA%EF%BC%9A">https://pubs.opengroup.org/onlinepubs/9699919799/utilities/crontab.html#tag_20_25_07，格式为：</a></p><blockquote><p>In the POSIX locale, the user or application shall ensure that a crontab entry is a text file consisting of lines of six fields each. The fields shall be separated by <blank> characters. The first five fields shall be integer patterns that specify the following:</blank></p><ol><li>Minute [0,59]</li><li>Hour [0,23]</li><li>Day of the month [1,31]</li><li>Month of the year [1,12]</li><li>Day of the week ([0,6] with 0&#x3D;Sunday)</li></ol></blockquote><p>我写的是这样写不知道为什么到了11:25（东八区时间）的时候没有触发</p><p><img src="/../images/image-20250216162918647.png" alt="image-20250216162918647"></p><p>查询说：有时候，GitHub Actions 的定时触发器可能会有几分钟的延迟。如果你的工作流程没有在预期时间立即运行，建议再等待几分钟来观察是否会触发。</p><p>测试了一下，会运行的，我是这样写的：</p><p><img src="/../images/image-20241031133455327.png" alt="image-20241031133455327"></p><p>定义的是20分钟的时候触发，但是真正触发延迟了十几分钟，具体可以看下图的日志，延迟了13分钟：</p><p><img src="/../images/image-20250216163007414.png" alt="image-20250216163007414"></p><p>我测了下，有时候甚至延迟半小时任务才运行，不止13分钟了。</p><h2 id="workflow-dispatch-手动发布的时候传递参数"><a href="#workflow-dispatch-手动发布的时候传递参数" class="headerlink" title="workflow_dispatch 手动发布的时候传递参数"></a>workflow_dispatch 手动发布的时候传递参数</h2><p>写法参考</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">手动选择分支，执行自动化发布 QA 测试环境的流程，使用分支为手动选择的分支</span><br>name: Manual Dev Release<br><br>on:<br>  workflow_dispatch:<br>   inputs:<br>     environment:<br>       description: &#x27;Deployment environment&#x27; # TODO: 修改注释<br>       required: true<br>       default: &#x27;dev&#x27;<br>       type: choice<br>       options:<br>         - dev  # admin<br>         - staging    # customer<br>         - production # both<br>jobs:<br>  Echo:<br>    runs-on: self-hosted<br>    steps:<br>     - name: Print environment<br>       run: echo  $&#123;&#123; github.event.inputs.environment &#125;&#125;<br>  EchoOnlyDevOrStaging:<br>    if: $&#123;&#123; github.event.inputs.environment == &#x27;dev&#x27; || github.event.inputs.environment == &#x27;staging&#x27; &#125;&#125;<br>    runs-on: self-hosted<br>    steps:<br>     - name: Print environment<br>       run: echo  $&#123;&#123; github.event.inputs.environment &#125;&#125;<br></code></pre></td></tr></table></figure><p>最终实现效果为：</p><p><img src="/../images/image-20241108094351309.png" alt="image-20241108094351309"></p><h2 id="job-amp-step之间共享变量"><a href="#job-amp-step之间共享变量" class="headerlink" title="job&amp;step之间共享变量"></a>job&amp;step之间共享变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs shell">name: &quot;Only test&quot;<br>on:<br> push:<br>   branches: <br>     - main <br> workflow_dispatch: # 手动选择分支触发<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> schedule:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    - cron: <span class="hljs-string">&#x27;0 14 * * *&#x27;</span> <span class="hljs-comment"># 这是需要写UTC时间，实际上会在北京时间运行每天晚上10点开始调度运行</span></span><br><br>jobs:<br>  setter:<br>    runs-on: self-hosted<br>    outputs:<br>      new-key: $&#123;&#123; steps.set-value.outputs.new-key &#125;&#125;<br>    steps:<br>      - id: set-value # 这个ID一定要指定，下面都是会用到它的<br>        name: Generate a value<br>        run: |<br>          value=$((RANDOM))<br>          echo &quot;new-key=$value&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;<br>      - id: read-value<br>        name: Read a value<br>        run: |<br>          echo &quot;the secret number is $&#123;&#123; steps.set-value.outputs.new-key &#125;&#125;&quot; # 因为是在一个job里，所以用step，要指定step id<br>  getter:<br>    runs-on: self-hosted<br>    needs: setter<br>    steps:<br>      - name: Access it<br>        run: |<br>          echo &quot;the secret number is $&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;<br>  getter222:<br>    runs-on: self-hosted<br>    needs: <br>    - getter<br>    - setter # 可以写成两行<br>    steps:<br>      - name: Access it<br>        run: |<br>          echo &quot;the secret number is $&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;<br><br>  getter333:<br>    runs-on: self-hosted<br>    needs: [getter222, setter] # 也可以这样写，注意一定要setter needed<br>    steps:<br>      - name: Access it<br>        run: |<br>          echo &quot;the secret number is $&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;<br></code></pre></td></tr></table></figure><p>运行显示效果：</p><p>（图上我的鼠标放在了getter222上，会直接显示它引用了setter）</p><p><img src="/../images/image-20250216163418963.png" alt="image-20250216163418963"></p><p><img src="/../images/image-20241118102931276.png" alt="image-20241118102931276"></p><h2 id="add-mask的作用"><a href="#add-mask的作用" class="headerlink" title="add-mask的作用"></a>add-mask的作用</h2><p>可以让关键信息不在终端显示</p><p>没有mask的时候，显示结果为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Only test&quot;</span><br><span class="hljs-attr">on:</span><br> <span class="hljs-attr">push:</span><br>   <span class="hljs-attr">branches:</span> <br>     <span class="hljs-bullet">-</span> <span class="hljs-string">main</span> <br> <span class="hljs-attr">workflow_dispatch:</span> <span class="hljs-comment"># 手动选择分支触发</span><br><span class="hljs-comment">#  schedule:</span><br><span class="hljs-comment">#     - cron: &#x27;0 14 * * *&#x27; # 这是需要写UTC时间，实际上会在北京时间运行每天晚上10点开始调度运行</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">setter:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">self-hosted</span><br>    <span class="hljs-attr">outputs:</span><br>      <span class="hljs-attr">new-key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">steps.set-value.outputs.new-key</span> <span class="hljs-string">&#125;&#125;</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">set-value</span> <span class="hljs-comment"># 这个ID一定要指定，下面都是会用到它的</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">Generate</span> <span class="hljs-string">a</span> <span class="hljs-string">value</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          value=$((RANDOM))</span><br><span class="hljs-string">          echo &quot;new-key=$value&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;</span><br><span class="hljs-string"></span>      <span class="hljs-comment"># - id: read-value</span><br>      <span class="hljs-comment">#   name: Read a value</span><br>      <span class="hljs-comment">#   run: |</span><br>      <span class="hljs-comment">#     p=$&#123;&#123; steps.set-value.outputs.new-key &#125;&#125;</span><br>      <span class="hljs-comment">#     echo &quot;::add-mask::$p&quot;</span><br>      <span class="hljs-comment">#     echo &quot;the secret number is $p&quot; # 因为是在一个job里，所以用step，要指定step id</span><br>  <span class="hljs-attr">getter:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">self-hosted</span><br>    <span class="hljs-attr">needs:</span> <span class="hljs-string">setter</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Access</span> <span class="hljs-string">it</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          # echo &quot;::add-mask::$&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;</span><br><span class="hljs-string">          echo &quot;the secret number is $&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;</span><br><span class="hljs-string"></span>  <span class="hljs-attr">getter222:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">self-hosted</span><br>    <span class="hljs-attr">needs:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">getter</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">setter</span> <span class="hljs-comment"># 可以写成两行</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Access</span> <span class="hljs-string">it</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          # echo &quot;::add-mask::$&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;</span><br><span class="hljs-string">          echo &quot;the secret number is $&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;</span><br><span class="hljs-string"></span><br>  <span class="hljs-attr">getter333:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">self-hosted</span><br>    <span class="hljs-attr">needs:</span> [<span class="hljs-string">getter222</span>, <span class="hljs-string">setter</span>] <span class="hljs-comment"># 也可以这样写，注意一定要setter needed</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Access</span> <span class="hljs-string">it</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          # echo &quot;::add-mask::$&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;</span><br><span class="hljs-string">          echo &quot;the secret number is $&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/image-20241118131411356.png" alt="image-20241118131411356"></p><p>添加mask，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs shell">name: &quot;Only test&quot;<br>on:<br> push:<br>   branches: <br>     - main <br> workflow_dispatch: # 手动选择分支触发<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> schedule:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    - cron: <span class="hljs-string">&#x27;0 14 * * *&#x27;</span> <span class="hljs-comment"># 这是需要写UTC时间，实际上会在北京时间运行每天晚上10点开始调度运行</span></span><br><br>jobs:<br>  setter:<br>    runs-on: self-hosted<br>    outputs:<br>      new-key: $&#123;&#123; steps.set-value.outputs.new-key &#125;&#125;<br>    steps:<br>      - id: set-value # 这个ID一定要指定，下面都是会用到它的<br>        name: Generate a value<br>        run: |<br>          value=$((RANDOM))<br>          echo &quot;new-key=$value&quot; &gt;&gt; &quot;$GITHUB_OUTPUT&quot;<br>      # - id: read-value<br>      #   name: Read a value<br>      #   run: |<br>      #     p=$&#123;&#123; steps.set-value.outputs.new-key &#125;&#125;<br>      #     echo &quot;::add-mask::$p&quot;<br>      #     echo &quot;the secret number is $p&quot; # 因为是在一个job里，所以用step，要指定step id<br>  getter:<br>    runs-on: self-hosted<br>    needs: setter<br>    steps:<br>      - name: Access it<br>        run: |<br>          echo &quot;::add-mask::$&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;<br>          echo &quot;the secret number is $&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;<br>  getter222:<br>    runs-on: self-hosted<br>    needs: <br>    - getter<br>    - setter # 可以写成两行<br>    steps:<br>      - name: Access it<br>        run: |<br>          echo &quot;::add-mask::$&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;<br>          echo &quot;the secret number is $&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;<br><br>  getter333:<br>    runs-on: self-hosted<br>    needs: [getter222, setter] # 也可以这样写，注意一定要setter needed<br>    steps:<br>      - name: Access it<br>        run: |<br>          echo &quot;::add-mask::$&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;<br>          echo &quot;the secret number is $&#123;&#123; needs.setter.outputs.new-key &#125;&#125;&quot;<br></code></pre></td></tr></table></figure><h2 id="使用cache-action"><a href="#使用cache-action" class="headerlink" title="使用cache action"></a>使用cache action</h2><p>参考 <a href="https://dwye.dev/post/github-action-npm-cache/">https://dwye.dev/post/github-action-npm-cache/</a></p><p>对于前端项目，可以使用action存储node_modules，在package.json没有变化的时候，直接用存储好的node_modules然后build。当package.json变化了，再执行install然后build。github action的配置文件如下：</p><p>大部分都在4分钟内，写法参考如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">Build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">self-hosted</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">repository</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">Node</span> <span class="hljs-string">Modules</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v4</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span><br>          <span class="hljs-comment"># cache key 包含了所有我們希望固定的資訊：OS，node 版本，以及 package-lock.json 的檔案內容，使用 hashFiles 將檔案內容轉換成字串</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">node-modules-$&#123;&#123;</span> <span class="hljs-string">runner.os</span> <span class="hljs-string">&#125;&#125;-$&#123;&#123;</span> <span class="hljs-string">matrix.node-version</span> <span class="hljs-string">&#125;&#125;-$&#123;&#123;</span> <span class="hljs-string">hashFiles(&#x27;package-lock.json&#x27;)</span> <span class="hljs-string">&#125;&#125;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">node</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v4</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">inputs.node_version</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">check-latest:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 确保使用预安装的版本</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Packages</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">test</span> <span class="hljs-string">-d</span> <span class="hljs-string">node_modules</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;node_modules exists&quot;</span> <span class="hljs-string">||</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">--legacy-peer-deps</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          echo &quot;The current node version is $(node -v)&quot;</span><br><span class="hljs-string">          npm run build:$&#123;&#123; inputs.env &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>但是实际运行的时候发现每次加载上一次运行时的缓存内容都要2分钟左右：</p><p><img src="/../images/image-20241107090633984.png" alt="image-20241107090633984"></p><h2 id="不让set-up-node插件缓存"><a href="#不让set-up-node插件缓存" class="headerlink" title="不让set-up node插件缓存"></a>不让set-up node插件缓存</h2><p>基于上一条，然后我想着不要使用cache存node_modules，直接install，修改后如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">jobs:<br>  Build:<br>    runs-on: self-hosted<br>    steps:<br>      - name: Checkout repository<br>        uses: actions/checkout@v4<br>      - name: Set up node<br>        uses: actions/setup-node@v4<br>        with:<br>          node-version: $&#123;&#123; inputs.node_version &#125;&#125;<br>          # cache: &#x27;npm&#x27;<br>      - name: Build<br>        shell: bash<br>        run: |<br>          echo &quot;The current node version is $(node -v)&quot;<br>          # [ -d &quot;node_modules&quot; ] &amp;&amp; rm -rf &quot;node_modules&quot;<br>          ls -a<br>          npm install --legacy-peer-deps<br>          npm run build:$&#123;&#123; inputs.env &#125;&#125;<br></code></pre></td></tr></table></figure><p>这次只要两分钟</p><p>主要修改就是如下：</p><p><img src="/../images/image-20241107090934974.png" alt="image-20241107090934974"></p><p>修改完了主要的变更就是：</p><p><img src="/../images/image-20241107091141664.png" alt="image-20241107091141664"></p><p>之前的效果是图上，修改完了红色的这个部分没有了。</p><p>之前红色的这个部分特别耗时。</p><p>所以# cache: ‘npm’这个注释掉可以让set-up node这个插件不再每次加载npm的缓存，加载npm缓存真的很费事，居然要5分钟左右，直接npm install不缓存node_modules居然更快</p><p>总结：<strong>加载缓存真的很耗时，虽然这个缓存文件就在runner服务器上，加载缓存有点类似解压文件，但是比解压文件慢多了。所有有时候不使用缓存直接下载是比使用缓存更快的。</strong></p><h2 id="用户评论触发workflow"><a href="#用户评论触发workflow" class="headerlink" title="用户评论触发workflow"></a>用户评论触发workflow</h2><p>有什么方法可以实现用户触发某个规则（比如在PR下评论）后才启动workflow？</p><p>在GitHub Actions中，可以通过使用GitHub的Webhooks和特定的事件触发器来实现这一目标。具体来说，可以利用<code>issue_comment</code>事件来检测PR下的评论，然后根据评论内容决定是否启动特定的workflow。</p><p>以下是一个示例工作流程，展示了如何在PR下的评论触发特定的workflow：</p><ol><li>创建一个GitHub Actions workflow文件（例如：<code>.github/workflows/pr-comment-trigger.yml</code>）。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">PR</span> <span class="hljs-string">Comment</span> <span class="hljs-string">Trigger</span><br><br><span class="hljs-attr">on:</span><br> <span class="hljs-attr">issue_comment:</span><br>   <span class="hljs-attr">types:</span> [<span class="hljs-string">created</span>]<br><br><span class="hljs-attr">jobs:</span><br> <span class="hljs-attr">check-comment:</span><br>   <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>   <span class="hljs-attr">steps:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Check</span> <span class="hljs-string">if</span> <span class="hljs-string">comment</span> <span class="hljs-string">contains</span> <span class="hljs-string">trigger</span> <span class="hljs-string">phrase</span><br>       <span class="hljs-attr">if:</span> <span class="hljs-string">github.event.comment.body</span> <span class="hljs-string">==</span> <span class="hljs-string">&#x27;run workflow&#x27;</span><br>       <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">         echo &quot;Trigger phrase detected, starting workflow...&quot;</span><br><span class="hljs-string">         # 在这里可以添加希望执行的命令或调用另一个工作流程</span><br><span class="hljs-string"></span>     <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Comment</span> <span class="hljs-string">does</span> <span class="hljs-string">not</span> <span class="hljs-string">contain</span> <span class="hljs-string">trigger</span> <span class="hljs-string">phrase</span><br>       <span class="hljs-attr">if:</span> <span class="hljs-string">github.event.comment.body</span> <span class="hljs-type">!=</span> <span class="hljs-string">&#x27;run workflow&#x27;</span><br>       <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;No trigger phrase detected, skipping workflow.&quot;</span><br></code></pre></td></tr></table></figure><p>在这个示例中，workflow会在任何issue或pull request的评论创建时触发。<code>check-comment</code> job会检查评论内容是否包含特定的触发短语（如<code>run workflow</code>）。如果评论包含该短语，则会执行指定的命令或进一步的工作流程。</p><ol><li>将这个workflow文件添加到你的GitHub仓库中，并推送到你的远程仓库。</li><li>在一个PR下添加评论，内容为<code>run workflow</code>，以触发该workflow。</li></ol><p>通过这种方式，你可以根据特定的评论内容来控制workflow的启动。你也可以根据需要修改触发短语和执行的命令，以满足你的特定</p><p>那么在已经close的PR下评论会触发吗</p><p>在GitHub中，即使一个Pull Request（PR）已经关闭，评论事件仍然可以触发GitHub Actions工作流程。<code>issue_comment</code>事件会在任何新的评论被添加到issue或PR时触发，不论该issue或PR是否处于打开（open）状态。</p><p>这意味着可以在一个已经关闭的PR下添加评论，并且如果该评论符合触发条件，相关的workflow仍然会被启动。</p><p>以下是一个示例工作流程，展示了如何在PR下的评论触发特定的workflow，即便PR已经关闭：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">PR</span> <span class="hljs-string">Comment</span> <span class="hljs-string">Trigger</span><br><br><span class="hljs-attr">on:</span><br> <span class="hljs-attr">issue_comment:</span><br>   <span class="hljs-attr">types:</span> [<span class="hljs-string">created</span>]<br><br><span class="hljs-attr">jobs:</span><br> <span class="hljs-attr">check-comment:</span><br>   <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>   <span class="hljs-attr">steps:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Check</span> <span class="hljs-string">if</span> <span class="hljs-string">comment</span> <span class="hljs-string">contains</span> <span class="hljs-string">trigger</span> <span class="hljs-string">phrase</span><br>       <span class="hljs-attr">if:</span> <span class="hljs-string">github.event.comment.body</span> <span class="hljs-string">==</span> <span class="hljs-string">&#x27;run workflow&#x27;</span><br>       <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">         echo &quot;Trigger phrase detected, starting workflow...&quot;</span><br><span class="hljs-string">         # 在这里可以添加希望执行的命令或调用另一个工作流程</span><br><span class="hljs-string"></span>     <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Comment</span> <span class="hljs-string">does</span> <span class="hljs-string">not</span> <span class="hljs-string">contain</span> <span class="hljs-string">trigger</span> <span class="hljs-string">phrase</span><br>       <span class="hljs-attr">if:</span> <span class="hljs-string">github.event.comment.body</span> <span class="hljs-type">!=</span> <span class="hljs-string">&#x27;run workflow&#x27;</span><br>       <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;No trigger phrase detected, skipping workflow.&quot;</span><br></code></pre></td></tr></table></figure><p>这个workflow会在任何新的评论被添加到issue或PR时触发，不论该issue或PR是否处于关闭状态。如果评论内容包含特定的触发短语（如<code>run workflow</code>），则会执行指定的命令或进一步的工作流程。</p><p>总结来说，即使PR已经关闭，在其下的评论仍然可以触发相应的GitHub Actions工作流程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flutter项目中关于系统权限的配置文件</title>
    <link href="/2024/11/07/flutter%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%85%B3%E4%BA%8E%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2024/11/07/flutter%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%85%B3%E4%BA%8E%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>在app里的webview页面需要调用相机，如图点击Take Photo就会调用相机</p><p><img src="/../images/image-20250215174557851.png" alt="image-20250215174557851"></p><blockquote><p>这个web view页面是前端页面，这个“Upload from local”按钮的实现是通过html的input 标签去访问本地的文件的，就是下面的代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;absolute block inset-0 opacity-0 text-[0] w-full disabled:cursor-not-allowed cursor-pointer&#x27;</span>  <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> ((e.target as HTMLInputElement).value = &#x27;&#x27;)&#125;  type=&#x27;file&#x27;  onChange=&#123;handleChange&#125;  accept=&#123;accept&#125;  disabled=&#123;!!(fileConfig.number_limits &amp;&amp; files.length &gt;= fileConfig?.number_limits)&#125;/&gt;<br></code></pre></td></tr></table></figure><p>这个input标签在不同的运行环境（不同环境比如浏览器，app等）有不同的效果，是因为不同的运行环境都自己实现了input标签对应的处理逻辑，比如浏览器里有自己的实现，在app里作为webview运行的时候ios系统有自己的处理逻辑，这个逻辑的最终效果就是图上的效果。</p><p>在PC上的浏览器中，上面html的input 标签去访问本地的文件的代码，运行的效果如下：</p><p><img src="/../images/image-20241218101024302.png" alt="image-20241218101024302"></p><p>和手机上的webview里的运行效果不同，这是因为PC上的浏览器和app对于这个html的input 标签的处理逻辑不同，点击“Upload from local”的效果是浏览器或者app自己的逻辑。</p></blockquote><p>我之前点Take Photo的时候app直接崩溃了。想到肯定是没有配置相关权限，解决方法就是在flutter项目的 ios&#x2F;Runner&#x2F;Info.plist 里增加这两行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;<br>&lt;string&gt;This app requires access to the camera to take photos or scan codes.&lt;/string&gt;<br></code></pre></td></tr></table></figure><p>这样再次点击Take Photo的时候就会有提示框，显示是否允许app使用相机。</p><p>注意： <strong>ios&#x2F;Runner&#x2F;Info.plist 配置的都是和系统权限相关的，什么使用相机权限、faceID权限、使用网络权限等，我的flutter应用的这个文件内容如下：</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">&lt;?xml</span> <span class="hljs-string">version=&quot;1.0&quot;</span> <span class="hljs-string">encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-string">&lt;!DOCTYPE</span> <span class="hljs-string">plist</span> <span class="hljs-string">PUBLIC</span> <span class="hljs-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="hljs-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span><span class="hljs-string">&gt;</span><br><span class="hljs-string">&lt;plist</span> <span class="hljs-string">version=&quot;1.0&quot;&gt;</span><br><span class="hljs-string">&lt;dict&gt;</span><br><span class="hljs-string">&lt;key&gt;CADisableMinimumFrameDurationOnPhone&lt;/key&gt;</span><br><span class="hljs-string">&lt;true/&gt;</span><br><span class="hljs-string">&lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;$(DEVELOPMENT_LANGUAGE)&lt;/string&gt;</span><br><span class="hljs-string">&lt;key&gt;CFBundleDisplayName&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;Ai</span> <span class="hljs-string">Mobile</span> <span class="hljs-string">App&lt;/string&gt;</span><br><span class="hljs-string">&lt;key&gt;CFBundleExecutable&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;$(EXECUTABLE_NAME)&lt;/string&gt;</span><br><span class="hljs-string">&lt;key&gt;CFBundleIdentifier&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;$(PRODUCT_BUNDLE_IDENTIFIER)&lt;/string&gt;</span><br><span class="hljs-string">&lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;6.0&lt;/string&gt;</span><br><span class="hljs-string">&lt;key&gt;CFBundleName&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;ai_mobile_app&lt;/string&gt;</span><br><span class="hljs-string">&lt;key&gt;CFBundlePackageType&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;APPL&lt;/string&gt;</span><br><span class="hljs-string">&lt;key&gt;CFBundleShortVersionString&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;$(FLUTTER_BUILD_NAME)&lt;/string&gt;</span><br><span class="hljs-string">&lt;key&gt;CFBundleSignature&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;????&lt;/string&gt;</span><br><span class="hljs-string">&lt;key&gt;CFBundleURLTypes&lt;/key&gt;</span><br><span class="hljs-string">&lt;array&gt;</span><br><span class="hljs-string">&lt;dict&gt;</span><br><span class="hljs-string">&lt;key&gt;CFBundleURLSchemes&lt;/key&gt;</span><br><span class="hljs-string">&lt;array&gt;</span><br><span class="hljs-string">&lt;string&gt;msauth.com.thermofisher.ai&lt;/string&gt;</span><br><span class="hljs-string">&lt;/array&gt;</span><br><span class="hljs-string">&lt;/dict&gt;</span><br><span class="hljs-string">&lt;/array&gt;</span><br><span class="hljs-string">&lt;key&gt;CFBundleVersion&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;$(FLUTTER_BUILD_NUMBER)&lt;/string&gt;</span><br><span class="hljs-string">&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;</span><br><span class="hljs-string">&lt;array&gt;</span><br><span class="hljs-string">&lt;string&gt;msauth&lt;/string&gt;</span><br><span class="hljs-string">&lt;string&gt;msauthv2&lt;/string&gt;</span><br><span class="hljs-string">&lt;/array&gt;</span><br><span class="hljs-string">&lt;key&gt;LSRequiresIPhoneOS&lt;/key&gt;</span><br><span class="hljs-string">&lt;true/&gt;</span><br><span class="hljs-string">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;</span><br><span class="hljs-string">&lt;dict&gt;</span><br><span class="hljs-string">&lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;</span><br><span class="hljs-string">&lt;true/&gt;</span><br><span class="hljs-string">&lt;/dict&gt;</span><br><span class="hljs-string">&lt;key&gt;UIApplicationSupportsIndirectInputEvents&lt;/key&gt;</span><br><span class="hljs-string">&lt;true/&gt;</span><br><span class="hljs-string">&lt;key&gt;UILaunchStoryboardName&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;LaunchScreen&lt;/string&gt;</span><br><span class="hljs-string">&lt;key&gt;UIMainStoryboardFile&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;Main&lt;/string&gt;</span><br><span class="hljs-string">&lt;key&gt;UISupportedInterfaceOrientations&lt;/key&gt;</span><br><span class="hljs-string">&lt;array&gt;</span><br><span class="hljs-string">&lt;string&gt;UIInterfaceOrientationPortrait&lt;/string&gt;</span><br><span class="hljs-string">&lt;string&gt;UIInterfaceOrientationLandscapeLeft&lt;/string&gt;</span><br><span class="hljs-string">&lt;string&gt;UIInterfaceOrientationLandscapeRight&lt;/string&gt;</span><br><span class="hljs-string">&lt;/array&gt;</span><br><span class="hljs-string">&lt;key&gt;UISupportedInterfaceOrientations~ipad&lt;/key&gt;</span><br><span class="hljs-string">&lt;array&gt;</span><br><span class="hljs-string">&lt;string&gt;UIInterfaceOrientationPortrait&lt;/string&gt;</span><br><span class="hljs-string">&lt;string&gt;UIInterfaceOrientationPortraitUpsideDown&lt;/string&gt;</span><br><span class="hljs-string">&lt;string&gt;UIInterfaceOrientationLandscapeLeft&lt;/string&gt;</span><br><span class="hljs-string">&lt;string&gt;UIInterfaceOrientationLandscapeRight&lt;/string&gt;</span><br><span class="hljs-string">&lt;/array&gt;</span><br><span class="hljs-string">&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;This</span> <span class="hljs-string">app</span> <span class="hljs-string">requires</span> <span class="hljs-string">access</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">microphone</span> <span class="hljs-string">for</span> <span class="hljs-string">voice</span> <span class="hljs-string">input.&lt;/string&gt;</span><br><span class="hljs-string">&lt;key&gt;NSFaceIDUsageDescription&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;Face</span> <span class="hljs-string">ID</span> <span class="hljs-string">is</span> <span class="hljs-string">used</span> <span class="hljs-string">to</span> <span class="hljs-string">authenticate</span> <span class="hljs-string">the</span> <span class="hljs-string">user.&lt;/string&gt;</span><br><span class="hljs-string">&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;</span><br><span class="hljs-string">&lt;string&gt;This</span> <span class="hljs-string">app</span> <span class="hljs-string">requires</span> <span class="hljs-string">access</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">camera</span> <span class="hljs-string">to</span> <span class="hljs-string">take</span> <span class="hljs-string">photos</span> <span class="hljs-string">or</span> <span class="hljs-string">scan</span> <span class="hljs-string">codes.&lt;/string&gt;</span><br><span class="hljs-string">&lt;/dict&gt;</span><br><span class="hljs-string">&lt;/plist&gt;</span><br></code></pre></td></tr></table></figure><p>在 ios&#x2F;Runner&#x2F;Info.plist配置后，当在ios里如果要使用到某个权限时，就会跳出弹窗询问，注意这一步是系统自动实现的。</p>]]></content>
    
    
    <categories>
      
      <category>mobile</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>github action runner group数据共享讨论</title>
    <link href="/2024/10/10/github%20action%20runner%20group%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/"/>
    <url>/2024/10/10/github%20action%20runner%20group%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="runner-group简介"><a href="#runner-group简介" class="headerlink" title="runner group简介"></a>runner group简介</h2><p>首先阅读一下github的文档：</p><p><a href="https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/managing-access-to-self-hosted-runners-using-groups">https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/managing-access-to-self-hosted-runners-using-groups</a></p><p>runner group是给organization用的</p><p>当创建runner group时，需要选择一个策略，该策略定义了哪些repo可以访问该runner group。</p><p>在organization’s runner settings里，可以看到列出来的runner group</p><p>当新runner创建时，不指定的情况下，会被分配到default group的runner里，所有organization都有一个default runner group。</p><p>可以通过API创建runner group，organization也可以在自己的主页的Settings里New runner group。</p><p>runner group新建后，也可以在runner group里修改哪些repo可以访问这个group。</p><p>自动将self-hosted runner 加到group：<code>./config.sh --url $org_or_enterprise_url --token $token --runnergroup rg-runnergroup</code>，也可以将self-hosted runner手动移到group里，还是需要在<strong>organization</strong>的Settings里设置。也可以将runner从group里移出。</p><blockquote><p>注意：</p><p>runner在内网中，只能runner向github发起网络请求然后github返回，github不可能向runner发起网络请求。</p><p>下面这个图解释了在内网中的runner如何和github服务器通讯传递和运行job，还有runner运行job的步骤。</p><p>本地runner运行的job的终端也会显示job的运行情况：</p><p><img src="/../images/image-20241016153012590.png" alt="image-20241016153012590"></p><p>runner group和github调度流程如下：</p><p><img src="/../images/image-20241016153302298.png" alt="image-20241016153302298"></p></blockquote><h2 id="runner-group数据共享问题"><a href="#runner-group数据共享问题" class="headerlink" title="runner group数据共享问题"></a>runner group数据共享问题</h2><p>我连续触发workflow，发现一个问题：有个Action的Job分为两个job，分别为Checkout和Build，查看runner的日志发现Checkout在runner2上运行，但是Build在runner1上运行，但是报错了：</p><p><a href="https://github.com/thermofisher/CN-DE-AMandA-Web/actions/runs/11513036704/job/32049037585">https://github.com/thermofisher/CN-DE-AMandA-Web/actions/runs/11513036704/job/32049037585</a></p><p><img src="/../images/image-20250215175709147.png" alt="image-20250215175709147"></p><p><img src="/../images/image-20241025145825961.png" alt="image-20241025145825961"></p><p>是因为runner2在自己的工作目录初始化了项目，是在Checkout里clone下来了代码，但是Build到了runner1上面运行，runner1的工作目录没有代码，所以执行<code>git branch --show-current</code>里报错了。</p><p>经过搜索后发现，<strong>我配置的runner group的多个runner每个runner都有自己的工作目录，runner之间是不会有共享目录的。</strong>而同一个workflow下的多个job可能会在多个不同的runner下运行，上述问题的产生是因为runner2运行了Checkout Job，把代码clone到runner2的工作目录中了。但是Build job在runner1上运行，runner1的工作目录没有clone下的代码，所以执行git命令报了上面的错。</p><p>每个作业（Job）默认是在一个独立的虚拟环境中运行的，这意味着环境配置（例如安装的工具和设置的环境变量）不会在作业之间共享。因此，如果你在一个作业中设置了Gradle环境，那么在下一个作业中无法直接访问这些设置。</p><p>这个问题的解决方案，第一个是使用actions&#x2F;upload-artifact@v3进行job之间的数据同步，前一个job把数据传到github上，后一个job从github上拉取数据，使用actions&#x2F;upload-artifact@v3会比较耗时，因为有上传数据和下载数据的时间。使用actions&#x2F;upload-artifact@v3的写法参考如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Mannual_QA_Test_Update</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">workflow_dispatch:</span><br>  <br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">Checkout:</span><br>    <span class="hljs-attr">runs-on:</span> <br>      <span class="hljs-attr">group:</span> <span class="hljs-string">group1</span><br>      <span class="hljs-attr">labels:</span> <span class="hljs-string">qa</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">repository</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">create</span> <span class="hljs-string">date</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          # 获取当前的日期和时间</span><br><span class="hljs-string">          $currentDateTime = Get-Date -Format &quot;yyyy-MM-dd HH:mm:ss.fff&quot;</span><br><span class="hljs-string">          Write-Output &quot;Date: $currentDateTime&quot;</span><br><span class="hljs-string">          # 定义输出文件的路径</span><br><span class="hljs-string">          $outputFilePath = &quot;output.txt&quot;</span><br><span class="hljs-string">          # 将当前的日期和时间写入文件</span><br><span class="hljs-string">          $currentDateTime | Out-File -FilePath $outputFilePath</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Upload</span> <span class="hljs-string">build</span> <span class="hljs-string">artifacts</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/upload-artifact@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">build-output</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">.</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ls</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          ls</span><br><span class="hljs-string"></span>  <span class="hljs-attr">Build:</span><br>    <span class="hljs-attr">needs:</span> <span class="hljs-string">Checkout</span><br>    <span class="hljs-attr">runs-on:</span> <br>      <span class="hljs-attr">group:</span> <span class="hljs-string">group1</span><br>      <span class="hljs-attr">labels:</span> <span class="hljs-string">qa</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Download</span> <span class="hljs-string">build</span> <span class="hljs-string">artifacts</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/download-artifact@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">build-output</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">.</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ls</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          ls</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">read</span> <span class="hljs-string">date</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          # 获取当前的日期和时间</span><br><span class="hljs-string">          Get-Content -Path &quot;output.txt&quot;</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Get</span> <span class="hljs-string">build</span> <span class="hljs-string">info</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          # 获取最新提交信息</span><br><span class="hljs-string">          $BRANCH = git branch --show-current</span><br><span class="hljs-string">          Write-Output &quot;Using branch: $BRANCH&quot;</span><br><span class="hljs-string">          $COMMIT_ID = git log -1 --format=&quot;%H&quot;</span><br><span class="hljs-string">          Write-Output &quot;Latest Commit ID: $COMMIT_ID&quot;</span><br><span class="hljs-string">          $COMMIT_MESSAGE = git log -1 --format=&quot;%s&quot;</span><br><span class="hljs-string">          Write-Output &quot;Latest Commit Message: $COMMIT_MESSAGE&quot;</span><br><span class="hljs-string">          $COMMIT_AUTHOR = git log -1 --format=&quot;%an&quot;</span><br><span class="hljs-string">          Write-Output &quot;Latest Commit Author: $COMMIT_AUTHOR&quot;</span><br></code></pre></td></tr></table></figure><p>方案2就是把所有可能会发生上述数据共享问题的步骤都放在一个Job里。</p><h2 id="runner-group如何通过label调度不同功能环境任务"><a href="#runner-group如何通过label调度不同功能环境任务" class="headerlink" title="runner group如何通过label调度不同功能环境任务"></a>runner group如何通过label调度不同功能环境任务</h2><p>runner group通过label获取发布任务的流程，label表示发布的环境</p><p><img src="/../images/image-20241029170202591.png" alt="image-20241029170202591"></p><h2 id="job和runner的对应关系"><a href="#job和runner的对应关系" class="headerlink" title="job和runner的对应关系"></a>job和runner的对应关系</h2><p>在GitHub Actions中，一个工作流（workflow）可以包含多个作业（jobs），这些作业可以并行运行，也可以有依赖关系（通过<code>needs</code>关键字来指定）。如果你有多个自托管的Runner，并且这些Runner都可用于同一个仓库的工作流，那么这些作业可以分配到不同的Runner上运行。</p><p>如果有作业之间的依赖关系，可以使用<code>needs</code>关键字来指定作业的执行顺序。</p><p>所以我这里写的这两个Job，执行到gradle wrapper会报错：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">Setup:</span><br>  <span class="hljs-attr">needs:</span> <span class="hljs-string">Checkout</span><br>  <span class="hljs-attr">runs-on:</span> <span class="hljs-string">self-hosted</span><br>  <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Java</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-java@v4</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">distribution:</span> <span class="hljs-string">&#x27;oracle&#x27;</span> <span class="hljs-comment"># See &#x27;Supported distributions&#x27; for available options</span><br>        <span class="hljs-attr">java-version:</span> <span class="hljs-string">$&#123;&#123;env.JAVA_VERSION&#125;&#125;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Gradle</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">gradle/actions/setup-gradle@v3</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">gradle-version:</span> <span class="hljs-string">&#x27;8.5&#x27;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Version</span> <span class="hljs-string">Info</span><br>      <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        echo &quot;The current java version is $(java -version 2&gt;&amp;1)&quot;</span><br><span class="hljs-string">        echo &quot;The current javac version is $(javac -version 2&gt;&amp;1)&quot;</span><br><span class="hljs-string">        echo &quot;The current gradle version is $(gradle -version)&quot;</span><br><span class="hljs-string"></span><span class="hljs-attr">Build:</span><br>  <span class="hljs-attr">needs:</span> <span class="hljs-string">Setup</span><br>  <span class="hljs-attr">runs-on:</span> <span class="hljs-string">self-hosted</span><br>  <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">gradle</span> <span class="hljs-string">wrapper</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">gradle</span> <span class="hljs-string">wrapper</span> <span class="hljs-comment"># 这里会报错，显示gradle not found。虽然我确认了Setup和Build这两个job是在一个runner上运行的，但是如果有两个runner，它们两个可能被分配到两个runner上去执行。所以一个job的运行环境是独立的，可以理解为一个job运行结束后它的环境就会被清除。所以Setup运行结束后会把它设置的java、gradle都清除掉。所以在Build里执行到gradle wrapper就会报错了。</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">./gradlew</span> <span class="hljs-string">:amanda-data-api:bootJar</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">./gradlew</span> <span class="hljs-string">:amanda-data-api:bootJar</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">./gradlew</span> <span class="hljs-string">:amanda-admin-portal:bootJar</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">./gradlew</span> <span class="hljs-string">:amanda-admin-portal:bootJar</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ls</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        ls amanda-data-api/build/libs</span><br><span class="hljs-string">        ls amanda-admin-portal/build/libs</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>苹果生态中的bundle ID</title>
    <link href="/2024/09/01/%E8%8B%B9%E6%9E%9C%E7%94%9F%E6%80%81%E4%B8%AD%E7%9A%84bundle%20ID/"/>
    <url>/2024/09/01/%E8%8B%B9%E6%9E%9C%E7%94%9F%E6%80%81%E4%B8%AD%E7%9A%84bundle%20ID/</url>
    
    <content type="html"><![CDATA[<p>苹果手机的应用系统为iOS，iOS中有很多个app，那么app在系统内是如何区分的呢？app有在系统内的唯一标识吗？唯一标识的作用比如：当用户下载appA之后再次在app store搜索appA，此时用户会看到该app已安装的提示而不是安装的提示。iOS通过appA是否在系统内注册了唯一标识来判断，appA是否已经安装。</p><p>上述的唯一标识的专门名称为bundle ID，这是苹果生态中的唯一ID。bundle ID可让 iOS 和 macOS 识别应用。bundle ID 必须在 Apple 注册，并且应用是唯一的。bundle ID 是特定于应用类型的（iOS 或 macOS）。</p><p>Xcode是苹果生态内应用的开发工具，Xcode里可以配置bundle ID，如下：</p><p><img src="/../images/image-20250124112424671.png" alt="image-20250124112424671"></p><p>配置完毕后打包，打出来的包就内置了之前配置了的bundle ID。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mobile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cacti简介与使用</title>
    <link href="/2024/08/01/Cacti%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/08/01/Cacti%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>cacti是用php写的，一个开源的网络监控工具，可以用于监控网络流量，并用图表化的方式呈现。</p><p>cacti将数据存储在MySQL里，同时还使用了RRDTool（Round Robin Database）即环状数据库。</p><p>cacti主要通过SNMP服务获取数据，用RRDTool存储数据和更新SNMP获取到的数据，需要时查看时可以查看RRDTool生成的图。MySQL则用于存储cacti用户信息模板等。</p><p>cacti的工作流程和架构如下：</p><p><img src="/../images/image-20240422160421832.png" alt="image-20240422160421832"></p><h2 id="环状数据库"><a href="#环状数据库" class="headerlink" title="环状数据库"></a>环状数据库</h2><p>RRDTool就是环状数据库，形象的理解为数据库存储在一个环中，环是头尾相接的。写数据沿着环以此写，当写到最开始的数据时，直接覆盖，相当于开始了第二圈的写环操作。</p><h2 id="通过docker-compose启动"><a href="#通过docker-compose启动" class="headerlink" title="通过docker-compose启动"></a>通过docker-compose启动</h2><p>docker-compose.yml文件内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.5&#x27;</span><br><span class="hljs-attr">services:</span><br><br><br>  <span class="hljs-attr">cacti:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;smcline06/cacti&quot;</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">cacti</span><br>    <span class="hljs-attr">domainname:</span> <span class="hljs-string">example.com</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">cacti</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;443:443&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_NAME=cacti_master</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_USER=user</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_PASS=admin</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_HOST=db</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_PORT=3306</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_ROOT_PASS=admin</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">INITIALIZE_DB=1</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=America/Los_Angeles</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">cacti-data:/cacti</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">cacti-spine:/spine</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">cacti-backups:/backups</span><br>    <span class="hljs-attr">links:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db</span><br><br><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;mariadb:10.3&quot;</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">cacti_db</span><br>    <span class="hljs-attr">domainname:</span> <span class="hljs-string">example.com</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">db</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysqld</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--character-set-server=utf8mb4</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--collation-server=utf8mb4_unicode_ci</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--max_connections=200</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--max_heap_table_size=128M</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--max_allowed_packet=32M</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--tmp_table_size=128M</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--join_buffer_size=128M</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--innodb_buffer_pool_size=1G</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--innodb_doublewrite=ON</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--innodb_flush_log_at_timeout=3</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--innodb_read_io_threads=32</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--innodb_write_io_threads=16</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--innodb_buffer_pool_instances=9</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--innodb_file_format=Barracuda</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--innodb_large_prefix=1</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--innodb_io_capacity=5000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--innodb_io_capacity_max=10000</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=admin</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=America/Los_Angeles</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">cacti-db:/var/lib/mysql</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">cacti-db:</span><br>  <span class="hljs-attr">cacti-data:</span><br>  <span class="hljs-attr">cacti-spine:</span><br>  <span class="hljs-attr">cacti-backups:</span><br></code></pre></td></tr></table></figure><p>登陆 <a href="http://localhost/cacti/auth_changepassword.php?ref=http://10.251.29.251/cacti/install/install.php%EF%BC%8C%E5%88%9D%E6%AC%A1%E7%99%BB%E9%99%86%E6%97%B6%EF%BC%8C%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E9%83%BD%E6%98%AFadmin">http://localhost/cacti/auth_changepassword.php?ref=http://10.251.29.251/cacti/install/install.php，初次登陆时，用户名和密码都是admin</a></p><p>然后按照引导执行安装操作，安装完毕后页面如下：</p><p><img src="/../images/image-20240422155442933.png" alt="image-20240422155442933"></p><h2 id="可视化机器的进出流量"><a href="#可视化机器的进出流量" class="headerlink" title="可视化机器的进出流量"></a>可视化机器的进出流量</h2><p>如果想要可视化某一台机器的一些指标，首先需要确认被监控的机器是否安装了snmp服务，没有则需要进行安装。确保snmp在该机器上运行。</p><p>要想查看某一台机器的指标情况，首先需要创建新设备：</p><p><img src="/../images/image-20240422175713376.png" alt="image-20240422175713376"></p><p>输入主机名和描述，设备模板选择 Net-SNMP Device</p><p><img src="/../images/image-20240422175815084.png" alt="image-20240422175815084"></p><p>然后点击 为设备创建图形：</p><p><img src="/../images/image-20240422175916660.png" alt="image-20240422175916660"></p><p>因为我想监控进出网络数据包变化，拉到下面可以看到网卡列表。选择想要监控的网卡，图形类型选择 In&#x2F;Out Bits：</p><p><img src="/../images/image-20240422180044991.png" alt="image-20240422180044991"></p><p>点击确认创建完毕后点击上方的 图形 按钮：</p><p><img src="/../images/image-20240422180136427.png" alt="image-20240422180136427"></p><p>可以查看流量变化（图上这个是我之前创建的，创建了好几个）。</p>]]></content>
    
    
    <categories>
      
      <category>Devops</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>golang底层数据结构实现原理</title>
    <link href="/2024/07/25/golang%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2024/07/25/golang%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>这是slice的底层数据结构定义，比较重要的字段包括：指向底层数组的指针、slice的长度即len字段，slice所指向的底层数组的长度即cap字段，表示slice的容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>array unsafe.Pointer<br><span class="hljs-built_in">len</span> <span class="hljs-type">int</span><br><span class="hljs-built_in">cap</span> <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="make"><a href="#make" class="headerlink" title="make"></a>make</h4><p>使用make函数，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>该slice的len为1，cap为1。</p><p>可以在make数组的基础上新增一个参数，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>该slice的len为1，cap为10。</p><p>注意slice取下标只能以len为基础，不能以cap为基础，比如下面的代码就会报越界的错误：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">slice</span> := make([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">slice</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span> // panic: runtime error: <span class="hljs-keyword">index</span> <span class="hljs-keyword">out</span> <span class="hljs-keyword">of</span> range [<span class="hljs-number">0</span>] <span class="hljs-keyword">with</span> length <span class="hljs-number">0</span><br>fmt.Println(<span class="hljs-keyword">slice</span>) // <br></code></pre></td></tr></table></figure><p>虽然len为0，但是可以append：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice)) <span class="hljs-comment">// 1 1</span><br></code></pre></td></tr></table></figure><h4 id="根据数组创建"><a href="#根据数组创建" class="headerlink" title="根据数组创建"></a>根据数组创建</h4><p>从数组拷贝：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">array := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125; <span class="hljs-comment">// array是一个数组</span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 创建一个slice</span><br><span class="hljs-built_in">copy</span>(slice, array[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]) <span class="hljs-comment">// 将数组的部分元素复制到切片</span><br></code></pre></td></tr></table></figure><p>或者从数组创建切片，共用数组的底层空间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">array := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125; <span class="hljs-comment">// array是一个数组</span><br><br>slice1 := array[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] <span class="hljs-comment">// 包含索引1到3的元素</span><br>fmt.Println(slice1)  <span class="hljs-comment">// 输出 [20, 30, 40]</span><br>slice1[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span><br>fmt.Println(slice1) <span class="hljs-comment">// 输出 [99 30 40]</span><br>fmt.Println(array)  <span class="hljs-comment">// 输出 [10 99 30 40 50]</span><br></code></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>向slice追加元素时，如果slice的容量不够，那么会触发slice的扩容操作（会分配一块更大的内存）：</p><p>原Slice容量小于1024， 新Slice容量将扩大为原来的2倍；<br>原Slice容量大于等于1024， 新Slice容量将扩大为原来的1.25倍；</p><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>copy拷贝的数量是两个slice长度的较小值。所以copy不会扩容，sppend才会扩容。比如如下的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// nums := []int&#123;2, 3, 1, 1, 4&#125;</span><br><span class="hljs-comment">// fmt.Println(minSubArrayLen(7, []int&#123;2, 3, 1, 2, 4, 3&#125;)) // 输出: 3</span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>slice[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span><br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>) <span class="hljs-comment">// 此时slice为 [10, 0, 1]</span><br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">2</span>) <span class="hljs-comment">// 此时slice为 [10, 0, 1, 1]</span><br><span class="hljs-built_in">new</span> := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">copy</span>(<span class="hljs-built_in">new</span>, slice)<br>fmt.Println(<span class="hljs-built_in">new</span>, <span class="hljs-built_in">len</span>(<span class="hljs-built_in">new</span>)) <span class="hljs-comment">// [0] 1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>append是向slice的len之后继续追加，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 此时slice是[0, 0]</span><br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>)  <span class="hljs-comment">// 此时slice是[0, 0, 1]</span><br>slice[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span> <span class="hljs-comment">// 此时slice是[10, 0, 1]</span><br></code></pre></td></tr></table></figure><h3 id="函数传递"><a href="#函数传递" class="headerlink" title="函数传递"></a>函数传递</h3><p>当函数的参数是一个切片类型的值时，如果在函数内部修改切片的值，会影响到原始切片的值。因为实际上是传递了切片的引用，而不是切片的副本，并且切片本质上还是一个对底层数组的引用。</p><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>channel的底层数据结构定义为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>qcount <span class="hljs-type">uint</span><br>dataqsiz <span class="hljs-type">uint</span><br>buf unsafe.Pointer <span class="hljs-comment">// 环形队列指针</span><br>elemsize <span class="hljs-type">uint16</span> <span class="hljs-comment">// 环形队列大小</span><br>closed <span class="hljs-type">uint32</span><br>elemtype *_type <span class="hljs-comment">// 指向 dataqsiz 元素数组</span><br>sendx <span class="hljs-type">uint</span> <span class="hljs-comment">// 标记了环形队列读指针的位置</span><br>recvx <span class="hljs-type">uint</span> <span class="hljs-comment">// 标记了环形队写读指针的位置</span><br>recvq waitq  <span class="hljs-comment">// 等待读取channel的可能是多个的goroutine组成的队列</span><br>sendq waitq <span class="hljs-comment">// 等待写channel的可能是多个的goroutine组成的队列</span><br> <br>lock mutex<br>&#125;<br></code></pre></td></tr></table></figure><p>主要就是一个环形队列指针，队列读写位置，队列读写goroutine的读取队列和接收队列。</p><p>一般实现环形队列会用数组或者链表，链表也可能不会将头尾直接链接起来，不然就真的变成一个圈了，而是会在链表的尾部节点做特殊处理。不管用数组还是链表实现，都会维护两个指针，即指向有效数据的头尾指针<strong>。golang的channel底层的环形链表用的是数组实现的。</strong></p><h3 id="写channel"><a href="#写channel" class="headerlink" title="写channel"></a>写channel</h3><p>写操作比较关键的就是接收队列了，还有缓冲区。</p><p>接收队列为空，缓冲区有位置，将数据写入缓冲区。</p><p>接收队列为空，缓冲区没有位置，将当前写数据的goroutine加入recvq，表示这个goroutine被阻塞了，要等待被唤醒。</p><p>接收队列不空，则表示接收队列的goroutine被阻塞了，为什么被阻塞，因为没有接收到数据，表明当前缓冲区为空或者根本没有缓冲区，则此时将接收队列的一个goroutine唤醒，把要写入的数据传递给这个goroutine。</p><h3 id="读channel"><a href="#读channel" class="headerlink" title="读channel"></a>读channel</h3><p>读操作比较关键的就是写队列了，还有缓冲区。</p><p>写队列为空，直接从缓冲区读取数据。</p><p>写队列不为空，缓冲区为空，表示没有压根没有缓冲区，此时唤醒写队列的某个goroutine接收其要写的数据。</p><p>写队列不为空，缓冲区不为空，表示缓冲区满了，从缓冲区读取最早写入的数据，然后唤醒写队列的某个goroutine，让这个goroutine把数据写到缓冲区，当然写的这个数据必然是最新的，在队列的最后面（缓冲区的队列不会环形队列）。</p><h3 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h3><p>对于recvq的所有goroutine，这些goroutine都是被阻塞的，让这些goroutine直接返回，也不会让它们把数据写到缓冲区。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>总结起来，golang的map数据类型底层使用的是哈希表来实现的，当哈希冲突时，使用链地址法来解决冲突。</p><blockquote><p>哈希操作简介：对于一个key，使用哈希函数f计算f(key)，得到一个值。<strong>如果多个key被哈希到同一个bucket里，那么就产生哈希冲突了。</strong>可以用链地址法解决。</p><p>解决哈希冲突除了链地址法，还有再次哈希法，创建一个公共缓冲区等方法。</p><p>golang官方使用了什么哈希函数，具体的函数逻辑没有公开。且golang对于不同类型的key使用了不同的哈希函数。</p></blockquote><p>底层结构为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>count <span class="hljs-type">int</span> <span class="hljs-comment">// 当前保存的元素个数</span><br>B <span class="hljs-type">uint8</span> <span class="hljs-comment">// 指示bucket数组的大小</span><br>buckets unsafe.Pointer <span class="hljs-comment">// bucket数组指针， 数组大小为2^B</span><br>  hash0     <span class="hljs-type">uint32</span> <span class="hljs-comment">// 哈希种子，让哈希函数计算的结果有了随机性</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>bucket底层数据结构为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>tophash [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span> <span class="hljs-comment">//存储哈希值的高8位</span><br>data <span class="hljs-type">byte</span>[<span class="hljs-number">1</span>] <span class="hljs-comment">// 占位符，类似一个指针，其具体的存储数据可能是变化的。这里存储了 /key value数据:key/key/key/.../value/value/value...，最多可存8个key-value对</span><br>overflow *bmap <span class="hljs-comment">//溢出bucket的地址，就是当该bucket存储的key-value对超出8个以外的key-value对会放在这里存储</span><br>  <span class="hljs-comment">// 这是一个新的bmap类型，父bmap指向了子bmap，实现了链表的功能</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><ul><li>对于一个key，通过哈希函数计算出哈希值</li><li>将哈希值的低8位和hmap.B取模，得到一个整数，得到buckets unsafe.Pointer所指向数组的下标</li><li>直接buckets unsafe.Pointer所指向数组的下标</li><li>将哈希值的低8位和bmap的tophash比较，如果相等，则去data byte[1]所指向的key-value键值对查找输入key对应的value</li><li>如果上述比较操作不相等，则去bmap.overflow的bmap数据结构继续将该哈希值的高8位和其进行比较，如果最后bmap.overflow为空，则表示没有找到</li></ul><h3 id="写入操作"><a href="#写入操作" class="headerlink" title="写入操作"></a>写入操作</h3><ul><li>对于一个key，通过哈希函数计算出哈希值</li><li>将哈希值的低8位和hmap.B取模，得到一个整数，得到buckets unsafe.Pointer所指向数组的下标</li><li>直接buckets unsafe.Pointer所指向数组的下标</li><li>如果数组该下标的元素为空，则新建。如果不为空，则找到key对应的value将value更新</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p>map底层的结构可参考如下图：</p><p><img src="/../images/image-20240729171926604.png" alt="image-20240729171926604"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GMP模型</title>
    <link href="/2024/06/26/GMP%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/06/26/GMP%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>goroutine是go语言的特色，是golang支持高并发的重要保障。go程序中可用创建成千上万个goroutine。goroutine的意思就是golang+coroutine（协程）。</p><p>goroutine也叫协程，一个goroutine的初始stack是2K（2*1024个字节），但是可以动态的伸缩其栈的大小。goroutine是用户态协程，goroutine比lua的协程要重一点。</p><p>goroutine是golang实现的协程，是用户级线程。所以下面对应的介绍线程模型。</p><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>线程模型的分类：</p><p>内核级线程（Kernel Level Thread）模型，内核级线程是可被操作系统内核调度器调度的对象实体。</p><p>用户级线程（User Level Thread）模型，用户级线程即<strong>协程</strong>，由应用程序创建，必须和内核级线程绑定后才能执行。</p><p>两级线程模型，也称为混合型线程模型</p><h2 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>golang实现了<strong>GMP模型</strong>，是golang对并发模型的抽象，也是goroutine的分配、负载、调度的模型。</p><p>G表示协程Goroutine，表示一个执行任务。</p><p>M表示线程Machine，是操作系统级的线程，是独立调度的基本单位，线程会归属于某个进程，线程是系统资源拥有的基本单位。</p><p>P表示逻辑处理器Processor，顾名思义为处理器，但是是虚拟处理器，用于限制当前正在运行的goroutine的数量。在不用<code>runtime.GOMAXPROCS</code>指定时，<strong>P的数量和虚拟CPU核心数一样多</strong>。P需要绑定一个M才可以运行，因为M才能真正的在<strong>物理</strong>CPU上运行。也就是说一般和虚拟CPU核心数一样多的P，每个P都需要绑定一个可以在物理CPU上运行的操作系统线程M，M的数量一般比P多。</p><p>golang在底层实现了两级线程模型，即混合型线程模型。一个M关联了一个内核调度实体<strong>KSE</strong>（Kernel Scheduling Entity），KSE是可被操作系统内核调度器调度的实体对象，是操作系统的最小调度单位，可以理解为内核级别线程。</p><p>下图是GMP模型的概览。</p><p><img src="/../images/image-20240626172239469.png" alt="image-20240626172239469"></p><p>GMP调度流程大致如下（也就是图上我画的黄色箭头和黄色文字描述部分）</p><ul><li>线程M想运行任务就需得获取 P，即与P关联。</li><li>M从 P 的本地队列(LRQ)获取 G</li><li>若LRQ中没有可运行的G，M 会尝试从全局队列(GRQ)拿一批G放到P的本地队列，</li><li>若全局队列也未找到可运行的G时候，M会随机从其他 P 的本地队列偷一半放到自己 P 的本地队列。</li><li>拿到可运行的G之后，M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。<strong>M想拿到G是一定要通过P的。</strong></li></ul><p>由上图可以看出，P的数量意味着程序执行的任意时刻，最多有P的数量个goroutine正在同时运行。</p><h3 id="调度过程中阻塞"><a href="#调度过程中阻塞" class="headerlink" title="调度过程中阻塞"></a>调度过程中阻塞</h3><h4 id="用户态阻塞"><a href="#用户态阻塞" class="headerlink" title="用户态阻塞"></a>用户态阻塞</h4><p>包括I&#x2F;O阻塞（比如请求某个外部服务时，外部服务迟迟没有返回），channel等待引起的阻塞等等。当阻塞时，G的状态从<code>_Gruning</code>变成<code>_Gwaitting</code>，M会跳过该G尝试获取并执行下一个G，但是如果没有runnable状态的G供M调用，那么M将解绑P然后进入休眠状态。</p><p>如果G又被唤醒了，比如之前IO阻塞的情况下外部服务返回了结果，或者之前channel阻塞的情况下channel接收到了数据可以继续执行了（假设该常见下是G2发送了数据使得G被唤醒），那么G将被标记为runnable，然后放入G2所在P的runnext也就是下一个被G2的P执行，G2的P执行完G后再继续执行自己的本地队列里的P。</p><h4 id="系统调用阻塞"><a href="#系统调用阻塞" class="headerlink" title="系统调用阻塞"></a>系统调用阻塞</h4><p>当G被阻塞在某个系统调用时，此时G会阻塞在_Gsyscall状态，M也处于 block on syscall 状态，此时的M可被抢占调度：G对应的M对应的P会和M解绑，P会寻找idle空闲的M和其绑定，如果没有空闲的M但是P的本地队列中还有G需要执行，那么会创建新的M，P和这个新的M绑定到一起。</p><p>当G不再被阻塞时，G会尝试进入一个idle的P（也就是还没有和M绑定的P）的本地队列中，如果没有idle的P，那么G会被标记为runnext状态进入全局队列。</p><h2 id="显示控制goroutine"><a href="#显示控制goroutine" class="headerlink" title="显示控制goroutine"></a>显示控制goroutine</h2><h3 id="runtime-Gosched"><a href="#runtime-Gosched" class="headerlink" title="runtime.Gosched()"></a>runtime.Gosched()</h3><p>在goroutine中调用该方法时，表示当前goroutine需要显示的让出本次运行机会，停止本次运行。在GMP模型中，如果某个G正在被M运行，运行到了G的runtime.Gosched()代码时，那么M会停止运行G，G处于暂停运行的状态，G会被放到M对应的P的本地队列中等待下次调用。</p><p>调用runtime.Gosched()可以避免某个G一直在运行占用资源使得其他的G不能得到调用。</p><p>一般使用该函数的场景都是避免某个协程一直霸占资源，或者主动让出当前协程让其他协程执行因为想观察其他协程的运行情况。</p><p>下面是一个示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  runtime.GOMAXPROCS(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>            fmt.Println(<span class="hljs-string">&quot;goroutine 1&quot;</span>)<br>            runtime.Gosched()<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>            fmt.Println(<span class="hljs-string">&quot;goroutine 2&quot;</span>)<br>            runtime.Gosched()<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 让主 goroutine 稍作等待，以便其他 goroutine 执行</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>        fmt.Println(<span class="hljs-string">&quot;main goroutine&quot;</span>)<br>        runtime.Gosched()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">main goroutine<br>goroutine 1<br>main goroutine<br>goroutine 1<br>main goroutine<br>goroutine 1<br>goroutine 1<br>goroutine 1<br>main goroutine<br>main goroutine<br></code></pre></td></tr></table></figure><p>如果把main goroutine的runtime.Gosched()去掉，那么打印出来的5个<code>main goroutine</code>的值必然连续，因为这个main goroutine一直在被运行，打印完了5个<code>main goroutine</code>后程序就退出了其他两个goroutine不会在5个<code>main goroutine</code>后输出任何结果。</p><p>但是加上runtime.Gosched()，那么每次打印1个<code>main goroutine</code>后，main goroutine都会主动让出资源被暂停执行，这样得以让其他两个goroutine有执行的机会。就不会有上述的一旦main goroutine得到执行机会就一直占用执行机会不给其他两个goroutine执行机会的情况了。</p><p>看起来似乎这个runtime.Gosched()效果很大但是不知道实际写代码时什么时候会用，一般如果某个goroutine可能会占用太多CPU或者可能要执行非常长时间以至于让其他goroutine一直等待，那么可以在写代码的时候就写runtime.Gosched()。</p><h2 id="goroutine调度调优"><a href="#goroutine调度调优" class="headerlink" title="goroutine调度调优"></a>goroutine调度调优</h2><p>有如下方案，遵循如下规则：</p><ul><li>控制并发数量，可以使用通道（channel）或信号量（semaphore）等机制来限制并发执行的goroutine数量。</li><li>避免goroutine里的过长时间的阻塞操作</li><li>使用slice的预分配来减少内存分配，对于频繁使用的对象，将对象放到pool里来实现复用内存</li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LRU算法的实现</title>
    <link href="/2024/06/12/LRU%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/06/12/LRU%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>LRU算法全程最少使用（Least Recently Used）算法。是一种缓存中使用的<strong>缓存淘汰算法</strong>，当缓存中的空间满了的时候，需要从已有的数据淘汰一部分以维持缓存的可用性，这个淘汰数据的算法可以通过LRU算法实现的。</p><blockquote><p>当然除了LRU，还有其他的缓存淘汰算法，只是LRU使用得最多，比如：</p><p>LFU（Least Frequently Used）：移除使用得最少的键</p><p>FIFO（First In First Out）：移除最早存储的键</p><p>Random：随机淘汰</p></blockquote><p>其基本思想就是：如果一个数据最近被访问了，那么接下来的一段时间它很可能会再次被访问。所以LRU算法会选出最少使用的数据进行淘汰。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="初识方案"><a href="#初识方案" class="headerlink" title="初识方案"></a>初识方案</h3><p>主要根据LRU的基本思想“如果一个数据最近被访问了，那么接下来的一段时间它很可能会再次被访问”来设计。</p><p>主要方案如下图：</p><p><img src="/../images/image-20240722221239813.png" alt="image-20240722221239813"></p><p>有一个map，map里存储了key到时间戳信息的映射关系，用map存储是为了方便利用key快速更新时间戳和判断key是否存在。此外还有一个链表，从表头到表尾存储了从新到旧的访问时间戳，较新的时间戳的节点指向次新的时间戳的节点。</p><p>当访问新key的时候，将key的时间戳更新为当前时间，且把右侧的时间戳节点置于链表的表头。一旦检测到链表的大小超过指定容量，则从链表的表头开始计算有多少个节点，把队尾的多出来的节点都删除掉，同时也把map里的key也删除掉。</p><p>完整代码如下，里面还有个测试的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>l := InitLRU(<span class="hljs-number">3</span>)<br>l.VisitKey(<span class="hljs-string">&quot;aaa&quot;</span>)<br>l.VisitKey(<span class="hljs-string">&quot;bbb&quot;</span>)<br>l.VisitKey(<span class="hljs-string">&quot;ccc&quot;</span>)<br>l.VisitKey(<span class="hljs-string">&quot;bbb&quot;</span>)<br>l.VisitKey(<span class="hljs-string">&quot;ddd&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> LRU <span class="hljs-keyword">struct</span> &#123;<br>capacity     <span class="hljs-type">int</span><br>cache        <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Node<br>firstVisited *Node<br>&#125;<br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>key  <span class="hljs-type">string</span><br>time <span class="hljs-type">int64</span><br>next *Node　<span class="hljs-comment">// 这里必须使用 *Node 类型，否则链表会有无限递归的问题</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitLRU</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> *LRU &#123;<br><span class="hljs-keyword">return</span> &amp;LRU&#123;<br>capacity: capacity,<br>cache:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Node, <span class="hljs-number">0</span>),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LRU)</span></span> VisitKey(key <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>node := l.firstVisited<br>fmt.Printf(<span class="hljs-string">&quot;cap:%d   &quot;</span>, <span class="hljs-built_in">len</span>(l.cache))<br><span class="hljs-keyword">for</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s -&gt;. &quot;</span>, node.key)<br><span class="hljs-keyword">if</span> node.next == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println()<br><span class="hljs-keyword">break</span><br>&#125;<br>node = node.next<br>&#125;<br>&#125;()<br><span class="hljs-keyword">if</span> l.firstVisited == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 表明目前没有任何缓存数据</span><br>node := &amp;Node&#123;<br>key:  key,<br>time: time.Now().Unix(),<br>&#125;<br>l.cache[key] = node<br>l.firstVisited = node<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> l.cache[key] == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 表明缓存数据里没有该key，需将该key设置为最新访问</span><br><span class="hljs-comment">// 仍需要判断缓存是否已满</span><br>node := &amp;Node&#123;<br>key:  key,<br>time: time.Now().Unix(),<br>next: l.firstVisited,<br>&#125;<br>l.cache[key] = node<br>node.next = l.firstVisited<br>l.firstVisited = node<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 将key对应的节点设置为最新</span><br>l.cache[key].time = time.Now().Unix()<br><span class="hljs-comment">// 将 l.cache[key] 的上个节点和下个节点相连</span><br>node := l.firstVisited<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 寻找 l.cache[key] 的上个节点</span><br><span class="hljs-keyword">if</span> node.next == l.cache[key] &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>node = node.next<br>&#125;<br>node.next = l.cache[key].next<br>l.cache[key].next = l.firstVisited<br>l.firstVisited = l.cache[key]<br>&#125;<br><span class="hljs-comment">// 判断是否超出了容量大小，超出了则淘汰多余的部分</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l.cache) &lt;= l.capacity &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>node := l.firstVisited<br>nodeCount := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> ; nodeCount &lt;= l.capacity; nodeCount++ &#123;<br><span class="hljs-keyword">if</span> node.next == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>nodeCount++<br>node = node.next<br>&#125;<br>firstNode := node<br><span class="hljs-keyword">if</span> nodeCount &gt; l.capacity &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 对应的 cache 也要删除</span><br><span class="hljs-keyword">if</span> node.next == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>node = node.next<br><span class="hljs-built_in">delete</span>(l.cache, node.key)<br>&#125;<br>firstNode.next = <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>初始方案写完后，很容易看出有如下几个问题：</p><ul><li>Node struct里的time其实不是必须的，就算去掉也不影响，如果调用端不想知道key的最新访问时间则可以删除time字段</li><li>寻找 l.cache[key] 的上个节点 里用了 for 遍历，从链表的表头开始遍历，只为了寻找 l.cache[key] 的上个节点。其实可以把单像链表优化为双向链表，这样就可以直接找到上个节点不用遍历了。</li><li>如果可以在LRU struct里直接存储第capacity个节点的信息，也就是存储链表最后一个节点的信息，那么删除时直接从这个Node开始操作，基于双向链表的话就会非常快。</li></ul><p>下面是优化后的代码，多存储了链表的最后一个节点，也从单向链表变成了双向链表。这样会增加存储空间但是也大大提高了操作的速度，算是和map数据结构一样，以空间换时间的优化。</p><p>现在的方案如下：</p><p><img src="/../images/image-20240722221217437.png" alt="image-20240722221217437"></p><p>优化后的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>l := InitLRU(<span class="hljs-number">3</span>)<br>l.VisitKey(<span class="hljs-string">&quot;aaa&quot;</span>)<br>l.VisitKey(<span class="hljs-string">&quot;bbb&quot;</span>)<br>l.VisitKey(<span class="hljs-string">&quot;ccc&quot;</span>)<br>l.VisitKey(<span class="hljs-string">&quot;bbb&quot;</span>)<br>l.VisitKey(<span class="hljs-string">&quot;ddd&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> LRU <span class="hljs-keyword">struct</span> &#123;<br>capacity  <span class="hljs-type">int</span><br>cache     <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Node<br>firstNode *Node<br>lastNode  *Node<br>&#125;<br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>key  <span class="hljs-type">string</span><br>pre  *Node<br>next *Node <span class="hljs-comment">// 这里必须使用 *Node 类型，否则链表会有无限递归的问题</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitLRU</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> *LRU &#123;<br><span class="hljs-keyword">return</span> &amp;LRU&#123;<br>capacity: capacity,<br>cache:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Node, <span class="hljs-number">0</span>),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LRU)</span></span> VisitKey(key <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>node := l.firstNode<br>fmt.Printf(<span class="hljs-string">&quot;cap:%d   &quot;</span>, <span class="hljs-built_in">len</span>(l.cache))<br><span class="hljs-keyword">for</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s &lt;-&gt;. &quot;</span>, node.key)<br><span class="hljs-keyword">if</span> node.next == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println()<br><span class="hljs-keyword">break</span><br>&#125;<br>node = node.next<br>&#125;<br>&#125;()<br><span class="hljs-keyword">if</span> l.firstNode == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 表明目前没有任何缓存数据</span><br>node := &amp;Node&#123;<br>key: key,<br>&#125;<br>l.cache[key] = node<br>l.firstNode = node<br>l.lastNode = node<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> l.cache[key] == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 表明缓存数据里没有该key，需将该key设置为最新访问</span><br><span class="hljs-comment">// 仍需要判断缓存是否已满</span><br>node := &amp;Node&#123;<br>key: key,<br>&#125;<br>l.cache[key] = node<br>node.next = l.firstNode<br>l.firstNode.pre = node<br>l.firstNode = node<br><span class="hljs-comment">// 只有新增key的时候可能超过最大容量</span><br><span class="hljs-comment">// 判断是否超出了容量大小，超出了则淘汰多余的部分</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l.cache) &lt;= l.capacity &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>node = l.lastNode<br><span class="hljs-built_in">delete</span>(l.cache, node.key)<br>node.pre.next = <span class="hljs-literal">nil</span><br>l.lastNode = node.pre<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> l.firstNode.key == key &#123;<br><span class="hljs-comment">// 访问的节点就是当前的最新节点</span><br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 将key对应的节点设置为最新</span><br><span class="hljs-comment">// 将 l.cache[key] 的上个节点和下个节点相连</span><br>node := l.cache[key]<br><span class="hljs-keyword">if</span> node.next == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// node 是链表的最后一个节点</span><br>l.lastNode = node.pre<br>node.pre.next = <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>node.pre.next = node.next<br>node.next.pre = node.pre<br>&#125;<br>node.next = l.firstNode<br>l.firstNode.pre = node<br>l.firstNode = node<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《架构整洁之道》阅读笔记</title>
    <link href="/2024/05/16/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E9%98%85%E8%AF%BB/"/>
    <url>/2024/05/16/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>程序可以分为：普通程序员，工程师和架构师。</p><p>大家对面向对象编程的一般理解是：由封装、继承和多态三种特性支持的。</p><p>大家对函数式编程的一般理解是：以函数为基本单元、没有变量（更准确的说是不能重复赋值）也没有副作用的编程方式。但是从更深层的层次来看，它彻底隔离了可变性，变量或者状态默认就是不可变的。如果要变化，则必须经过合理设计的专门机制来实现，所以也避免了死锁、状态冲突等众多麻烦。</p><p>软件架构（architecture）关注的一个重点是组织结构（structure），不管是组件（component）类（class）函数（function）模块（module）还是层级（layer）服务（service）以及微观与宏观的软件开发过程，软件的组织结构都是我们的主要关注点。</p><p>有一点很重要：今天的软件和过去的软件本质上依然是一样的，都是由if语句，赋值语句以及while循环组成的。</p><h2 id="第一部分-概述"><a href="#第一部分-概述" class="headerlink" title="第一部分 概述"></a>第一部分 概述</h2><h3 id="第一章-设计与架构究竟是什么"><a href="#第一章-设计与架构究竟是什么" class="headerlink" title="第一章 设计与架构究竟是什么"></a>第一章 设计与架构究竟是什么</h3><h4 id="目标是什么"><a href="#目标是什么" class="headerlink" title="目标是什么"></a>目标是什么</h4><p>“架构“这个词往往使用于”高层次“的讨论中，这类讨论一般都把”底层“的实现细节排出在外。而”设计“一词，往往用来指代具体的系统底层组织结构和实现的细节。但是从一个真正的系统架构师的日常工作来看，这样的区别是不成立的。</p><p>软件架构的终极目标是，用最小的人力成本来满足构建和维护系统的需求。</p><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h4><p>不管怎么看，研发团队最好的选择就是清晰的认识并避开工程师们过度自信的特点，开始认真地对待自己的代码架构，对其质量负责。</p><p>要想提高自己软件架构的质量，就需要知道什么是优秀的软件架构。而为了在系统构建过程中采用好的设计和架构以便减少构建成本，提高生产力，又需要先了解系统架构的各种属性与成本和生产力的关系。</p><p>这就是本书的主题。本书为读者描述了什么是优秀的、整洁的软件架构与设计，读者可以参考这些设计来构建一个长期稳定的、持久的系统。</p><h3 id="第2章-两个价值维度"><a href="#第2章-两个价值维度" class="headerlink" title="第2章 两个价值维度"></a>第2章 两个价值维度</h3><h4 id="行为价值"><a href="#行为价值" class="headerlink" title="行为价值"></a>行为价值</h4><p>软件系统的行为是其最直观的价值维度。</p><h4 id="架构价值"><a href="#架构价值" class="headerlink" title="架构价值"></a>架构价值</h4><p>软件应该容易修改。</p><h4 id="哪个价值维度更重要"><a href="#哪个价值维度更重要" class="headerlink" title="哪个价值维度更重要"></a>哪个价值维度更重要</h4><p>如果程序可以正常工作，但是无法修改，那么需求变更时它就无法正常工作了，也就无法修改它让它正常工作。因此，程序的价值会是0。</p><p>如果某程序目前无法正常工作，但是可以轻易修改，那么随着需求更改将会很容易。因此这个程序会持续产生价值。</p><h4 id="艾森豪威尔矩阵"><a href="#艾森豪威尔矩阵" class="headerlink" title="艾森豪威尔矩阵"></a>艾森豪威尔矩阵</h4><p>总结起来就是：我有两种难题：紧急的和重要的，而紧急的难题永远是不重要的，而重要额难题永远是不紧急的。</p><p><img src="/../images/image-20240206165827538.png" alt="image-20240206165827538"></p><h4 id="为好的软件架构而持续斗争"><a href="#为好的软件架构而持续斗争" class="headerlink" title="为好的软件架构而持续斗争"></a>为好的软件架构而持续斗争</h4><p>如果忽略软件架构的价值，系统将会变得越来越难以维护，那么终有一天，系统将会变得再也无法修改。</p><h2 id="第2部分-从基础构建开始：编程范式"><a href="#第2部分-从基础构建开始：编程范式" class="headerlink" title="第2部分 从基础构建开始：编程范式"></a>第2部分 从基础构建开始：编程范式</h2><p>阿兰‘图灵石第一个提出“程序即数据”的人。</p><p>计算机编程领域还经历了另外一个更巨大、更重要的变革，那就是编程范式（paradigm）的变迁，<strong>编程范式指的是程序的编写模式，</strong>与具体的编程语言的关系相对较小。这些范式会告诉你应该在什么时候才用什么样的代码结构，直到今天，我们一共只有三个编程范式。</p><h3 id="第3章-编程范式总览"><a href="#第3章-编程范式总览" class="headerlink" title="第3章 编程范式总览"></a>第3章 编程范式总览</h3><p>本章讲讲述三个编程范式，它们分别是结构化编程（structured programming）、面向对象编程（object-oriented programming）以及函数式编程（functional programming）。</p><h4 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h4><p>1968年提出。Dijkstra论证了使用goto这样的无限制跳转语句将会损害程序的整体结构。Dijkstra也最先主张用我们现在所熟知的if&#x2F;then&#x2F;else语句和do&#x2F;while&#x2F;until语句来代替跳转语句的。</p><p>可以将结构化编程范式规结为一句话：<strong>编程化范式对程序控制权的直接转移进行了限制和规范。</strong></p><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p>最开始的一个例子是：程序员注意到ALGOL语言中，函数调用堆栈（call stack frame）可以被挪到堆内存区域里，这样函数定义的本地变量就可以在函数返回之后继续存在。这样函数就成为一个类（class）的构造函数，而它所定义的本地变量就是类的成员函数，构造函数定义的嵌套函数就成为了成员方法（method），这样依赖，我们就可以利用多态（polymorphism）来限制用户对函数指针的使用。</p><p><strong>面向对象编程对程序控制权的间接转移进行了限制和规范。</strong></p><h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><p>从理论上来说，函数式编程语言中应该是没有赋值语句的，大部分函数式编程语言只允许在非常严格的限制条件下，才可以更改某个变量的值。</p><p>函数式编程对程序中的赋值进行了限制和规范。</p><h4 id="仅供思考"><a href="#仅供思考" class="headerlink" title="仅供思考"></a>仅供思考</h4><h4 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h4><p>多态是我们跨越架构边界的手段，函数式编程是我们规范和限制数据存放位置和访问权限的手段，结构化编程则是各模块的算法实现基础。</p><h3 id="第4章-结构化编程"><a href="#第4章-结构化编程" class="headerlink" title="第4章 结构化编程"></a>第4章 结构化编程</h3><h4 id="可推导性"><a href="#可推导性" class="headerlink" title="可推导性"></a>可推导性</h4><p>Dijkstra提出采用数学推导方法用于解决编程中的错误。他的想法是借鉴数学中的公理（Postulate）、定理（Theorem）、推论（Corollary）和饮理（Lemma），形成一种欧几里得结构。而且他在研究中发现了一个问题：goto语句的某些用法会导致某个模块无法被递归拆分成更小的、可证明的单元，这会导致无法采用分解法来将大型问题进一步拆分成更小的、可证明的单元。但是goto的其他用法虽然不会导致这种问题，但是Dijkstra意识到它们的实际效果其实和更简单的分支结构if- then- else以及循环结构do- while是一致的，那么代码只采用这两种控制结构，则一定可以将程序分解为更小的、可证明的单元。</p><h4 id="goto是有害的"><a href="#goto是有害的" class="headerlink" title="goto是有害的"></a>goto是有害的</h4><h4 id="功能性讲解拆分"><a href="#功能性讲解拆分" class="headerlink" title="功能性讲解拆分"></a>功能性讲解拆分</h4><h4 id="形式化证明没有发生"><a href="#形式化证明没有发生" class="headerlink" title="形式化证明没有发生"></a>形式化证明没有发生</h4><h4 id="科学来救场"><a href="#科学来救场" class="headerlink" title="科学来救场"></a>科学来救场</h4><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>Dijkstra说过“测试只能展示Bug的存在，并不能证明不存在Bug”</p><p>结构化编程范式促使我们先将一段程序递归降解为一系列可证明的小函数，然后再编写相关的测试来试图证明这些函数是错误的，如果这些测试无法证伪这些函数，那么我们可以认为这些函数是足够准确的，进而推导出整个程序是准确的。</p><h4 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h4><p>结构化编程中最有价值的地方就是，它赋予了我们创造可证伪程序单元的能力，</p><p>无论在哪一个层面上，由最小的函数到最大的组件，软件开发的过程都和科学研究非常类似，它们都是由证伪驱动的，软件结构师需要定义可以方便地进行证伪（测试）的模块、组件以及服务，为了达到这个目的，他们需要将类似结构化编程方法应用在更高的层面上。</p><h3 id="第5章-面向对象编程"><a href="#第5章-面向对象编程" class="headerlink" title="第5章 面向对象编程"></a>第5章 面向对象编程</h3><p>面向对象语言包含了封装（encapsulation）、继承（inheriance）、多态（polymorphism）。</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>通过采用封装特性，我们可以把一组相关联的数据和函数圈起来，是的圈外的代码只能看见部分函数，数据则完全不可见。譬如在实际运用中，类（class）中的公共函数和私有变量就是这样。</p><p>下面查看一个简单的C程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">point.h<br>------------------------------------------------------------------------------<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span>;</span><br><span class="hljs-keyword">struct</span> Point* <span class="hljs-title function_">makePoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Point *p)</span>, <span class="hljs-keyword">struct</span> Point *p2);<br><br>point.c<br>------------------------------------------------------------------------------<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;point.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> &#123;</span><br>  <span class="hljs-type">double</span> x,y;<br>&#125;<br><br><span class="hljs-keyword">struct</span> Point* <span class="hljs-title function_">makepoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x,<span class="hljs-type">double</span> y)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span>* <span class="hljs-title">p</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Point));<br>  p-&gt;x = x;<br>  p-&gt;y = y;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Point* p1, <span class="hljs-keyword">struct</span> Point* p2)</span>&#123;<br>  <span class="hljs-type">double</span> dx = p1-&gt;x - p2-&gt;x;<br>  <span class="hljs-type">double</span> dy = p1-&gt;y - p2-&gt;y;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(dx*dx+dy*dy);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的程序可以看出，这是完美封装，虽然<strong>C语言是非面向对象的编程语言</strong>。伤处C程序是很常见的，在头文件中进行数据结构以及函数定义的前置声明（forward declare），然后在。程序文件中具体实现。程序文件中的具体实现细节对于使用者来说是不可见的。</p><p><strong>C++作为一种面向对象语言，反而破坏了C的完美封装性。</strong></p><p>由于一些技术原因，C++编译器要求类的成员变量必须在该类的头文件中声明。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承的主要作用就是让我们可以在某个作用域内对外部定义的某一组变量和函数进行覆盖。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamePoint</span> &#123;</span><br><span class="hljs-type">double</span> x,y;<br><span class="hljs-type">char</span>* name;<br>&#125;<br></code></pre></td></tr></table></figure><p>NamePoint数据结构可以被当作Point数据结构的一个衍生体使用。之所以可以这样做，是因为NamePoint结构体的前两个成员的顺序与Point结构体的完全一致。也就是NamePoint之所以可以被伪装成Point来使用，是因为NamePoint是Point结构体的一个超集，同时两者共同成员的顺序也是一样的。</p><p>同时应该注意的是，在main.c中，程序员必须强制将NamePoint的参数类型转换为Point，而在真正的面向对象编程语言中，这种类型的向上转换通常应该是隐性的。</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>先看下面这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> c;<br><span class="hljs-keyword">while</span> ((c=getchar())!=EOF)<br><span class="hljs-built_in">putchar</span>(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>多态类似golang的接口，函数getchar()主要负责从STDIN中读取数据，但是STDIN究竟是指代的哪个设备呢？同样的道理，putchar()主要负责将数据写入STDOUT，而STDOUT又指代哪个设备呢？很显然，这类函数就具有多态性。</p><p>这里的STDIN和STDOUT类似Java的接口，各种设备都有自己各自的实现。当然，C程序中是没有接口这个概念的。那么getchar()这个调用的动作是如何真正传递到设备驱动程序中，从而读取到具体内容的呢？</p><p>其实很简单，UNIX操作系统强制要求每个IO设备都要提供open、close、read、write和seek这5个标准函数，也就是说，每个IO设备驱动程序对这5个函数的实现在函数调用上必须保持一致。</p><p>FILE数据结构体中包含了相对应的5歌函数指针，分别用于指向这些函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FILE</span> &#123;</span><br><span class="hljs-type">void</span> (*open)(<span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> mode);<br>viod (*close)();<br><span class="hljs-type">int</span> (*read)();<br><span class="hljs-type">void</span> (*write)(<span class="hljs-type">char</span>);<br><span class="hljs-type">void</span> (*seek)(<span class="hljs-type">long</span> index, <span class="hljs-type">int</span> mode);<br>&#125;<br></code></pre></td></tr></table></figure><p>比如控制台设备的IO驱动程序会提供这5个函数的实际定义，将FILE结构体的函数指针指向这些对应的实现函数，那么上面的getchar()只是调用了STDIN所指向的FILE数据结构体中的read函数指针指向的函数。因为多态，上面的IO设备变成了copy程序的插件。</p><p>常规的控制流是：</p><p><img src="/../images/image-20240218160328850.png" alt="image-20240218160328850"></p><p>图上可见：源代码层面的依赖不可避免的要跟随程序的控制流。main函数调用高层函数，它就必须能够看到这个函数所在的模块，总之，每个函数的调用房都必须要引用被调用方所在的模块。这样就导致了我们在软件架构上别无选择，这里系统决定了控制流，控制流则决定了源代码依赖关系。</p><p>使用多态，可以实现<strong>依赖反转</strong>：先参考下面的图</p><p><img src="/../images/image-20240218154725206.png" alt="image-20240218154725206"></p><p>模块HL1调用了ML1模块中的F()函数，这个调用是通过源代码级别的接口来实现的，当然在函数实际运行中，接口这个概念是不存在的。模块ML1和接口的依赖关系，该关系和控制流正好是相反的，称之为依赖反转。</p><p>实际上，通过面向对象编程语言提供的这种安全便利的多态实现，无论我们面对怎么样的源代码级别的依赖关系，都可以将其反转。</p><blockquote><p>一个关于依赖反转的例子：<a href="https://juejin.cn/post/7023594132660551693">来源</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendMsgDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> canSendMsg &#123;...&#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">if</span>(canSendMsg()) &#123;<br>            <span class="hljs-comment">// 发送消息处理</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 消息发送失败处理</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是 <code>所有流程由程序员控制</code>，那么我们可以改变一下，<code>由框架去控制流程</code>呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将消息发送器抽象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canSendMsg</span><span class="hljs-params">()</span>;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSend</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(canSendMsg()) &#123;<br>            <span class="hljs-comment">// 发送消息处理</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 消息发送失败处理</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现一个消息发送器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMsgSender</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MsgSender</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canSendMsg</span><span class="hljs-params">()</span> &#123;...&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendMsgDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;MsgSender&gt; senders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  <br>    <span class="hljs-comment">// 注册消息发送器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(MsgSender sender)</span> &#123;<br>        <span class="hljs-keyword">if</span>(sender != <span class="hljs-literal">null</span>) &#123;<br>            senders.add(sender);<br>        &#125;      <br>    &#125;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 注册流程，可以通过第三方配置类或者配置文件进行注册 MsgSender</span><br>        <span class="hljs-comment">// 为了完整逻辑，当前在这里注册</span><br>        register(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserMsgSender</span>());<br>  <br>        <span class="hljs-comment">// 执行消息发送逻辑</span><br>        <span class="hljs-keyword">for</span> (MsgSender sender : senders) &#123;<br>            sender.doSend();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们在框架中预留了扩展点 MsgSender ， 也就是，我们实现发送信息的逻辑，只需要自定义 MsgSender 即可实现功能，无需再次修改框架逻辑 main，这是典型利用模板设计模式实现控制反转的例子。</p><p>框架提供的是代码骨架，通过扩展点组装对象并控制执行流程。程序员在编写框架时，需要思考预留好扩展点，通过扩展点定制化自己的业务，自定义的业务逻辑借用框架，链接驱动整个程序流程的执行。</p><p><code>“控制”是指对程序执行流程的控制；“反转”是由程序员控制程序执行流程，到框架控制程序执行流程，控制权从程序员转移到框架上。</code>控制反转并非实现技巧，而是一种设计思想，主要用于指引框架的设计。</p></blockquote><h4 id="本章小结-3"><a href="#本章小结-3" class="headerlink" title="本章小结"></a>本章小结</h4><p>面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层插件的开发和部署。</p><h3 id="第6章-函数式编程"><a href="#第6章-函数式编程" class="headerlink" title="第6章 函数式编程"></a>第6章 函数式编程</h3><p>函数式编程语言中的变量（Variable）是不可变的。</p><h4 id="可变性与软件架构"><a href="#可变性与软件架构" class="headerlink" title="可变性与软件架构"></a>可变性与软件架构</h4><h4 id="可变性的隔离"><a href="#可变性的隔离" class="headerlink" title="可变性的隔离"></a>可变性的隔离</h4><p>不可变组件用纯函数的方式来执行任务，期间不更改任何状态，这些不可变的组件将通过一个或者多个非函数式组件通信的方式来修改状态。</p><p><img src="/../images/image-20240218164655517.png" alt="image-20240218164655517"></p><p>由于状态的修改会导致一系列的并发问题的产生，所以我们通常会采用某种事务型内存来保护可变变量，避免同步更新和竞争状态的发生。</p><p>一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量。</p><p>软件架构师应该着力于将大部分处理逻辑都归于不可变组件中，可变状态组件的逻辑应该越少越好。</p><h4 id="事件溯源"><a href="#事件溯源" class="headerlink" title="事件溯源"></a>事件溯源</h4><p><strong>事件溯源是什么意思</strong>？一个简单的例子是银行会存储客户账号余额信息，当它执行存取款业务时，同时要负责修改余额记录。如果不保存具体账户余额，只保存事务日志，那么当有人想查询账户余额时，我们就将全部交易记录取出，每次都从最开始到当下累计。当然这样的设计就不需要维护任何可变变量了。那么关于如何追溯历史时刻的账户余额 ，这就是事件溯源。在这种事件溯源体系下，我们只存储事务记录，不存储具体状态。当需要具体状态时，我们只需要从头开始计算所有事务即可。</p><h4 id="本章小结-4"><a href="#本章小结-4" class="headerlink" title="本章小结"></a>本章小结</h4><p>结构化编程时对程序控制权的直接转移的限制</p><p>面向对象编程时对程序控制权的间接转移的限制</p><p>函数式编程时对程序中赋值操作的限制</p><h2 id="第三部分-设计原理"><a href="#第三部分-设计原理" class="headerlink" title="第三部分 设计原理"></a>第三部分 设计原理</h2><p>SOLID原则的主要作用就是告诉我们如何将数据和函数组织为类，以及如何将这些类链接起来成为程序。</p><p>SOLID原则是一系列原则的总结：</p><p>SRP：单一职责原则</p><p>OCP：开闭原则</p><p>LSP：里氏替换原则</p><p>ISP：接口隔离原则</p><p>DIP：依赖反转原则</p><h3 id="第7章-SRP：单一职责原则"><a href="#第7章-SRP：单一职责原则" class="headerlink" title="第7章 SRP：单一职责原则"></a>第7章 SRP：单一职责原则</h3><p>总结起来就是：任何一个软件模块都应该有且仅有一个被修改的原因。</p><h3 id="第8章-OCP：开闭原则"><a href="#第8章-OCP：开闭原则" class="headerlink" title="第8章 OCP：开闭原则"></a>第8章 OCP：开闭原则</h3><p>OCP主要目的是让系统易于拓展，同时限制每次被修改所影响的范围。实现方式就是通过将系统划分为一系列组件，并将这些组件间的依赖关系按照层次进行组织，使得高阶组件不会因为低阶组件被修改受到影响。</p><h3 id="第9章-LSP：里氏替换原则"><a href="#第9章-LSP：里氏替换原则" class="headerlink" title="第9章 LSP：里氏替换原则"></a>第9章 LSP：里氏替换原则</h3><h3 id="第10章-ISP：接口隔离原则"><a href="#第10章-ISP：接口隔离原则" class="headerlink" title="第10章 ISP：接口隔离原则"></a>第10章 ISP：接口隔离原则</h3><p>对于python和ruby这样的动态语言来说，源代码就不存在这样的声明，它们所用对象的类型会在运行时被推演出来，所以也就不存在强制重新编译和重新部署等必要性。这就是动态类型语言要比静态类型语言更灵活、耦合度更松的原因。</p><h3 id="第11章-DIP：依赖反转原则"><a href="#第11章-DIP：依赖反转原则" class="headerlink" title="第11章 DIP：依赖反转原则"></a>第11章 DIP：依赖反转原则</h3><p>这个原则强调，如何想要设计一个灵活的系统，在源代码层次的依赖关系中，就应该多引用抽象类型，而非具体实现。</p><p>也就是说，在java这类静态类型的编程语言中，在使用use、import、include这些语句时应该只引用哪些包含接口、抽象类或者其他抽象类型声明的源文件，不应该引用任何具体实现。</p><h2 id="第四部分-组件构建原则"><a href="#第四部分-组件构建原则" class="headerlink" title="第四部分 组件构建原则"></a>第四部分 组件构建原则</h2><h3 id="第12章-组件"><a href="#第12章-组件" class="headerlink" title="第12章 组件"></a>第12章 组件</h3><p>组件时软件在部署过程中的最小单元。</p><p>如果一段程序调用了某个库函数，编译器会将这个函数的名字输出为外部引用（external reference），而将库函数的定义输出为外部定义（external definition），加载器在加载完程序后，会将外部引用和外部定义链接（link）起来。</p><p>程序员将加载过程和链接过程进行分离，他们将耗时较长的部分（链接部分）放到一个单独的程序中去运行，这个程序就是所谓的链接器（linker）。链接器的输出是一个完成了外部链接的，可以重定位的二进制文件，这种文件可以由一个支持重定位的加载器迅速加载到内存中，这使得程序员可以用缓慢的链接器生产出可以更快进行多次加载的可执行文件。</p><p>程序规模上的墨菲定律：程序的规模会一直不断的增长下去，直到有限的编译和链接时间填满为止。</p><h3 id="第13章-组件聚合"><a href="#第13章-组件聚合" class="headerlink" title="第13章 组件聚合"></a>第13章 组件聚合</h3><h4 id="复用-x2F-发布等同原则"><a href="#复用-x2F-发布等同原则" class="headerlink" title="复用&#x2F;发布等同原则"></a>复用&#x2F;发布等同原则</h4><p>软件复用的最小粒度应该等同于其发布的最小粒度。</p><h4 id="共同闭包原则"><a href="#共同闭包原则" class="headerlink" title="共同闭包原则"></a>共同闭包原则</h4><p>将由于相同原因而修改，并且需要同时修改的东西放在一起。将由于不同原因而修改，并且不同时修改的东西分开。</p><h3 id="第13章-组件耦合"><a href="#第13章-组件耦合" class="headerlink" title="第13章 组件耦合"></a>第13章 组件耦合</h3><h4 id="无依赖环原则"><a href="#无依赖环原则" class="headerlink" title="无依赖环原则"></a>无依赖环原则</h4><p>组件依赖关系图中不应该出现环。</p><h4 id="自上而下的设计"><a href="#自上而下的设计" class="headerlink" title="自上而下的设计"></a>自上而下的设计</h4><h4 id="稳定依赖原则"><a href="#稳定依赖原则" class="headerlink" title="稳定依赖原则"></a>稳定依赖原则</h4><p><img src="/../images/image-20240218175734958.png" alt="image-20240218175734958"></p><p>这里的X是一个稳定的组件，因为有三个组件依赖着X，所以X有三个不应该被修改的原因，这里就说X要对三个组件负责，另一方面，X不依赖于任何组件，所以不会有任何原因导致它需要变更，我们称它为“独立”组件。这里的图，A依赖B，那么A就有向B的箭头。</p><p><img src="/../images/image-20240218175912809.png" alt="image-20240218175912809"></p><p>与X相反，这里的Y是一个非常不稳定的组件。由于没有其他组件依赖Y，所以Y不对任何组件负责。但是Y同时依赖三个组件，所以它的变更就是可能由三个不同的源产生，这里说Y是有依赖性的组件。</p><h4 id="并不是所有的组件都应该是稳定的"><a href="#并不是所有的组件都应该是稳定的" class="headerlink" title="并不是所有的组件都应该是稳定的"></a>并不是所有的组件都应该是稳定的</h4><p>当我们使用Ruby或者Python这类动态类语言时，这些抽象接口实际上并不存在，因此也就没有对它们的依赖，动态类型语言中的依赖关系是非常简单的，因为其依赖反转的过程中并不需要声明和继承接口。</p><h2 id="第五部分-软件架构"><a href="#第五部分-软件架构" class="headerlink" title="第五部分 软件架构"></a>第五部分 软件架构</h2><h3 id="第15章-什么是软件架构"><a href="#第15章-什么是软件架构" class="headerlink" title="第15章 什么是软件架构"></a>第15章 什么是软件架构</h3><p>软件架构师自身需要是程序员，并且必须一直坚持做一线程序员。</p><p>软件架构师生产的代码量也许不是最多的，但是他们必须不停的承接编程任务。</p><h4 id="开发（Development）"><a href="#开发（Development）" class="headerlink" title="开发（Development）"></a>开发（Development）</h4><h4 id="部署（Deployment）"><a href="#部署（Deployment）" class="headerlink" title="部署（Deployment）"></a>部署（Deployment）</h4><h4 id="运行（Operation）"><a href="#运行（Operation）" class="headerlink" title="运行（Operation）"></a>运行（Operation）</h4><h4 id="维护（Maintenance）"><a href="#维护（Maintenance）" class="headerlink" title="维护（Maintenance）"></a>维护（Maintenance）</h4><h4 id="保持可选项"><a href="#保持可选项" class="headerlink" title="保持可选项"></a>保持可选项</h4><h4 id="设备无关性"><a href="#设备无关性" class="headerlink" title="设备无关性"></a>设备无关性</h4><h4 id="垃圾邮件"><a href="#垃圾邮件" class="headerlink" title="垃圾邮件"></a>垃圾邮件</h4><h4 id="物理地址寻址"><a href="#物理地址寻址" class="headerlink" title="物理地址寻址"></a>物理地址寻址</h4><h4 id="本章小结-5"><a href="#本章小结-5" class="headerlink" title="本章小结"></a>本章小结</h4><p>在本章中，我们用两个小故事示范了一些架构师普遍会采用的设计原则，优秀的架构师会小心得将软件的高层策略与其底层实现隔离开，让高层策略与实现细节脱钩，使其策略部分完全不需要关心底层细节，当然也不会对这些细节有任何形式的依赖。另外，优秀的架构师所设计的策略应该允许系统尽可能推迟与实现细节相关的决策，越晚做决策越好。</p><h3 id="第16章-独立性"><a href="#第16章-独立性" class="headerlink" title="第16章 独立性"></a>第16章 独立性</h3><h4 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h4><p>如果某系统是一个购物车应用，那么该系统的架构就必须非常直观的支持这类应用可能会涉及到的所有用例。</p><p>软件的架构必须为其用例提供支持。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><p>康威定律：任何一个组织在设计系统时，往往都会复制出一个与该组织内部沟通结构相同的系统。</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>一个系统的架构在其部署的便捷性方便起到的作用也是非常大的，设计目标一定是“立刻部署”。</p><h4 id="保留可选项"><a href="#保留可选项" class="headerlink" title="保留可选项"></a>保留可选项</h4><p>一个设计良好的架构想要权衡上述的所有关注点，然后尽可能的形成一个同时满足所有要求的组件结构，没有那么容易。因为大部分时间无法预知系统的所有用例和运行条件，开发团队的结构等等。就算了解了他们也会变化。</p><p>一个设计良好的架构应该通过保留可选项的方式，让系统在任何情况下都能方便的做出必要的变更。</p><h4 id="按层解耦"><a href="#按层解耦" class="headerlink" title="按层解耦"></a>按层解耦</h4><p>一个系统可以被解耦成若干个水平分层—- UI界面，应用独有的业务逻辑，领域普适的业务逻辑，数据库等。</p><h4 id="用例的解耦"><a href="#用例的解耦" class="headerlink" title="用例的解耦"></a>用例的解耦</h4><p>按照用例切分系统，比如添加新订单的用例和删除订单的用例可以切分开。</p><p>一个简单的例子：将新增订单这个用例的UI和删除订单用例的UI分开，那么对业务逻辑的部分，数据库的部分，也要</p><p>我们如果按照变更原因的不同对系统进行解耦，就可以持续向系统添加新的用例，而不会影响新的用例。如果同时对支持这些用例的UI和数据库也进行了分组，那么每个用例使用的就是不同面向的UI和数据库，因此增加新用例就不太可能影响就的用例了。</p><h4 id="解耦的模式"><a href="#解耦的模式" class="headerlink" title="解耦的模式"></a>解耦的模式</h4><h4 id="开发的独立性"><a href="#开发的独立性" class="headerlink" title="开发的独立性"></a>开发的独立性</h4><h4 id="部署的独立性"><a href="#部署的独立性" class="headerlink" title="部署的独立性"></a>部署的独立性</h4><h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><h4 id="再谈解耦模式"><a href="#再谈解耦模式" class="headerlink" title="再谈解耦模式"></a>再谈解耦模式</h4><p>我们可以在源代码层次上解耦，二进制层次上解耦（部署），也可以在执行单元层次上解耦（服务）。包括：源代码层次，部署层次，服务层次。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>要达到上述要求难度不小，系统的部署模式并不一定就一定要是某种简单的配置项（虽然在某些情况的确应该这样做）。这里的主要观点认为，一个系统所使用的解耦模式可能会随着时间而变化，优秀的架构师应该能遇见这一点，并且做出响应的对策。</p><h3 id="第17章-划分边界"><a href="#第17章-划分边界" class="headerlink" title="第17章 划分边界"></a>第17章 划分边界</h3><h4 id="输入和输出怎么办"><a href="#输入和输出怎么办" class="headerlink" title="输入和输出怎么办"></a>输入和输出怎么办</h4><p>开发者和使用者经常会对系统边界究竟如何定义感到疑惑。因为GUI是直观可见的，所以有人会以GUI的视角来定义整个系统。但是实际上GUI后面是有个BusinessRules组件的，可以在脱离GUIde情况下完成所有的任务逻辑，负责的是业务逻辑。</p><p>那么GUI和BusinessRules这两个组件之间应该也有一条边界线，在这里不重要的组件依赖于较为重要的组件，箭头指向的方向表示组件之间的关系，GUI关心BusinessRules。</p><p><img src="/../images/image-20240220182038306.png" alt="image-20240220182038306"></p><h4 id="插件式架构"><a href="#插件式架构" class="headerlink" title="插件式架构"></a>插件式架构</h4><h4 id="插件式架构的好处"><a href="#插件式架构的好处" class="headerlink" title="插件式架构的好处"></a>插件式架构的好处</h4><p>将系统设计为插件式架构，就等于构建起了一面变更无法逾越的防火墙，换句话说，只要GUI是以插件形式插入系统的业务逻辑中的，那么GUI这边所发起的变更就不会影响系统的业务逻辑。</p><h4 id="本章小结-6"><a href="#本章小结-6" class="headerlink" title="本章小结"></a>本章小结</h4><p>为了在软件架构中画边界线，我们需要先将系统分割为组件，其中一部分是系统的核心业务逻辑组件，另外一部分是与业务逻辑无关的但是负责提供必要功能的插件，通过修改源代码，让这些非核心的组件依赖于系统的核心业务逻辑组件。</p><p>其实，这也是一种对依赖反转原则（DIP）和稳定抽象原则（SAP）的具体应用，依赖箭头应该由底层具体实现细节指向高层抽象的方向。</p><h3 id="第18章-边界剖析"><a href="#第18章-边界剖析" class="headerlink" title="第18章 边界剖析"></a>第18章 边界剖析</h3><h4 id="跨边界调用"><a href="#跨边界调用" class="headerlink" title="跨边界调用"></a>跨边界调用</h4><p>当一个模块的源代码发生变更时，其他模块的源代码也可能会随之发生变更或者重新编译，所谓划分边界，就是在这些模块之间建立这种针对变更的防火墙。</p><h4 id="令人生畏的单体结构"><a href="#令人生畏的单体结构" class="headerlink" title="令人生畏的单体结构"></a>令人生畏的单体结构</h4><h4 id="部署层次的组件"><a href="#部署层次的组件" class="headerlink" title="部署层次的组件"></a>部署层次的组件</h4><p>下面我们看下系统最常见的物理边界形式：动态链接库。这种形式包括.Net的DLL、java的jar文件、Ruby Gem以及UNIX共享库等，这种类型的组件在部署时不需要重新编译，因为它们都是以二进制形式或者其他等价的课部署形式交付的。这里采用的就是部署层次上的解耦模式，部署这类项目，就是将所有可部署的单元打包成一个便于操作的文件格式，例如WAR文件，甚至可以时一个目录（或者文件夹）。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>单体结构和按部署层次划分的组件都可以采用线程模型。当然，线程不属于架构边界，也不属于部署单元，它们仅仅时一种管理并调度程序执行的方式。一个线程既可以被包含在单一组件中，也可以横跨多个组件。</p><h4 id="本地进程"><a href="#本地进程" class="headerlink" title="本地进程"></a>本地进程</h4><p>本地进程一般是由命令行启动或者其他等价的系统调用产生的。</p><p>本地进程会使用socket来实现彼此的通信。也可以通过一些操作系统提供的方式来通信，比如共享邮件或者消息队列。</p><p>每个本地进程可以是一个静态链接的单体结构，也可以是一个由动态链接组件组成的程序。</p><p>对于本地进程来说，这就意味着高层进程的源代码中不应该包含低层进程的名字，物理内存地址或者注册表键名。该系统架构的设计目标是让低层进程成为高层进程的一个插件。</p><p>本地进程之间的跨边界通信需要用到系统调用，数据的编码和解码，以及进程间的上下文切换，成本会高些，所以需要谨慎的控制通信的次数。</p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>系统架构中的最强的边界形式是服务，一个服务就是一个进程。</p><p>服务之间的跨边界通信相对于函数调用来说，速度是很缓慢的，其往返时间可以是几十毫秒到几秒不等。</p><p>除此之外，我们可以在服务层次上使用与本地进程相同的规则。也就是让较低层次服务成为较高层次的“插件”，为此需要确保高层次服务的源代码没有包含任何与低层次服务相关的物理信息（例如URL）。</p><h4 id="本章小结-7"><a href="#本章小结-7" class="headerlink" title="本章小结"></a>本章小结</h4><p>除了单体结构外，大部分系统都会同时采用多种边界策略。一个按照服务层次划分边界的系统也可能会在某一部分采用本地进程的边界划分模式。事实上，服务经常不过就是一系列互相作用的本地进程的某种外在形式。无论是服务还是本地进程，它们几乎都肯定是由一个或者多个源代码组成的单体结构，或者一组动态链接的可部署组件。</p><p>这也意味着一个系统中通常会同时包含高通信量、低延迟的本地架构边界和低通信量、高延迟的服务边界。</p><h3 id="第19章-策略与层次"><a href="#第19章-策略与层次" class="headerlink" title="第19章 策略与层次"></a>第19章 策略与层次</h3><p>所有的软件系统都是一组策略语句的集合。计算机程序就是一组仔细描述如何将输入转化为输出的策略语句的集合。</p><p> 大多数非小系统中，整体业务逻辑通常都可以被拆解为多组更小的策略语句。一部分策略语句用于描述计算部分的业务逻辑，另一部分策略语句专门用于描述计算机报告的格式。</p><p>软件架构设计的工作之一就是将这些策略彼此分离，然后把他们按照新的方式重组。其中变更原因，时间和层次相同的策略应该被分到同一个组件中，不同的应该被分到不同的组件。</p><p>软件架构的工作就是将组件重新排列为一个有向无环图，图中的每一个节点代表一个拥有相同层次策略的组件，每一条单向链接代表了一种组件之间的依赖关系。</p><h4 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h4><p>这里的层次指的是输入和输出之间的距离。如果一条策略距离系统的输入&#x2F;输出越远，它所属的层次就越高，而直接管理输入&#x2F;输出的策略在系统的层次是最低的。</p><p>下面是一个加密程序的更好的系统设计架构</p><p><img src="/../images/image-20240227182240497.png" alt="image-20240227182240497"></p><h4 id="本章小结-8"><a href="#本章小结-8" class="headerlink" title="本章小结"></a>本章小结</h4><p>本章针对策略的讨论涉及单一职责原则（SRP）、开闭原则（OCP）、共同闭包原则（CCP）、依赖反转原则（DIP）、稳定依赖原则（SDP）以及稳定抽象原则。</p><h3 id="第20章-业务逻辑"><a href="#第20章-业务逻辑" class="headerlink" title="第20章 业务逻辑"></a>第20章 业务逻辑</h3><p>业务逻辑就是那些真正用于赚钱或者省钱的业务逻辑与过程。更严格的说，无论这些业务逻辑实在计算机上面实现的，还是人工执行的，他们在省钱、赚钱上都是一样的。</p><p>“关键业务逻辑”是指那些业务的关键部分，赚钱部分。关键业务逻辑通常会需要处理一些数据，例如在借贷的业务逻辑中，需要知晓借贷的数量、利率以及还款日期。</p><p>我们将这些数据称为“关键业务数据”，这是因为这些数据无论自动化程序存在与否，都必须存在。</p><p>关键业务逻辑和关键业务数据是紧密相关的，所以它们很适合被放在同一个对象里处理，我们成这种对象为<strong>“业务实体（Entity）”。</strong></p><h4 id="业务实体"><a href="#业务实体" class="headerlink" title="业务实体"></a>业务实体</h4><p>业务实体包含了一系列用于操作关键数据的业务逻辑。</p><p>比如下面是一个关于借贷业务的实体类Loan的UML图。</p><p><img src="/../images/image-20240227182846563.png" alt="image-20240227182846563"></p><p>这个类独自代表了整个业务逻辑，它与数据库、用户界面、第三方框架无关。</p><p>业务实体这个概念应该之后业务逻辑，没有别的。</p><h4 id="用例-1"><a href="#用例-1" class="headerlink" title="用例"></a>用例</h4><p>不是所有的业务逻辑都是一个纯粹的业务实体。比如有些业务逻辑是通过定义或者限制自动化系统的运行方式来实现赚钱或者省钱的业务的，这些业务逻辑就不能靠人工执行，它们只有作为自动化系统的一部分时才有意义。</p><p>用例并部描述系统与用户之间的接口，它只描述应用在某些特定场景下的业务逻辑。这些业务逻辑所规范的是用户与业务实体之间的交互方式，它与数据流入&#x2F;流出系统的方式无关。</p><p>为什么业务实体属于高层概念，而用例属于低层概念呢？这是因为业务描述的是一个特定的应用场景，这样一来，用例必然会更靠近系统的输入和输出。用例依赖业务实体，而业务实体不依赖于应用。</p><h4 id="请求和响应模型"><a href="#请求和响应模型" class="headerlink" title="请求和响应模型"></a>请求和响应模型</h4><p>用例类所接收的输入应该是一个简单的请求性数据结构，返回输出应该是一个简单的响应性数据结构。这些数据结构不应该存在任何依赖关系，不派生于HttpRequest和HttpResponse这样的标准框架接口。</p><p>尽量不要在用例类中直接对业务实体对象引用，因为业务实体对象和用例并没有强相关，强行引用会违反共同闭包原则（CCP）和单一职责原则（SRP）。</p><h4 id="本章小结-9"><a href="#本章小结-9" class="headerlink" title="本章小结"></a>本章小结</h4><p>业务逻辑是一个系统软件存在的意义，是核心功能，是系统用来赚钱或者省钱的那部分。</p><p>这些业务逻辑应该保持纯净，不要掺杂用户界面或者所使用的数据库相关的东西。其他低层次概念应该以插件的形式接入系统，业务逻辑应该是系统最独立的部分。</p><h3 id="第21章-尖叫的软件架构"><a href="#第21章-尖叫的软件架构" class="headerlink" title="第21章 尖叫的软件架构"></a>第21章 尖叫的软件架构</h3><h4 id="架构设计的主题"><a href="#架构设计的主题" class="headerlink" title="架构设计的主题"></a>架构设计的主题</h4><h4 id="架构设计的核心目标"><a href="#架构设计的核心目标" class="headerlink" title="架构设计的核心目标"></a>架构设计的核心目标</h4><p>良好的架构设计应该允许用户在项目后期再决定是否采用Rails、Hibernate、Tomcat、Mysql这些工具。良好的架构设计应该只关注用例，并将它们与其他的周边因素隔离。</p><h4 id="Web呢"><a href="#Web呢" class="headerlink" title="Web呢"></a>Web呢</h4><p>web究竟是不是一种架构呢？其实上web只是一种交付手段，一种IO设备，这是其在应用程序的架构设计中的角色。</p><h4 id="框架是工具而不是生活信条"><a href="#框架是工具而不是生活信条" class="headerlink" title="框架是工具而不是生活信条"></a>框架是工具而不是生活信条</h4><p>一定要采用怀疑的态度审视每一个框架。</p><h4 id="可测试的框架设计"><a href="#可测试的框架设计" class="headerlink" title="可测试的框架设计"></a>可测试的框架设计</h4><p>如果系统框架的设计都是围绕用例展开的，那么就可以在不依赖任何框架的基础上对这些用例进行测试。</p><p>运行测试时也不应该运行web服务</p><h4 id="本章小结-10"><a href="#本章小结-10" class="headerlink" title="本章小结"></a>本章小结</h4><p>一个系统的架构应该着重于展示系统本身的设计，而非该系统所使用的框架，如果要构建一个医疗系统，那么不了解的程序员一看到源代码就知道这是一个医疗系统。<strong>新来的程序员应该先了解系统的用例，而非系统的交付方式，</strong></p><h3 id="第22章-整洁架构"><a href="#第22章-整洁架构" class="headerlink" title="第22章 整洁架构"></a>第22章 整洁架构</h3><p><img src="/../images/image-20240320105910642.png" alt="image-20240320105910642"></p><p>图上的同心圆分别代表了软件系统中的不同层次，通常越靠近中心，其所在的软件的层次越高。基本上外层圈代表的是机制，内层圈代表的是策略。</p><p>源代码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。</p><p>接口适配器：接口适配器通常是一组数据转换器，它们负责将数据从对用例和业务实体而言最方便操作的格式，转换成外部系统）比如数据库和web）最方便操作的格式。</p><p>哪些数据会跨越上述的边界？一般而言跨越边界的数据在数据结构上都是很简单的。在进行跨边界传输时，一定要采用内层最方便使用的形式。</p><h3 id="第23章-展示器和谦卑对象"><a href="#第23章-展示器和谦卑对象" class="headerlink" title="第23章 展示器和谦卑对象"></a>第23章 展示器和谦卑对象</h3><p>展示器（presenter）实际上是采用谦卑对象（humble object）模式的一种形式，这种设计模式可以很好的帮助识别和保护架构的边界。</p><h4 id="谦卑对象模式"><a href="#谦卑对象模式" class="headerlink" title="谦卑对象模式"></a>谦卑对象模式</h4><p>谦卑对象模式最初的设计目的是帮助单元测试的编写者区分容易测试的部分和不容易测试的部分。<strong>难以测试的部分会被划分到谦卑（Humble）组里</strong>，因为难以测试，所以谦卑对象应该越简单越好。另一个组就是包含其他的部分。</p><h4 id="展示与视图"><a href="#展示与视图" class="headerlink" title="展示与视图"></a>展示与视图</h4><p>比如视图也是就是UI是谦卑组里的，应用程序所能控制的，就是屏幕上展示的一切东西，都应该在视图中以字符串、布尔值或者枚举值的形式存在的。视图部分除了加载视图模型所需要的值，不应该再做其他事情。</p><h4 id="测试与架构"><a href="#测试与架构" class="headerlink" title="测试与架构"></a>测试与架构</h4><h4 id="数据库网关"><a href="#数据库网关" class="headerlink" title="数据库网关"></a>数据库网关</h4><p>数据库网关就是用例交互器（interactor）与数据库之间的组件。</p><p>SQL不应该出现在用例层的代码中，所以这部分的功能需要通过网关接口来提供，而这些接口的实现则需要通过数据库的类来负责。</p><h4 id="本章小结-11"><a href="#本章小结-11" class="headerlink" title="本章小结"></a>本章小结</h4><p>在每个系统架构的边界处，都有可能发现谦卑对象模式的存在。在系统的边界处使用谦卑对象模式，可以大幅度提高系统的可测试性。</p><h3 id="第24章-不完全边界"><a href="#第24章-不完全边界" class="headerlink" title="第24章 不完全边界"></a>第24章 不完全边界</h3><p>敏健社区的一个要义是：You Aren’t Going To Need It，即不要预测未来的需要。但是架构师设计系统的时候必然要为未来考虑一些即预测未来的需求的，那这样和上面的要义冲突了，此时就需要引入不完全边界（partial boundary）了。</p><h4 id="省掉最后一步"><a href="#省掉最后一步" class="headerlink" title="省掉最后一步"></a>省掉最后一步</h4><p>构建不完全边界的一种方法就是将系统分割成一系列可以独立编译、独立部署的组件后，再把它们构建成一个组件。这种方法需要的代码量和设计的工作量，和设计完整边界的是一样的。但是省掉了多组件管理中的版本号和发布部署等工作。</p><h4 id="单向边界"><a href="#单向边界" class="headerlink" title="单向边界"></a>单向边界</h4><p>在设计一套完整的系统架构边界时，往往需要反向接口来维护边界两侧的组件的隔离性。</p><h4 id="门户模式"><a href="#门户模式" class="headerlink" title="门户模式"></a>门户模式</h4><p>这个模式下，连依赖反转的工作都省略了，边界将只由Facade类定义，这个类的背后是一份包含了所有服务函数的列表，会将Client的调用传递给对Client不可见的服务函数。</p><p><img src="/../images/image-20240515160736556.png" alt="image-20240515160736556"></p><h4 id="本章小结-12"><a href="#本章小结-12" class="headerlink" title="本章小结"></a>本章小结</h4><h3 id="第25章-层次与边界"><a href="#第25章-层次与边界" class="headerlink" title="第25章 层次与边界"></a>第25章 层次与边界</h3><p>一般人们习惯将系统分为三个组件：UI、业务逻辑和数据库。但是对于复杂的系统其实不止这三个组件。下面举出不仅仅包含这三个组件的服务：</p><h4 id="基于文本的冒险游戏：Hunt-The-Wumpus"><a href="#基于文本的冒险游戏：Hunt-The-Wumpus" class="headerlink" title="基于文本的冒险游戏：Hunt The Wumpus"></a>基于文本的冒险游戏：Hunt The Wumpus</h4><h4 id="可否采用整洁架构"><a href="#可否采用整洁架构" class="headerlink" title="可否采用整洁架构"></a>可否采用整洁架构</h4><p>A组件调用B组件时，如果通过接口调用，那么这个接口是需要A维护的而不需要B维护。</p><h4 id="本章小结-13"><a href="#本章小结-13" class="headerlink" title="本章小结"></a>本章小结</h4><h3 id="第26章-Main组件"><a href="#第26章-Main组件" class="headerlink" title="第26章 Main组件"></a>第26章 Main组件</h3><p>在所有的系统中，都至少要有一个组件来负责创建、协调、监督其他组件的运转，我们将其称为Main组件。</p><h4 id="最细节化的部分"><a href="#最细节化的部分" class="headerlink" title="最细节化的部分"></a>最细节化的部分</h4><p>Main组件时系统的起点，除了操作系统不会再有组件依赖它了，它只可能依赖别人。Main组件的任务是创建所有的工厂类，策略以及其他的全局设施，并最终将系统的控制权转交给最高抽象层的代码来处理。</p><p>Main组件是整个系统的一个底层模块，处于整洁架构的最外圈，负责为系统加载所有的必要信息。</p><h4 id="本章小结-14"><a href="#本章小结-14" class="headerlink" title="本章小结"></a>本章小结</h4><p>Main组件也可以被视为应用程序的一个插件，这个插件负责设置起始状态、配置信息、加载外部资源、最后将控制权交给应用程序的其他高层组件。</p><p>可以对系统设计多个Main组件，比如设计专门用于开发环境的Main组件，也可以设计专门用于测试或者生产的Main组件。</p><h3 id="第27章-服务：宏观与微观"><a href="#第27章-服务：宏观与微观" class="headerlink" title="第27章 服务：宏观与微观"></a>第27章 服务：宏观与微观</h3><h4 id="面向服务的架构"><a href="#面向服务的架构" class="headerlink" title="面向服务的架构"></a>面向服务的架构</h4><p>架构设计的任务就是找到高层策略与底层细节之间的架构边界，同时保证这些边界遵守依赖关系规则。</p><h4 id="基于组件的服务"><a href="#基于组件的服务" class="headerlink" title="基于组件的服务"></a>基于组件的服务</h4><p>可以将java文件中的服务看作是一个或者多个jar文件的一组抽象类，而每个新功能或者扩展功能都是 另一个jar文件中的类，它们都扩展了之前jar文件中的抽象类。这样，部署新功能就不再是部署服务了，而是简单的在服务的加载路径下添加一个jar文件，换句话说，这种增加新功能的过程符合开闭原则（OCP）。</p><h4 id="本章小结-15"><a href="#本章小结-15" class="headerlink" title="本章小结"></a>本章小结</h4><p>服务本身不能代表整个系统的架构设计，系统的架构由系统内部的架构边界以及边界之间的依赖关系所定义。</p><h3 id="第28章-测试边界"><a href="#第28章-测试边界" class="headerlink" title="第28章 测试边界"></a>第28章 测试边界</h3><h4 id="测试也是一种系统组件"><a href="#测试也是一种系统组件" class="headerlink" title="测试也是一种系统组件"></a>测试也是一种系统组件</h4><p>测试组件是可以独立部署的，实际上大部分测试组件都是被部署在测试环境中的，而不是生产环境中的。即使那些本身不需要独立部署的系统的测试代码也是独立部署的。</p><h4 id="可测试设计"><a href="#可测试设计" class="headerlink" title="可测试设计"></a>可测试设计</h4><p>修改一个通用的系统组件导致成百上千个测试出现问题，这个问题成为“脆弱的测试问题”。</p><p>GUI往往是多变的，通过GUI来验证系统的测试一定是脆弱的。因此在系统设计和测试设计中，应该让业务不通过GUI被测试。</p><h4 id="测试专用API"><a href="#测试专用API" class="headerlink" title="测试专用API"></a>测试专用API</h4><p>这个API应该被赋予超级用户权限，允许测试代码可以忽略安全限制，绕过那些成本高昂的资源，强制将系统设置到某种可测试的状态中。但是需要注意这个API的安全性。</p><h4 id="本章小结-16"><a href="#本章小结-16" class="headerlink" title="本章小结"></a>本章小结</h4><p>测试时系统的重要组成部分。</p><h3 id="第29章-整洁的嵌入式架构"><a href="#第29章-整洁的嵌入式架构" class="headerlink" title="第29章 整洁的嵌入式架构"></a>第29章 整洁的嵌入式架构</h3><p>虽然软件本身不会随着时间推移而磨损，但是硬件和固件却会随着时间推移而过时，随即也需要对软件做相应的改动。</p><h4 id="程序适用测试"><a href="#程序适用测试" class="headerlink" title="程序适用测试"></a>程序适用测试</h4><h4 id="目标硬件瓶颈"><a href="#目标硬件瓶颈" class="headerlink" title="目标硬件瓶颈"></a>目标硬件瓶颈</h4><p>目标硬件瓶颈时嵌入式开发特有的一个问题，如果没有采用某种清晰的架构来设计嵌入式系统的代码结构，就经常会面临只能在目标平台上测试代码的难题。</p><p>整洁的嵌入式架构就是可测试的嵌入式架构。可以进行分层（底层是硬件层，然后是固件，然后是软件），软件和固件之间的间隔线没有硬件和固件之间的分割线那么清晰。</p><h4 id="本章小结-17"><a href="#本章小结-17" class="headerlink" title="本章小结"></a>本章小结</h4><p>本章介绍的是和嵌入式开发相关的。</p><h2 id="第六部分-实现细节"><a href="#第六部分-实现细节" class="headerlink" title="第六部分 实现细节"></a>第六部分 实现细节</h2><h3 id="第30章-数据库只是实现细节"><a href="#第30章-数据库只是实现细节" class="headerlink" title="第30章 数据库只是实现细节"></a>第30章 数据库只是实现细节</h3><p>这里讨论的不是数据模型，为应用程序中国呢的数据设计结构，对于系统架构来说当然是很重要的，但是数据库并不是数据模型，数据库只是一款软件，用来存取数据的工具，从系统架构的角度来看，工具通常是无关紧要的</p><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><h4 id="为什么数据库系统如此流行"><a href="#为什么数据库系统如此流行" class="headerlink" title="为什么数据库系统如此流行"></a>为什么数据库系统如此流行</h4><p>答案是硬盘。带有告诉旋转的盘片，成为数据库读取的主要手段。</p><p>为了应对硬盘访问速度带来的限制，必须使用索引、缓存以及查询优化器等技术。此外还需要一种数据的标准展现格式，一边让索引、缓存以及查询优化器来使用。过去几十年，业界逐渐发展出两种截然不同的系统：文件系统与关系型数据库（RDBMS）。</p><p>文件系统基于文档格式，提供一种便于存储整个文档的方式。当需要按照名字存储数据和查找一系列文档时，文件系统很有用，但是当我们需要检索文档内容时，就没有那么有用了。而数据库系统与文件系统相反，关注的主要是内容 。</p><p>每个系统最终都会将数据缓存在内存中，方便快速操作。</p><h4 id="假设磁盘不存在会怎么样"><a href="#假设磁盘不存在会怎么样" class="headerlink" title="假设磁盘不存在会怎么样"></a>假设磁盘不存在会怎么样</h4><p>考虑如果所有的数据都存在内存中，那么应该如何组织它们呢？我们会将数据存储为链表、树、哈希表、队列等等数据结构。然后用指针或者引用来访问这些数据。</p><p>事实上，我们已经这样做了。即使数据保存在数据库或者文件系统中，我们最终也会将其读取到内存中，并将其组织为各种数据结构。继续按照文件或者表格的形式来操作数据是非常少见的。</p><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><p>上面所说的，就是为什么我们认为数据库只是一种实现细节的原因，因为数据库中酒只是在硬盘和内存之间互相传输数据的一种手段。</p><h4 id="但性能怎么办呢"><a href="#但性能怎么办呢" class="headerlink" title="但性能怎么办呢"></a>但性能怎么办呢</h4><p>我们需要从数据存储中快速读取数据，但是这终究只是一个底层实现问题，让它不要和系统架构相关联，也就是这部分是独立在业务逻辑之外的。</p><h4 id="一段轶事"><a href="#一段轶事" class="headerlink" title="一段轶事"></a>一段轶事</h4><h4 id="本章小结-18"><a href="#本章小结-18" class="headerlink" title="本章小结"></a>本章小结</h4><p>数据的组织结构，数据的模型，都是系统架构的重要部分，但是从磁盘读取&#x2F;存储数据的机制和手段没有那么重要，关系型数据库强制我们将数据存储成表格并且以SQL访问，主要是为了后者。</p><h3 id="第31章-Web是实现细节"><a href="#第31章-Web是实现细节" class="headerlink" title="第31章 Web是实现细节"></a>第31章 Web是实现细节</h3><p>GUI只是一个实现细节，而web则是GUI的一种，所以也是一个实现细节，<strong>软件架构师需要将这类细节和核心业务逻辑隔离开。</strong></p><h3 id="第32章-应用程序框架是实现细节"><a href="#第32章-应用程序框架是实现细节" class="headerlink" title="第32章 应用程序框架是实现细节"></a>第32章 应用程序框架是实现细节</h3><h4 id="框架作者"><a href="#框架作者" class="headerlink" title="框架作者"></a>框架作者</h4><p>大部分框架的作者都愿意免费提供自己的工作成果，是因为它们想要帮助整个社群。</p><h4 id="单向婚姻"><a href="#单向婚姻" class="headerlink" title="单向婚姻"></a>单向婚姻</h4><p>我们与框架作者的关系非常不对等，因为采用框架需要遵守一大堆的约定，但是框架作者却完全不需要为我们遵守上什么约定，这就像一段单向婚姻。</p><h4 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h4><p>我们使用框架需要承担的风险包括：</p><ul><li>框架自身的架构设计很多时候并没有很明确，有时候还可能违反依赖关系原则。</li><li>框架可能会帮助我们实现一些应用程序的早起功能，但是随着我们产品的眼花，会发现我们与框架斗争的时间比框架帮助我们的时间长得多。</li><li>框架本身可能会朝着我们不需要的方向演化，我们可能会被破升级到不需要的就版本，我们赖以生存的框架旧版本或者旧功能突然消失了或者改变了行为。</li><li>未来我们想要升级到一个更好的框架上</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>“请不要嫁给框架！”</p><p>如果框架要求我们根据它们的基类来创建派生类，那么请不要这样做！我们可以创建一些代理类，同时把这些代理类当作业务逻辑的插件来管理。</p><p>另外不要让框架污染核心代码，<strong>应该根据依赖关系的原则，把它们当成核心代码的插件来管理。</strong></p><h4 id="不得不接受的依赖"><a href="#不得不接受的依赖" class="headerlink" title="不得不接受的依赖"></a>不得不接受的依赖</h4><p>比如C++的STL，Java的标准库这些都是不太能避免使用的</p><p>但是这些是主动选择的结果，必须明白如果在项目中引用一个框架，那么之后的整个生命周期都可能依赖它，后来情形的变化都不太能更改这个决定了。</p><h4 id="本章小结-19"><a href="#本章小结-19" class="headerlink" title="本章小结"></a>本章小结</h4><p>我们选择框架时，不能草率的决定。</p><h3 id="第33章-案例分析：视频销售网站"><a href="#第33章-案例分析：视频销售网站" class="headerlink" title="第33章 案例分析：视频销售网站"></a>第33章 案例分析：视频销售网站</h3><h3 id="第34章-拾遗"><a href="#第34章-拾遗" class="headerlink" title="第34章 拾遗"></a>第34章 拾遗</h3><p>本章节以构建一个在线书店为例子</p><h4 id="按层封装"><a href="#按层封装" class="headerlink" title="按层封装"></a>按层封装</h4><p>Web为一层，业务逻辑为一层，持久化是另一层。相同类型的代码在同一层，每一层只能对相邻的下层有依赖。即水平分层</p><h4 id="按功能封装"><a href="#按功能封装" class="headerlink" title="按功能封装"></a>按功能封装</h4><p>这种另一种组织代码的形式，即垂直切分。</p><p>研发人员一般一开始采用按层封装，遇到困难后切换为垂直分层。但是这两种方法都不太好</p><h4 id="端口和适配器"><a href="#端口和适配器" class="headerlink" title="端口和适配器"></a>端口和适配器</h4><p>采用“端口和适配器”，“六边形架构”，”边界、控制器实体“等可以创造出一个业务领域代码与实现具体细节（数据库，框架）隔离的结构，可以区分代码中的内部代码（领域，Domain）和外部代码（基础设施，Infrastructure）</p><p><img src="/../images/image-20240516110946379.png" alt="image-20240516110946379"></p><p>内部区域包含了所有的领域概念，外部区域则包含了和外部交互的部分（这部分不仅仅指用户使用的UI或者命令行终端，而是指如UI，数据库，第三方集成）。这个图上只有外部代码可以依赖内部代码。</p><h4 id="按组件封装"><a href="#按组件封装" class="headerlink" title="按组件封装"></a>按组件封装</h4><h4 id="本章小结-20"><a href="#本章小结-20" class="headerlink" title="本章小结"></a>本章小结</h4><p>不考虑细节，再好的设计也无法长久。</p><h3 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h3>]]></content>
    
    
    <categories>
      
      <category>设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>翻译：一份如何使用raw scoekt的指南</title>
    <link href="/2024/05/13/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8raw%20socket/"/>
    <url>/2024/05/13/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8raw%20socket/</url>
    
    <content type="html"><![CDATA[<p>本文翻译自：<a href="https://www.opensourceforu.com/2015/03/a-guide-to-using-raw-sockets/">https://www.opensourceforu.com/2015/03/a-guide-to-using-raw-sockets/</a></p><p>raw socket即原始套接字，可以用来发送和接收数据包，可以通过常见的TCP&#x2F;IP协议，将数据包发送给指定的用户应用。</p><p>当你对linux内核一无所知，但是依然对网络数据包感兴趣时，可以通过raw socket来了解自己想要的内容。</p><p>raw socket是用来接收数据包的，这意味着链路层接收到的数据包会被直接传递给raw socket。<strong>因为绕过了链路层上的网络层和传输层</strong>，所以raw socket会绕过TCP&#x2F;IP处理程序将数据包直接发送给特定的应用程序。如下图：</p><p><img src="/../images/image-20240511173806622.png" alt="image-20240511173806622"></p><h2 id="raw-socket和其他的socket的对比"><a href="#raw-socket和其他的socket的对比" class="headerlink" title="raw socket和其他的socket的对比"></a>raw socket和其他的socket的对比</h2><p>其他的socket包括了stream socket、data gram socket等等，这些其他的socket接收到来自传输层的数据，这些数据不包含header只包含了payload。因为没有header，所以找不到源IP地址和MAC地址。如果运行在同一台机器或者不同机器的两个程序正在交流，那么这两个程序只是交换数据。</p><p>下图展示了raw socket和其他socket的对比：</p><p><img src="/../images/image-20240511174504392-5420705.png" alt="image-20240511174504392"></p><h2 id="网络数据包和数据包嗅探器（sniffer）"><a href="#网络数据包和数据包嗅探器（sniffer）" class="headerlink" title="网络数据包和数据包嗅探器（sniffer）"></a>网络数据包和数据包嗅探器（sniffer）</h2><p>当一个应用发送数据到网络中时，这个数据会经过不层的处理，这些层按照时间顺序从先到后分别是网络层、传输层、数据链路层。每层都会添加Header。最终处理得到的结果可能为 ：</p><p>下图是一个网络数据包的结构：</p><p><img src="/../images/image-20240511175417969.png" alt="image-20240511175417969"></p><p>默认情况下，机器会接收与本机具有相同目的地址的数据包，这种模式称为非混杂模式。 但如果我们想接收所有数据包，我们必须切换到混杂模式。 我们可以借助 ioctl 进入混杂模式。</p><p>如果想知道数据包的结构，可以使用数据包嗅探器（sniffer），比如wireshark或者tcpdump。</p><h2 id="带有raw-socket的数据包嗅探器"><a href="#带有raw-socket的数据包嗅探器" class="headerlink" title="带有raw socket的数据包嗅探器"></a>带有raw socket的数据包嗅探器</h2><p>这里主要介绍如何开发一个数据包嗅探器。要开发数据包嗅探器，<strong>首先必须打开原始套接字（raw socket）</strong>。 仅允许有效用户 ID 为 0 或具有 CAP_NET_RAW 功能的进程打开原始套接字。 所以，在程序执行过程中，你必须是root用户。</p><h3 id="打开-raw-socket"><a href="#打开-raw-socket" class="headerlink" title="打开 raw socket"></a>打开 raw socket</h3><p>要打开套接字，需要了解套接字系列、套接字类型和协议这三个字段。</p><p>对于raw socket，套接字系列字段为 AF_PACKET，套接字类型为 SOCK_RAW。</p><p>接收所有数据包时，宏为 ETH_P_ALL；接收 IP 数据包时，宏为 ETH_P_IP（协议字段）。？？？？？？？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> sock_r;<br>sock_r=socket(AF_PACKET,SOCK_RAW,htons(ETH_P_ALL));<br><span class="hljs-keyword">if</span>(sock_r&lt;<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(error in socket\n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网络数据包的接收"><a href="#网络数据包的接收" class="headerlink" title="网络数据包的接收"></a>网络数据包的接收</h3><p>成功打开原始套接字后，就可以接收网络数据包了，为此需要使用recvfrom api或者使用recv api。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buffer = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">65536</span>); <span class="hljs-comment">//to receive data</span><br><span class="hljs-built_in">memset</span>(buffer,<span class="hljs-number">0</span>,<span class="hljs-number">65536</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">saddr</span>;</span><br><span class="hljs-type">int</span> saddr_len = <span class="hljs-keyword">sizeof</span> (saddr);<br> <br><span class="hljs-comment">//Receive a network packet and copy in to buffer</span><br>buflen=recvfrom(sock_r,buffer,<span class="hljs-number">65536</span>,<span class="hljs-number">0</span>,&amp;saddr,(<span class="hljs-type">socklen_t</span> *)&amp;saddr_len);<br><span class="hljs-keyword">if</span>(buflen&lt;<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(error in reading recvfrom function\n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在saddr中，底层协议提供数据包的源地址。</p><h3 id="提取各层数据"><a href="#提取各层数据" class="headerlink" title="提取各层数据"></a>提取各层数据</h3><h4 id="提取以太网（Ethernet）Header"><a href="#提取以太网（Ethernet）Header" class="headerlink" title="提取以太网（Ethernet）Header"></a>提取以太网（Ethernet）Header</h4><p>以太网的标头包含了源地址和目的地址（源地址和目的地址都是物理地址，占用了6个字节）和协议。以太网的Header在源代码的if_ether.h文件被定义成如下数据结构：</p><p><img src="/../images/image-20240513135305485.png" alt="image-20240513135305485"></p><p>h_proto表示下一层是什么协议。比如如果h_proto的值是ETH_P_IP，那么表示下一个Header是IP协议的Header。下面类似的，介绍如何提取IP Header。</p><h4 id="提取IP层的-Header"><a href="#提取IP层的-Header" class="headerlink" title="提取IP层的 Header"></a>提取IP层的 Header</h4><p>IP 层提供各种信息，如源和目标 IP 地址、传输层协议等。IP Header的信息在<em>ip.h</em>被定义了，如下：</p><p><img src="/../images/image-20240513140223611.png" alt="image-20240513140223611"></p><p>类似的，提取传输层的协议的Header</p><h4 id="提取传输层的Header"><a href="#提取传输层的Header" class="headerlink" title="提取传输层的Header"></a>提取传输层的Header</h4><p>TCP和UDP协议结构分别在tcp.h和udp.h中定义。 这些结构提供源和目标的端口号。</p><blockquote><p>TLS 协议在 OSI 模型中被认为是一个位于传输层和应用层之间的安全层协议。</p></blockquote><h4 id="提取应用层的Payload"><a href="#提取应用层的Payload" class="headerlink" title="提取应用层的Payload"></a>提取应用层的Payload</h4><p>在传输层Header之后的数据就是有效负载。</p><h3 id="使用raw-socket发送数据包"><a href="#使用raw-socket发送数据包" class="headerlink" title="使用raw socket发送数据包"></a>使用raw socket发送数据包</h3><p>要发送数据包，需要知道源MAC地址和目的MAC地址，以及源IP地址和目的IP地址。发送时如何知晓发送人的IP地址和MAC地址呢？下面是方法：</p><p>输入<code>ifconfig</code>来获得某个指定网络接口的IP地址和MAC地址。或者输入ioctl命令获取IP地址和MAC地址（这个方法更快速更推荐）。</p><h4 id="打开raw-socket"><a href="#打开raw-socket" class="headerlink" title="打开raw socket"></a>打开raw socket</h4><p>要打开raw socket，需要知道socekt API的三个参数，分别为：</p><p>Family参数，可以传递AF_PACKET</p><p>Type参数，可以传递SOCK_RAW</p><p>协议protocol参数，可以传递IPPROTO_RAW</p><p>协议protocol参数为什么要传递IPPROTO_RAW呢？因为想传递一个IP包。IPPROTO_RAW宏定义在in.h文件中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">sock_raw=socket(AF_PACKET,SOCK_RAW,IPPROTO_RAW);<br><span class="hljs-keyword">if</span>(sock_raw == <span class="hljs-number">-1</span>)<br><span class="hljs-built_in">printf</span>(error in socket);<br></code></pre></td></tr></table></figure><h4 id="什么是ifreq-struct？"><a href="#什么是ifreq-struct？" class="headerlink" title="什么是ifreq struct？"></a>什么是ifreq struct？</h4><p>Linux 支持一些标准 ioctl 来配置网络设备。</p><p><img src="/../images/image-20240513144921115.png" alt="image-20240513144921115"></p><p><img src="/../images/image-20240513145255271.png" alt="image-20240513145255271"></p><h4 id="获取发送数据包的网络接口的下标"><a href="#获取发送数据包的网络接口的下标" class="headerlink" title="获取发送数据包的网络接口的下标"></a>获取发送数据包的网络接口的下标</h4><p>您的机器上可能有多种接口，如环回、有线接口和无线接口。 因此，您必须决定我们可以通过哪个接口发送数据包。 确定接口后，您必须获取该接口的索引。 为此，首先通过设置 ifreq 结构的 ifr_name 字段来给出接口的名称，然后使用 ioctl。 然后使用 sockios.h 中定义的 SIOCGIFINDEX 宏，您将在 ifreq 结构中收到索引号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ifreq</span> <span class="hljs-title">ifreq_i</span>;</span><br><span class="hljs-built_in">memset</span>(&amp;ifreq_i,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(ifreq_i));<br><span class="hljs-built_in">strncpy</span>(ifreq_i.ifr_name,wlan0,IFNAMSIZ<span class="hljs-number">-1</span>); <span class="hljs-comment">//giving name of Interface</span><br> <br><span class="hljs-keyword">if</span>((ioctl(sock_raw,SIOCGIFINDEX,&amp;ifreq_i))&lt;<span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(error in index ioctl reading);<span class="hljs-comment">//getting Index Name</span><br> <br><span class="hljs-built_in">printf</span>(index=%d\n,ifreq_i.ifr_ifindex);<br></code></pre></td></tr></table></figure><h4 id="获取网络接口的MAC地址"><a href="#获取网络接口的MAC地址" class="headerlink" title="获取网络接口的MAC地址"></a>获取网络接口的MAC地址</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ifreq</span> <span class="hljs-title">ifreq_c</span>;</span><br><span class="hljs-built_in">memset</span>(&amp;ifreq_c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(ifreq_c));<br><span class="hljs-built_in">strncpy</span>(ifreq_c.ifr_name,wlan0,IFNAMSIZ<span class="hljs-number">-1</span>);<span class="hljs-comment">//giving name of Interface</span><br> <br><span class="hljs-keyword">if</span>((ioctl(sock_raw,SIOCGIFHWADDR,&amp;ifreq_c))&lt;<span class="hljs-number">0</span>) <span class="hljs-comment">//getting MAC Address</span><br><span class="hljs-built_in">printf</span>(error in SIOCGIFHWADDR ioctl reading);<br></code></pre></td></tr></table></figure><h4 id="获取网络接口的IP地址"><a href="#获取网络接口的IP地址" class="headerlink" title="获取网络接口的IP地址"></a>获取网络接口的IP地址</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">struct</span> ifreq ifreq_ip;<br>memset(&amp;ifreq_ip,<span class="hljs-number">0</span>,sizeof(ifreq_ip));<br>strncpy(ifreq_ip.ifr_name,wlan0,IFNAMSIZ<span class="hljs-number">-1</span>);<span class="hljs-comment">//giving name of Interface</span><br><span class="hljs-keyword">if</span>(ioctl(sock_raw,SIOCGIFADDR,&amp;ifreq_ip)&lt;<span class="hljs-number">0</span>) <span class="hljs-comment">//getting IP Address</span><br>&#123;<br>printf(<span class="hljs-type">error</span> in SIOCGIFADDR \n);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构建以太网报头"><a href="#构建以太网报头" class="headerlink" title="构建以太网报头"></a>构建以太网报头</h4><p>获得索引以及接口的 MAC 和 IP 地址后，就可以构建以太网标头了。 首先，创建一个缓冲区，在其中放置所有信息，如以太网标头、IP 标头、UDP 标头和数据。 该缓冲区将是您的数据包。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">sendbuff=(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">64</span>); <span class="hljs-comment">// increase in case of more data</span><br><span class="hljs-built_in">memset</span>(sendbuff,<span class="hljs-number">0</span>,<span class="hljs-number">64</span>);<br></code></pre></td></tr></table></figure><p>要构造以太网标头，请填写 ethhdr 结构的所有字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ethhdr</span> *<span class="hljs-title">eth</span> =</span> (<span class="hljs-keyword">struct</span> ethhdr *)(sendbuff);<br> <br>eth-&gt;h_source[<span class="hljs-number">0</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(ifreq_c.ifr_hwaddr.sa_data[<span class="hljs-number">0</span>]);<br>eth-&gt;h_source[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(ifreq_c.ifr_hwaddr.sa_data[<span class="hljs-number">1</span>]);<br>eth-&gt;h_source[<span class="hljs-number">2</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(ifreq_c.ifr_hwaddr.sa_data[<span class="hljs-number">2</span>]);<br>eth-&gt;h_source[<span class="hljs-number">3</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(ifreq_c.ifr_hwaddr.sa_data[<span class="hljs-number">3</span>]);<br>eth-&gt;h_source[<span class="hljs-number">4</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(ifreq_c.ifr_hwaddr.sa_data[<span class="hljs-number">4</span>]);<br>eth-&gt;h_source[<span class="hljs-number">5</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(ifreq_c.ifr_hwaddr.sa_data[<span class="hljs-number">5</span>]);<br> <br><span class="hljs-comment">/* filling destination mac. DESTMAC0 to DESTMAC5 are macro having octets of mac address. */</span><br>eth-&gt;h_dest[<span class="hljs-number">0</span>] = DESTMAC0;<br>eth-&gt;h_dest[<span class="hljs-number">1</span>] = DESTMAC1;<br>eth-&gt;h_dest[<span class="hljs-number">2</span>] = DESTMAC2;<br>eth-&gt;h_dest[<span class="hljs-number">3</span>] = DESTMAC3;<br>eth-&gt;h_dest[<span class="hljs-number">4</span>] = DESTMAC4;<br>eth-&gt;h_dest[<span class="hljs-number">5</span>] = DESTMAC5;<br> <br>eth-&gt;h_proto = htons(ETH_P_IP); <span class="hljs-comment">//means next header will be IP header</span><br> <br><span class="hljs-comment">/* end of ethernet header */</span><br>total_len+=<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ethhdr);<br></code></pre></td></tr></table></figure><h4 id="构建IP-Header"><a href="#构建IP-Header" class="headerlink" title="构建IP Header"></a>构建IP Header</h4><p>要构造 IP 标头，请将 sendbuff 增加以太网标头的大小并填充 iphdr 结构的每个字段。 IP报头之后的数据称为IP报头的有效负载，同样，以太网报头之后的数据称为以太网报头的有效负载。 在IP报头中，有一个称为总长度的字段，它包含IP报头加上有效负载的大小。 要了解 IP 标头有效负载的大小，您必须知道 UDP 标头和 UDP 有效负载的大小。 因此，iphdr 结构的某些字段将在填充 UDP 标头字段后获取值。</p><blockquote><p>代码这里就不贴出来了，因为代码我没怎么看，主要看的就是大概的步骤。</p></blockquote><h4 id="构建UDP-Header"><a href="#构建UDP-Header" class="headerlink" title="构建UDP Header"></a>构建UDP Header</h4><p>构建 UDP 标头与构建 IP 标头非常相似。 为 udphdr 结构的字段赋值。 为此，将 sendbuff 指针增加以太网和 IP 标头的大小。</p><h4 id="添加数据或者UDP-Payload"><a href="#添加数据或者UDP-Payload" class="headerlink" title="添加数据或者UDP Payload"></a>添加数据或者UDP Payload</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">sendbuff[total_len++] = <span class="hljs-number">0xAA</span>;<br>sendbuff[total_len++] = <span class="hljs-number">0xBB</span>;<br>sendbuff[total_len++] = <span class="hljs-number">0xCC</span>;<br>sendbuff[total_len++] = <span class="hljs-number">0xDD</span>;<br>sendbuff[total_len++] = <span class="hljs-number">0xEE</span>;<br></code></pre></td></tr></table></figure><h4 id="填充-IP-和-UDP-标头的剩余字段"><a href="#填充-IP-和-UDP-标头的剩余字段" class="headerlink" title="填充 IP 和 UDP 标头的剩余字段"></a>填充 IP 和 UDP 标头的剩余字段</h4><p>现在我们有了total_len指针，借助它，我们可以填充IP和UDP标头的剩余字段</p><h4 id="IP-Header-校验和"><a href="#IP-Header-校验和" class="headerlink" title="IP Header 校验和"></a>IP Header 校验和</h4><p>IP 标头检查中还剩下一个字段，用于校验和。 校验和用于头部的错误检查。</p><p>当数据包到达路由器时，路由器会计算校验和，如果计算出的校验和与标头的校验和字段不匹配，则路由器将丢弃该数据包； 如果匹配，则路由器会将到达 live 字段的时间减 1，然后转发。</p><p>计算校验和时，将IP头的所有16位字相加，如果有进位，则再次相加得到16位字。 之后，找到 1 的补码，这就是我们的校验和。 要检查我们的校验和是否正确，请使用上述算法。</p><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><p>现在我们有了数据包，但在发送之前，让我们用目标 MAC 地址填充 sockaddr_ll 结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_ll</span> <span class="hljs-title">sadr_ll</span>;</span><br>sadr_ll.sll_ifindex = ifreq_i.ifr_ifindex; <span class="hljs-comment">// index of interface</span><br>sadr_ll.sll_halen = ETH_ALEN; <span class="hljs-comment">// length of destination mac address</span><br>sadr_ll.sll_addr[<span class="hljs-number">0</span>] = DESTMAC0;<br>sadr_ll.sll_addr[<span class="hljs-number">1</span>] = DESTMAC1;<br>sadr_ll.sll_addr[<span class="hljs-number">2</span>] = DESTMAC2;<br>sadr_ll.sll_addr[<span class="hljs-number">3</span>] = DESTMAC3;<br>sadr_ll.sll_addr[<span class="hljs-number">4</span>] = DESTMAC4;<br>sadr_ll.sll_addr[<span class="hljs-number">5</span>] = DESTMAC5;<br></code></pre></td></tr></table></figure><p>现在是时候发送它了，为此我们使用 sendto api：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">send_len = sendto(sock_raw,sendbuff,<span class="hljs-number">64</span>,<span class="hljs-number">0</span>,(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr*)&amp;sadr_ll,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_ll));<br><span class="hljs-keyword">if</span>(send_len&lt;<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(error in sending....sendlen=%d....errno=%d\n,send_len,errno);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>翻译</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gopacket源代码部分阅读</title>
    <link href="/2024/04/26/gopacket%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2024/04/26/gopacket%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>gopacket是用Golang开发的、Google出品的一个<code>PF_RING</code>和<code>AF_PACKET</code>和基于C语言的libpcap的网络数据包抓取和分析包。</p><blockquote><p>不同的选项会使用不同的底层，比如大部分时候是基于libpcap的，有时候是基于PF_RING的，有时候是基于AF_PACKET的。具体是基于什么的主要取决于代码是怎么写的。</p><p>PF_RING和AF_PACKET都是网络套接字，</p></blockquote><blockquote><p>libpcap是C语言写的一个库，但是libpcap并不像前两者一样是套接字（socket）API的一部分。在linux系统或者IRIX系统，libpcap是基于套接字API实现的，比如Linux系统上是基于PF_PACKET套接字实现的。在<code>*BSD</code>, OS X, AIX, 和Solaris 11和之后的系统，是基于 BPF套接字实现的。在Solaris的早期版本和HP-UX系统，是基于STREAMS+DLPI。但是在<code>UN*Xes</code>系统中，因为系统没有提供用于包捕获的套接字，所以libpcap是通过其他机制实现的。</p><p>在windows上 Winpcap做的事情和libpcap一样。</p><p>原始socket是操作系统提供的API，可以由调用者自定义包的header，比如包的TCP header和IP header等等，然后发送包。</p></blockquote><p>通常最经常使用的是gopacket基于libpcap的抓包功能。下面也基于此介绍。因为是基于libpcap，故gopacket使用到了C代码，编译时需要开启CGO。libpcap是一个网络数据包捕获框架，应用极其广泛，tcpdump、wireshark都是基于libpcap的。</p><p>因为在使用gopacket的过程中对其在libpcap的基础上做了哪些额外的功能和功能的实现比较好奇，故阅读了gopacket的源代码。其实也没有把源代码完全读完，只读了我自己比较感兴趣的部分，日后有时间可能会把其他部分都读完，读完了继续补充到本文。</p><p>我阅读的部分主要是数据包抓取部分，数据包解码部分。还有一些这两部分之外的包，不过阅读得比较浅显没怎么看懂。下面介绍我读取的部分的内容。</p><h2 id="数据包抓取"><a href="#数据包抓取" class="headerlink" title="数据包抓取"></a>数据包抓取</h2><p>调用gopacket的代码一般类似如下的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  device := <span class="hljs-string">&quot;en0&quot;</span><br>handle, err := pcap.OpenLive(device, snaplen, promiscuous, <span class="hljs-number">-1</span>*time.Second)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> handle.Close()<br>packetSource := gopacket.NewPacketSource(handle, handle.LinkType())<br><span class="hljs-keyword">for</span> packet := <span class="hljs-keyword">range</span> packetSource.Packets() &#123;<br>    <span class="hljs-comment">// do something</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到每个数据包是通过packetSource.Packets()函数获取的，查看该函数及该函数调用的其他函数的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *PacketSource)</span></span> Packets() <span class="hljs-keyword">chan</span> Packet &#123;<br><span class="hljs-keyword">if</span> p.c == <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// channel 的大小在gopacket代码里被写死了，是固定的1000</span><br>p.c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Packet, <span class="hljs-number">1000</span>)<br><span class="hljs-keyword">go</span> p.packetsToChannel()<br>&#125;<br><span class="hljs-keyword">return</span> p.c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *PacketSource)</span></span> packetsToChannel() &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(p.c)<br><span class="hljs-keyword">for</span> &#123;<br>packet, err := p.NextPacket()<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>p.c &lt;- packet<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// Immediately retry for temporary network errors</span><br><span class="hljs-keyword">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// Immediately retry for EAGAIN</span><br><span class="hljs-keyword">if</span> err == syscall.EAGAIN &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// Immediately break for known unrecoverable errors</span><br><span class="hljs-keyword">if</span> err == io.EOF || err == io.ErrUnexpectedEOF ||<br>err == io.ErrNoProgress || err == io.ErrClosedPipe || err == io.ErrShortBuffer ||<br>err == syscall.EBADF ||<br>strings.Contains(err.Error(), <span class="hljs-string">&quot;use of closed file&quot;</span>) &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><br><span class="hljs-comment">// Sleep briefly and try again</span><br>time.Sleep(time.Millisecond * time.Duration(<span class="hljs-number">5</span>))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *PacketSource)</span></span> NextPacket() (Packet, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// ReadPacketData 返回从 pcap 句柄读取的下一个数据包，</span><br><span class="hljs-comment">// 以及与该数据包关联的错误代码。 如果数据包读取成功，则返回错误为零。</span><br>data, ci, err := p.source.ReadPacketData()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// p.DecodeOptions 是在这个地方使用的</span><br>  <span class="hljs-comment">// NewPacket 里进行的主要是数据包的解码操作，除了在Decode选项的Lazy值为true时不会做解码操作</span><br>packet := NewPacket(data, p.decoder, p.DecodeOptions)<br>m := packet.Metadata()<br>m.CaptureInfo = ci<br><span class="hljs-comment">// 如果捕获的长度小于实际传输的长度，那么表示被截断了，是不是gopacket的 snapshot_len 参数会对是否被截断有影响</span><br>m.Truncated = m.Truncated || ci.CaptureLength &lt; ci.Length<br><span class="hljs-keyword">return</span> packet, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里比较重要的部分就是p.source.ReadPacketData()的实现，跳转过去后发现其定义是一个interface</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PacketDataSource <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// ReadPacketData returns the next packet available from this data source.</span><br><span class="hljs-comment">// It returns:</span><br><span class="hljs-comment">//  data:  The bytes of an individual packet.</span><br><span class="hljs-comment">//  ci:  Metadata about the capture</span><br><span class="hljs-comment">//  err:  An error encountered while reading packet data.  If err != nil,</span><br><span class="hljs-comment">//    then data/ci will be ignored.</span><br>ReadPacketData() (data []<span class="hljs-type">byte</span>, ci CaptureInfo, err <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>那么对于最开始的示例代码，代码执行时是如何实现这个interface的呢？那么需要定位到p.source的具体的值是什么。首先往上一行，查看<code>packetSource := gopacket.NewPacketSource(handle, handle.LinkType())</code>的NewPacketSource函数的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPacketSource</span><span class="hljs-params">(source PacketDataSource, decoder Decoder)</span></span> *PacketSource &#123;<br><span class="hljs-keyword">return</span> &amp;PacketSource&#123;<br>source:  source,<br>decoder: decoder,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数很简单，无法定位到p.source的值具体是什么。</p><p>再查看上一行代码<code>handle, err := pcap.OpenLive(device, snaplen, promiscuous, -1*time.Second)</code>的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">OpenLive</span><span class="hljs-params">(device <span class="hljs-type">string</span>, snaplen <span class="hljs-type">int32</span>, promisc <span class="hljs-type">bool</span>, timeout time.Duration)</span></span> (handle *Handle, _ <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> pro <span class="hljs-type">int</span><br><span class="hljs-keyword">if</span> promisc &#123;<br>pro = <span class="hljs-number">1</span><br>&#125;<br><br>p, err := pcapOpenLive(device, <span class="hljs-type">int</span>(snaplen), pro, timeoutMillis(timeout))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>p.timeout = timeout<br>p.device = device<br><br>ifc, err := net.InterfaceByName(device)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// The device wasn&#x27;t found in the OS, but could be &quot;any&quot;</span><br><span class="hljs-comment">// Set index to 0</span><br>p.deviceIndex = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>p.deviceIndex = ifc.Index<br>&#125;<br><br>p.nanoSecsFactor = <span class="hljs-number">1000</span> <span class="hljs-comment">// 直接翻译为纳秒因子</span><br><br><span class="hljs-comment">// Only set the PCAP handle into non-blocking mode if we have a timeout</span><br><span class="hljs-comment">// greater than zero. If the user wants to block forever, we&#x27;ll let libpcap</span><br><span class="hljs-comment">// handle that.</span><br><span class="hljs-comment">// 仅当超时大于零时，才将 PCAP 句柄设置为非阻塞模式。 如果用户想要永远阻塞，我们会让 libpcap 来处理。</span><br><span class="hljs-keyword">if</span> p.timeout &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> err := p.setNonBlocking(); err != <span class="hljs-literal">nil</span> &#123;<br>p.pcapClose()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> p, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pcapOpenLive</span><span class="hljs-params">(device <span class="hljs-type">string</span>, snaplen <span class="hljs-type">int</span>, pro <span class="hljs-type">int</span>, timeout <span class="hljs-type">int</span>)</span></span> (*Handle, <span class="hljs-type">error</span>) &#123;<br>buf := (*C.char)(C.calloc(errorBufferSize, <span class="hljs-number">1</span>)) <span class="hljs-comment">// C.calloc 分配内存</span><br><span class="hljs-keyword">defer</span> C.free(unsafe.Pointer(buf))              <span class="hljs-comment">// C.free 释放内存</span><br><br>dev := C.CString(device)<br><span class="hljs-comment">// 释放变量 dev 的内存</span><br><span class="hljs-keyword">defer</span> C.free(unsafe.Pointer(dev))<br><br>cptr := C.pcap_open_live(dev, C.<span class="hljs-type">int</span>(snaplen), C.<span class="hljs-type">int</span>(pro), C.<span class="hljs-type">int</span>(timeout), buf)<br><span class="hljs-comment">// cptr 是一个指针</span><br><span class="hljs-comment">// 将这个指针存储在 cptr 变量中意味着你可以通过 cptr 来访问被打开的实时捕获会话的相关信息和函数。</span><br><span class="hljs-comment">// 这种方式允许你在 Go 代码中使用 C 代码中定义的结构和函数，这在需要与 C 语言库进行交互的情况下非常有用。</span><br><span class="hljs-comment">// 在后续读取数据包时，通常不会涉及到复制操作，因为 cptr 是指向 pcap_t 结构的指针，而不是结构本身。</span><br><span class="hljs-keyword">if</span> cptr == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(C.GoString(buf))<br>&#125;<br><span class="hljs-keyword">return</span> &amp;Handle&#123;cptr: cptr&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，在打开网卡的时候就已经调用了很多的C的代码。最终返回的是Handle struct类型的值。所以示例代码中的，上面需要定位的实现了PacketDataSource interface必然是Handle struct，查看其实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如果包已经被成功读取了，那么错误为空</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Handle)</span></span> ReadPacketData() (data []<span class="hljs-type">byte</span>, ci gopacket.CaptureInfo, err <span class="hljs-type">error</span>) &#123;<br>p.mu.Lock()<br>err = p.getNextBufPtrLocked(&amp;ci)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>data = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, ci.CaptureLength)<br><span class="hljs-comment">// 使用 unsafe.Pointer 将 p.bufptr 的指针转换为 unsafe.Pointer 类型的指针，</span><br><span class="hljs-comment">// 然后再将其转换为指向一个长度为 2^30 (即 1GB) 字节的数组的指针 (*[1 &lt;&lt; 30]byte)。</span><br><span class="hljs-comment">// 接着，使用切片操作 [:]，将整个数组转换为切片</span><br><br><span class="hljs-comment">// 这一行代码的作用是将 p.bufptr 指向的内存数据复制到 data 切片中，以便后续对数据进行处理和分析。</span><br><span class="hljs-comment">// 最终，data 切片中将包含 p.bufptr 指向的内容</span><br><span class="hljs-comment">// 原来是直接读取内存的指针，复制的数据包的内容</span><br><span class="hljs-built_in">copy</span>(data, (*(*[<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>]<span class="hljs-type">byte</span>)(unsafe.Pointer(p.bufptr)))[:])<br>&#125;<br>p.mu.Unlock()<br><span class="hljs-keyword">if</span> err == NextErrorTimeoutExpired &#123;<br><span class="hljs-comment">// runtime.Gosched() 的作用是手动触发 Go 调度器的一次调度</span><br><span class="hljs-comment">// 调用 runtime.Gosched() 时，它会主动让出 CPU，让其他就绪状态的 goroutine 有机会执行。</span><br><span class="hljs-comment">// 当读取数据包时发生了超时，即等待数据包超时时，当前的 goroutine 会调用 runtime.Gosched() 主动让出 CPU。</span><br><br><span class="hljs-comment">// 数据包超时是指在一定时间内没有从网络接口中成功读取到数据包</span><br><span class="hljs-comment">// 在一定时间内没有成功读取到数据包即视为超时。例如，设置超时时间为 1 秒，表示如果在 1 秒内没有读取到数据包，就认为发生了超时。</span><br>runtime.Gosched()<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Handle)</span></span> getNextBufPtrLocked(ci *gopacket.CaptureInfo) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> !p.isOpen() &#123;<br><span class="hljs-keyword">return</span> io.EOF<br>&#125;<br><br><span class="hljs-comment">// set after we have call waitForPacket for the first time</span><br><span class="hljs-keyword">var</span> waited <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// stop 为 0 表示没有停止，使用原子读取</span><br><span class="hljs-comment">// 只要 stop 为 0 的时候就循环执行</span><br><span class="hljs-keyword">for</span> atomic.LoadUint64(&amp;p.stop) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// try to read a packet if one is immediately available</span><br><span class="hljs-comment">// pcapNextPacketEx 尝试从底层的 libpcap 读取数据包</span><br>result := p.pcapNextPacketEx()<br><br><span class="hljs-keyword">switch</span> result &#123;<br><span class="hljs-keyword">case</span> NextErrorOk:<br><span class="hljs-comment">// 获取数据包的时间戳中的秒数部分，并将其赋值给 sec 变量。</span><br>sec := p.pkthdr.getSec()<br><span class="hljs-comment">// p.pkthdr.getUsec() 方法获取数据包的时间戳中的微秒数部分</span><br><span class="hljs-comment">// convert micros to nanos</span><br><span class="hljs-comment">// 将毫秒转换为纳秒</span><br>nanos := <span class="hljs-type">int64</span>(p.pkthdr.getUsec()) * p.nanoSecsFactor<br><br><span class="hljs-comment">// 使用 time.Unix 方法将秒数部分和纳秒数部分组合成一个时间戳</span><br>ci.Timestamp = time.Unix(sec, nanos)<br><span class="hljs-comment">// p.pkthdr.getCaplen() 方法获取数据包的捕获长度（即实际捕获到的数据包长度）</span><br>ci.CaptureLength = p.pkthdr.getCaplen()<br><span class="hljs-comment">// 调用 p.pkthdr.getLen() 方法获取数据包的长度（即数据包的原始长度）</span><br><br><span class="hljs-comment">// 捕获长度和原始长度的区别在于捕获长度是实际被网络接口捕获到的数据包的长度，</span><br><span class="hljs-comment">// 可能会小于或等于数据包的原始长度，而原始长度是数据包在网络上传输时的完整长度。</span><br>ci.Length = p.pkthdr.getLen()<br>ci.InterfaceIndex = p.deviceIndex<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> NextErrorNoMorePackets:<br><span class="hljs-comment">// 没有更多的数据包可读了</span><br><span class="hljs-comment">// no more packets, return EOF rather than libpcap-specific error</span><br><span class="hljs-keyword">return</span> io.EOF<br><span class="hljs-keyword">case</span> NextErrorTimeoutExpired:<br><span class="hljs-comment">// we&#x27;ve already waited for a packet and we&#x27;re supposed to time out</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// we should never actually hit this if we were passed BlockForever</span><br><span class="hljs-comment">// since we should block on C.pcap_next_ex until there&#x27;s a packet</span><br><span class="hljs-comment">// to read.</span><br><span class="hljs-keyword">if</span> waited &amp;&amp; p.timeout &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-comment">// wait for packet before trying again</span><br>p.waitForPacket()<br>waited = <span class="hljs-literal">true</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> result<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// stop must be set</span><br><span class="hljs-keyword">return</span> io.EOF<br>&#125;<br><br><br><span class="hljs-comment">// 其他补充：golang 一般会在栈上分配内存，因为栈上内存的分配和回收更快</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Handle)</span></span> pcapNextPacketEx() NextError &#123;<br><span class="hljs-comment">// This horrible magic allows us to pass a ptr-to-ptr to pcap_next_ex</span><br><span class="hljs-comment">// without causing that ptr-to-ptr to itself be allocated on the heap.</span><br><span class="hljs-comment">// Since Handle itself survives through the duration of the pcap_next_ex</span><br><span class="hljs-comment">// call, this should be perfectly safe for GC stuff, etc.</span><br><span class="hljs-comment">// 强制类型转换</span><br><span class="hljs-comment">// pcap_next_ex 是 libpcap 的从网络接口中读取下一个数据包的函数</span><br><span class="hljs-comment">// 由于 pcap_next_ex 函数的参数需要传递指向指针的指针，</span><br><span class="hljs-comment">// 为了避免在堆上分配内存，这段代码使用了一种技巧来传递指针的地址而不会分配额外的内存。</span><br><span class="hljs-keyword">return</span> NextError(C.pcap_next_ex_escaping(<br><span class="hljs-comment">// p.cptr 是 Handle 结构中的一个指向 pcap_t 结构的指针</span><br>p.cptr,<br><span class="hljs-comment">// 使用unsafe.Pointer 先转换为 unsafe.Pointer 类型，</span><br><span class="hljs-comment">// 然后使用 uintptr 将这些指针转换为整数。</span><br><span class="hljs-comment">// C.uintptr_t 将整数转换为 C 语言中的 uintptr_t 类型。</span><br><br><span class="hljs-comment">// 通常情况下，pcap_next_ex 函数会修改传入参数所指向的内存，</span><br><span class="hljs-comment">// 以填充数据包的信息。因此，p.pkthdr 和 p.bufptr 可能会被修改为新的值，</span><br><span class="hljs-comment">// 以包含从网络接口中读取到的数据包的信息。</span><br>C.uintptr_t(<span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;p.pkthdr))),<br>C.uintptr_t(<span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;p.bufptr)))))<br>&#125;<br></code></pre></td></tr></table></figure><p>一路照下来，最核心的就是pcapNextPacketEx函数，这个函数的功能就是读取下一个数据包，但是本质上还是调用C的函数。</p><p><strong>所以gopacket的数据包抓取是通过对C的代码的调用实现的，且实现过程中使用了指针没有涉及到内存分配，已经是比较优秀的处理方法了。</strong></p><h2 id="数据包解码"><a href="#数据包解码" class="headerlink" title="数据包解码"></a>数据包解码</h2><p>如果把“数据包抓取”部分读完，就会知道数据包解码部分是在下面源代码里的NewPacket函数中做的（除了Lazy为true时）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *PacketSource)</span></span> NextPacket() (Packet, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// ReadPacketData 返回从 pcap 句柄读取的下一个数据包，</span><br><span class="hljs-comment">// 以及与该数据包关联的错误代码。 如果数据包读取成功，则返回错误为零。</span><br>data, ci, err := p.source.ReadPacketData()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// p.DecodeOptions 是在这个地方使用的</span><br>  <span class="hljs-comment">// NewPacket 里进行的主要是数据包的解码操作，除了在Decode选项的Lazy值为true时不会做解码操作</span><br>packet := NewPacket(data, p.decoder, p.DecodeOptions)<br>m := packet.Metadata()<br>m.CaptureInfo = ci<br><span class="hljs-comment">// 如果捕获的长度小于实际传输的长度，那么表示被截断了，是不是gopacket的 snapshot_len 参数会对是否被截断有影响</span><br>m.Truncated = m.Truncated || ci.CaptureLength &lt; ci.Length<br><span class="hljs-keyword">return</span> packet, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面介绍NewPacket的实现，和gopacket解码的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPacket</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>, firstLayerDecoder Decoder, options DecodeOptions)</span></span> Packet &#123;<br><span class="hljs-comment">// NoCopy 表示是否直接操作数据包的原始数据，操作原始数据可能会影响原始包</span><br><span class="hljs-keyword">if</span> !options.NoCopy &#123;<br>dataCopy := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(data))<br><span class="hljs-built_in">copy</span>(dataCopy, data)<br>data = dataCopy<br>&#125;<br><span class="hljs-keyword">if</span> options.Lazy &#123;<br>p := &amp;lazyPacket&#123;<br>packet: packet&#123;data: data, decodeOptions: options&#125;,<br>next:   firstLayerDecoder,<br>&#125;<br>p.layers = p.initialLayers[:<span class="hljs-number">0</span>]<br><span class="hljs-comment">// Crazy craziness:</span><br><span class="hljs-comment">// If the following return statemet is REMOVED, and Lazy is FALSE, then</span><br><span class="hljs-comment">// eager packet processing becomes 17% FASTER.  No, there is no logical</span><br><span class="hljs-comment">// explanation for this.  However, it&#x27;s such a hacky micro-optimization that</span><br><span class="hljs-comment">// we really can&#x27;t rely on it.  It appears to have to do with the size the</span><br><span class="hljs-comment">// compiler guesses for this function&#x27;s stack space, since one symptom is</span><br><span class="hljs-comment">// that with the return statement in place, we more than double calls to</span><br><span class="hljs-comment">// runtime.morestack/runtime.lessstack.  We&#x27;ll hope the compiler gets better</span><br><span class="hljs-comment">// over time and we get this optimization for free.  Until then, we&#x27;ll have</span><br><span class="hljs-comment">// to live with slower packet processing.</span><br><span class="hljs-comment">// 设置为 lazy 则直接返回</span><br><span class="hljs-keyword">return</span> p<br>&#125;<br>p := &amp;eagerPacket&#123;<br>packet: packet&#123;data: data, decodeOptions: options&#125;,<br>&#125;<br><span class="hljs-comment">// layers 置为空</span><br>p.layers = p.initialLayers[:<span class="hljs-number">0</span>]<br>p.initialDecode(firstLayerDecoder)<br><span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure><p>返回值Packet时一个interface，eagerPacket struct和lazyPacket struct都实现了该interface。这里只介绍Lazy为false的情况，Lazy为true时gopacket的处理比较巧妙，下文会在“解码数据包时的一些选项的作用”详细介绍Lazy为true的情况。</p><p>Lazy为false时，会执行到p.initialDecode(firstLayerDecoder)，这也是最关键的调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *eagerPacket)</span></span> initialDecode(dec Decoder) &#123;<br><span class="hljs-keyword">defer</span> p.recoverDecodeError()<br><span class="hljs-comment">// p 即 eagerPacket 实现了 gopacket.PacketBuilder interface</span><br>err := dec.Decode(p.data, p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>p.addFinalDecodeError(err, <span class="hljs-literal">nil</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Decode跳转过去是一个interface：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Decoder <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Decode decodes the bytes of a packet, sending decoded values and other</span><br><span class="hljs-comment">// information to PacketBuilder, and returning an error if unsuccessful.  See</span><br><span class="hljs-comment">// the PacketBuilder documentation for more details.</span><br>Decode([]<span class="hljs-type">byte</span>, PacketBuilder) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实现了该interface的是gopacket中所有定义的协议，下面以数据链路层PPP协议的实现为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Decoder calls PPPTypeMetadata.DecodeWith&#x27;s decoder.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a PPPType)</span></span> Decode(data []<span class="hljs-type">byte</span>, p gopacket.PacketBuilder) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> PPPTypeMetadata[a].DecodeWith.Decode(data, p)<br>&#125;<br></code></pre></td></tr></table></figure><p>PPPTypeMetadata的定义为[65536]EnumMetadata，调用<code>Decode(data, p)</code>最终执行的是PPP协议实现的如下函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodePPP</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>, p gopacket.PacketBuilder)</span></span> <span class="hljs-type">error</span> &#123;<br>ppp := &amp;PPP&#123;&#125;<br>offset := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == <span class="hljs-number">0xff</span> &amp;&amp; data[<span class="hljs-number">1</span>] == <span class="hljs-number">0x03</span> &#123;<br>offset = <span class="hljs-number">2</span><br>ppp.HasPPTPHeader = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">if</span> data[offset]&amp;<span class="hljs-number">0x1</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> data[offset+<span class="hljs-number">1</span>]&amp;<span class="hljs-number">0x1</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;PPP has invalid type&quot;</span>)<br>&#125;<br>ppp.PPPType = PPPType(binary.BigEndian.Uint16(data[offset : offset+<span class="hljs-number">2</span>]))<br>ppp.Contents = data[offset : offset+<span class="hljs-number">2</span>]<br>ppp.Payload = data[offset+<span class="hljs-number">2</span>:]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ppp.PPPType = PPPType(data[offset])<br>ppp.Contents = data[offset : offset+<span class="hljs-number">1</span>]<br>ppp.Payload = data[offset+<span class="hljs-number">1</span>:]<br>&#125;<br>p.AddLayer(ppp)<br>p.SetLinkLayer(ppp)<br><span class="hljs-keyword">return</span> p.NextDecoder(ppp.PPPType)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数在ppp.go文件里。</p><p>decodePPP就是按照PPP协议的规定，第几个字节存储的是什么东西这样，读取所有存储PPP协议的字段，解析出PPP协议的各个字段的值。这里需要注意下PPPType的值，PPPType这里存储的是PPP协议上一层协议的类型。然后调用了p.NextDecoder(ppp.PPPType)，NextDecoder的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *eagerPacket)</span></span> NextDecoder(next Decoder) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> next == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errNilDecoder<br>&#125;<br>d := p.last.LayerPayload()<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(d) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// Since we&#x27;re eager, immediately call the next decoder.</span><br><span class="hljs-keyword">return</span> next.Decode(d, p)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里用了LayerPayload()的值来解码，解码所用的协议正是ppp.PPPType也就是PPP上一层的协议。LayerPayload()的值不包括PPP的头部，是PPP的Payload，也就是PPP协议的上一层的所有内容，上一层的协议的头部信息和Payload。</p><p>上一层协议会和PPP协议类似，调用Decode函数，继续解码。</p><h3 id="解码数据包时的一些选项的作用"><a href="#解码数据包时的一些选项的作用" class="headerlink" title="解码数据包时的一些选项的作用"></a>解码数据包时的一些选项的作用</h3><p>DecodeOptions在gopacket的源代码中定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// DecodeOptions tells gopacket how to decode a packet.</span><br><span class="hljs-keyword">type</span> DecodeOptions <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Lazy decoding decodes the minimum number of layers needed to return data</span><br><span class="hljs-comment">// for a packet at each function call.  Be careful using this with concurrent</span><br><span class="hljs-comment">// packet processors, as each call to packet.* could mutate the packet, and</span><br><span class="hljs-comment">// two concurrent function calls could interact poorly.</span><br>Lazy <span class="hljs-type">bool</span><br><span class="hljs-comment">// NoCopy decoding doesn&#x27;t copy its input buffer into storage that&#x27;s owned by</span><br><span class="hljs-comment">// the packet.  If you can guarantee that the bytes underlying the slice</span><br><span class="hljs-comment">// passed into NewPacket aren&#x27;t going to be modified, this can be faster.  If</span><br><span class="hljs-comment">// there&#x27;s any chance that those bytes WILL be changed, this will invalidate</span><br><span class="hljs-comment">// your packets.</span><br>NoCopy <span class="hljs-type">bool</span><br><span class="hljs-comment">// SkipDecodeRecovery skips over panic recovery during packet decoding.</span><br><span class="hljs-comment">// Normally, when packets decode, if a panic occurs, that panic is captured</span><br><span class="hljs-comment">// by a recover(), and a DecodeFailure layer is added to the packet detailing</span><br><span class="hljs-comment">// the issue.  If this flag is set, panics are instead allowed to continue up</span><br><span class="hljs-comment">// the stack.</span><br>SkipDecodeRecovery <span class="hljs-type">bool</span><br><span class="hljs-comment">// DecodeStreamsAsDatagrams enables routing of application-level layers in the TCP</span><br><span class="hljs-comment">// decoder. If true, we should try to decode layers after TCP in single packets.</span><br><span class="hljs-comment">// This is disabled by default because the reassembly package drives the decoding</span><br><span class="hljs-comment">// of TCP payload data after reassembly.</span><br>DecodeStreamsAsDatagrams <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><p>里面一共有4个选项。下面介绍其中比较重要的3个。</p><h4 id="Nocopy选项"><a href="#Nocopy选项" class="headerlink" title="Nocopy选项"></a>Nocopy选项</h4><p>在设置 <code>NoCopy</code> 选项为 <code>true</code> 时，<code>gopacket</code> 将尽量避免在解析数据包时进行内存拷贝操作。启用 <code>NoCopy</code> 选项后，<code>gopacket</code> 将尝试使用零拷贝技术，直接在原始数据包的内存中进行操作，避免不必要的内存拷贝操作，从而提高解析性能。在处理大量数据包时，启用 <code>NoCopy</code> 选项可以显著减少内存开销和CPU消耗，尤其是对于大型数据包或高速网络流量的处理</p><p>Nocopy选项在使用时一般是类似这样使用的，就是在DecodeOptions里指定Nocopy的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">handle, err := pcap.OpenOffline(file)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;.....err......&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> handle.Close()<br>packetSource := gopacket.NewPacketSource(handle, handle.LinkType())<br>packetSource.DecodeOptions.NoCopy = <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> packet := <span class="hljs-keyword">range</span> packetSource.Packets() &#123;<br>   <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么Nocopy到底有什么作用呢？</p><p>Nocopy在gopacket源代码的使用处如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPacket</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>, firstLayerDecoder Decoder, options DecodeOptions)</span></span> Packet &#123;<br><span class="hljs-comment">// NoCopy 表示是否直接操作数据包的原始数据，操作原始数据可能会影响原始包</span><br><span class="hljs-keyword">if</span> !options.NoCopy &#123;<br>dataCopy := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(data))<br><span class="hljs-built_in">copy</span>(dataCopy, data)<br>data = dataCopy<br>&#125;<br></code></pre></td></tr></table></figure><p>因为之后对data的更改会影响到调用NewPacket处的data的数据，即最原始的data。想要原始的data不被修改可以设置Nocopy为false。因为调用处传递的data是一个切片。</p><p>下面测试下函数内修改[]byte数组对原始值的影响：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s []<span class="hljs-type">byte</span><br>s = []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>testChange(s)<br>fmt.Println(<span class="hljs-string">&quot;......after testChange.....&quot;</span>, s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testChange</span><span class="hljs-params">(s []<span class="hljs-type">byte</span>)</span></span> &#123;<br>s[<span class="hljs-number">0</span>] = <span class="hljs-number">9</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">4</span>)<br>fmt.Println(<span class="hljs-string">&quot;......finish testChange.....&quot;</span>, s)<br>&#125;<br><span class="hljs-comment">// 运行结果为：</span><br><span class="hljs-comment">// ......finish testChange..... [9 2 3 4]</span><br><span class="hljs-comment">// ......after testChange..... [9 2 3]</span><br></code></pre></td></tr></table></figure><blockquote><p>在 Go 语言中，切片是一个引用类型，<strong>传递给函数时是按值传递的，但仍然是传递的引用的拷贝。这意味着在函数中修改切片的元素会影响到原始切片，但如果在函数内部重新分配了切片</strong>，则不会影响到原始切片。</p><p>修改了切片的第一个元素为 9，这会影响到原始切片。但是，在函数内部使用 <code>append</code> 函数追加一个元素时，实际上创建了一个新的切片，并将新切片的引用赋值给了 <code>s</code>，但这不会影响到原始切片。</p></blockquote><h4 id="DecodeStreamsAsDatagrams选项"><a href="#DecodeStreamsAsDatagrams选项" class="headerlink" title="DecodeStreamsAsDatagrams选项"></a>DecodeStreamsAsDatagrams选项</h4><p>DecodeStreamsAsDatagrams直接翻译为：将流解码为数据报</p><p>用于指示解码器将所有的流（streams）都作为数据报（datagrams）处理。</p><p>通常情况下，流是指基于连接的协议（如 TCP）中的数据流，而数据报是指基于无连接的协议（如 UDP）中的独立数据包。</p><p>当设置 <code>DecodeStreamsAsDatagrams</code> 选项时，解码器会将所有的流都当作数据报处理，即将所有的数据包视为独立的数据报，而不考虑它们的连接关系。这在一些特定场景下可能会有用，例如处理不基于连接的协议数据时，或者需要对每个数据包进行独立处理时。</p><h4 id="SkipDecodeRecovery选项"><a href="#SkipDecodeRecovery选项" class="headerlink" title="SkipDecodeRecovery选项"></a>SkipDecodeRecovery选项</h4><p>当设置为 <code>true</code> 时，<code>SkipDecodeRecovery</code> 将告诉 <code>gopacket</code> 在解析数据包时不进行恢复处理。通常情况下，如果 <code>gopacket</code> 在解析数据包时遇到错误或异常情况，它会尝试进行恢复处理，以尽可能多地解析出有效的数据。这种恢复处理可能包括尝试从错误中恢复，忽略部分损坏的数据，并尝试继续解析。</p><p>但是，在某些情况下，可能希望完全避免 <code>gopacket</code> 的恢复处理，而是直接在解析过程中忽略任何错误或异常情况，并接受可能的数据丢失或不完整。这时，可以将 <code>SkipDecodeRecovery</code> 设置为 <code>true</code>，告诉 <code>gopacket</code> 在解析数据包时不进行任何恢复处理，直接返回解析错误。</p><p>总的来说，设置 <code>SkipDecodeRecovery</code> 为 <code>true</code> 可以提高解析性能，但同时也可能导致更多的解析错误或数据丢失。因此，在使用时需要根据具体情况进行权衡和选择。</p><h4 id="Lazy选项"><a href="#Lazy选项" class="headerlink" title="Lazy选项"></a>Lazy选项</h4><p>Lazy选项设置为true来实现数据包的延迟解析。不设置为true即默认情况下，gopacket会在接收到数据包后立刻解析然后接收下一个数据包。如果设置为true，则会接收到数据包后不解析然后立刻接收下一个数据包，数据包的解析操作会在需要访问这些字段和数据时才进行解析。这样可以减少解析过程中的内存和CPU消耗，并提高性能。</p><p>举例来说，可能只对数据包的部分字段感兴趣，比如源地址、目的地址和协议类型等。启用 <code>Lazy</code> 选项后，<code>gopacket</code> 将只解析这些字段，而对于其他字段，只有在获取他们值的时候才会触发解析数据包的操作，且只解析尽可能少的数据，即不做多余的操作。</p><p>Lazy选项使用时可参考如下的方式使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">handle, err := pcap.OpenOffline(file)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;.....err......&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> handle.Close()<br>packetSource := gopacket.NewPacketSource(handle, handle.LinkType())<br>packetSource.DecodeOptions.NoCopy = <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> packet := <span class="hljs-keyword">range</span> packetSource.Packets() &#123;<br>   <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>gopacket源代码涉及到Lazy选项的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPacket</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>, firstLayerDecoder Decoder, options DecodeOptions)</span></span> Packet &#123;<br><span class="hljs-keyword">if</span> !options.NoCopy &#123;<br>dataCopy := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(data))<br><span class="hljs-built_in">copy</span>(dataCopy, data)<br>data = dataCopy<br>&#125;<br><span class="hljs-keyword">if</span> options.Lazy &#123;<br>p := &amp;lazyPacket&#123;<br>packet: packet&#123;data: data, decodeOptions: options&#125;,<br>next:   firstLayerDecoder,<br>&#125;<br>p.layers = p.initialLayers[:<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br>p := &amp;eagerPacket&#123;<br>packet: packet&#123;data: data, decodeOptions: options&#125;,<br>&#125;<br>p.layers = p.initialLayers[:<span class="hljs-number">0</span>]<br>p.initialDecode(firstLayerDecoder)<br><span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>PS：我这里贴出来的源代码在gopacket的基础上可能删掉了一部分注释，因为gopacket有的地方源代码的注释写得特别长，我直接把原来的注释贴在这里会让篇幅显得太长了。</p></blockquote><p>根据上面的代码可以看出，如果Lazy为true，那么就不会执行p.initialDecode(firstLayerDecoder)，initialDecode的作用就是尽可能的对包进行解码，把每一层的内容都分析出来。</p><p>所以如果Lazy为false，那么会在NewPacket中执行p.initialDecode，也就是每捕获到一个包之后会立即对包解码，把所有层的协议内容都分析出来，然后才会去捕获下一个包。<strong>Lazy设置为true时，则捕获到包之后不会对包进行解码就立即去捕获下一个包。</strong>因为多了一个对包进行解码的操作，所以Lazy为false时捕获包的速率必然不如Lazy设置为true的时候快。</p><p> 那么Lazy顾名思义就是延迟对包进行解码，那么gopacket是如何实现延迟解码的呢？gopacket的延迟解码是延迟到了什么程度呢？gopacket的包解码的延迟操作还有可优化的空间吗？下面解释下这些问题。</p><p>NewPacket定义了返回的类型必须是Packet interface。由NewPacket函数可以看出，如果Lazy为true时，返回的是lazyPacket类型的struct。Lazy为false时，返回的是eagerPacket类型的struct。lazyPacket struct和eagerPacket struct都实现了Packet interface。lazyPacket顾名思义，就是延迟包对包进行延迟解码操作。eagerPacket顾名思义，就是急切包即需要对包第一时间立即做出解码操作。</p><p>lazyPacket struct的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// lazyPacket does lazy decoding on its packet data.  On construction it does</span><br><span class="hljs-comment">// no initial decoding.  For each function call, it decodes only as many layers</span><br><span class="hljs-comment">// as are necessary to compute the return value for that function.</span><br><span class="hljs-comment">// lazyPacket implements Packet and PacketBuilder.</span><br><span class="hljs-keyword">type</span> lazyPacket <span class="hljs-keyword">struct</span> &#123;<br>packet<br>next Decoder<br>&#125;<br><br><span class="hljs-comment">// packet 实现了 gopacket.PacketBuilder interface</span><br><span class="hljs-comment">// packet contains all the information we need to fulfill the Packet interface,</span><br><span class="hljs-comment">// and its two &quot;subclasses&quot; (yes, no such thing in Go, bear with me),</span><br><span class="hljs-comment">// eagerPacket and lazyPacket, provide eager and lazy decoding logic around the</span><br><span class="hljs-comment">// various functions needed to access this information.</span><br><span class="hljs-keyword">type</span> packet <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// data contains the entire packet data for a packet</span><br>data []<span class="hljs-type">byte</span><br><span class="hljs-comment">// initialLayers is space for an initial set of layers already created inside</span><br><span class="hljs-comment">// the packet.</span><br><span class="hljs-comment">// 存储已经创建好了的各层数据</span><br>initialLayers [<span class="hljs-number">6</span>]Layer<br><span class="hljs-comment">// layers contains each layer we&#x27;ve already decoded</span><br>layers []Layer<br><span class="hljs-comment">// last is the last layer added to the packet</span><br>last Layer<br><span class="hljs-comment">// metadata is the PacketMetadata for this packet</span><br>metadata PacketMetadata<br><br>decodeOptions DecodeOptions<br><br><span class="hljs-comment">// Pointers to the various important layers</span><br>link        LinkLayer<br>network     NetworkLayer<br>transport   TransportLayer<br>application ApplicationLayer<br>failure     ErrorLayer<br>&#125;<br></code></pre></td></tr></table></figure><p>由lazyPacket的注释可以看出，lazyPacket对于每个函数调用，它仅解码计算该函数的返回值所需的层数。也就是当尝试访问数据包的某一层内容时，lazyPacket只会解码到需要的那一层，而不会再继续解码上一层的数据。总结下来就是只在需要的时候只返回需要的内容，不会返回需要更多额外操作的内容，这就是所谓的Lazy的含义。</p><p>下面以调用时常用的Layer(t LayerType)函数为例，lazyPacket的此函数为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *lazyPacket)</span></span> Layer(t LayerType) Layer &#123;<br><span class="hljs-keyword">for</span> _, l := <span class="hljs-keyword">range</span> p.layers &#123;<br><span class="hljs-comment">// 数据包之前已经被解码了的情况下，遍历已经解码了的各层</span><br>    <span class="hljs-comment">// 一旦发现需要的数据层，立刻返回</span><br><span class="hljs-keyword">if</span> l.LayerType() == t &#123;<br><span class="hljs-keyword">return</span> l<br>&#125;<br>&#125;<br>numLayers := <span class="hljs-built_in">len</span>(p.layers)<br><span class="hljs-comment">// p.next 为空的时候，表示所有能解码的都解码完毕了</span><br><span class="hljs-keyword">for</span> p.next != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 只解码一层，不会包整个包都解码完分析完</span><br>p.decodeNextLayer()<br><span class="hljs-keyword">for</span> _, l := <span class="hljs-keyword">range</span> p.layers[numLayers:] &#123;<br><span class="hljs-keyword">if</span> l.LayerType() == t &#123;<br><span class="hljs-keyword">return</span> l<br>&#125;<br>&#125;<br>numLayers = <span class="hljs-built_in">len</span>(p.layers)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里Layer函数一旦发现传入的t参数需要的层，会立刻停止解码。</p><p>p.layers 为 []Layer 类型，存储的是已经解码出来的各层数据，如果后续继续解码上层，会把解码出来的层的信息继续追加到p.layers 里。p.next表示了接下来要解码的是什么协议。</p><p>那么p.next是如何获取到的呢？首先是p.decodeNextLayer()的调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *lazyPacket)</span></span> decodeNextLayer() &#123;<br><span class="hljs-keyword">if</span> p.next == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>d := p.data<br><span class="hljs-keyword">if</span> p.last != <span class="hljs-literal">nil</span> &#123;<br>d = p.last.LayerPayload()<br>&#125;<br>next := p.next<br>p.next = <span class="hljs-literal">nil</span><br><span class="hljs-comment">// We&#x27;ve just set p.next to nil, so if we see we have no data, this should be</span><br><span class="hljs-comment">// the final call we get to decodeNextLayer if we return here.</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(d) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> p.recoverDecodeError()<br>err := next.Decode(d, p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>p.addFinalDecodeError(err, <span class="hljs-literal">nil</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数里的重点就是Decode函数，Decode跳转过去的定义处为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PacketBuilder <span class="hljs-keyword">interface</span> &#123;<br>DecodeFeedback<br><span class="hljs-comment">// AddLayer should be called by a decoder immediately upon successful</span><br><span class="hljs-comment">// decoding of a layer.</span><br>AddLayer(l Layer)<br><span class="hljs-comment">// The following functions set the various specific layers in the final</span><br><span class="hljs-comment">// packet.  Note that if many layers call SetX, the first call is kept and all</span><br><span class="hljs-comment">// other calls are ignored.</span><br>SetLinkLayer(LinkLayer)<br>SetNetworkLayer(NetworkLayer)<br>SetTransportLayer(TransportLayer)<br>SetApplicationLayer(ApplicationLayer)<br>SetErrorLayer(ErrorLayer)<br><span class="hljs-comment">// NextDecoder should be called by a decoder when they&#x27;re done decoding a</span><br><span class="hljs-comment">// packet layer but not done with decoding the entire packet.  The next</span><br><span class="hljs-comment">// decoder will be called to decode the last AddLayer&#x27;s LayerPayload.</span><br><span class="hljs-comment">// Because of this, NextDecoder must only be called once all other</span><br><span class="hljs-comment">// PacketBuilder calls have been made.  Set*Layer and AddLayer calls after</span><br><span class="hljs-comment">// NextDecoder calls will behave incorrectly.</span><br>NextDecoder(next Decoder) <span class="hljs-type">error</span><br><span class="hljs-comment">// DumpPacketData is used solely for decoding.  If you come across an error</span><br><span class="hljs-comment">// you need to diagnose while processing a packet, call this and your packet&#x27;s</span><br><span class="hljs-comment">// data will be dumped to stderr so you can create a test.  This should never</span><br><span class="hljs-comment">// be called from a production decoder.</span><br>DumpPacketData()<br><span class="hljs-comment">// DecodeOptions returns the decode options</span><br>DecodeOptions() *DecodeOptions<br>&#125;<br><br><span class="hljs-keyword">type</span> Decoder <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Decode decodes the bytes of a packet, sending decoded values and other</span><br><span class="hljs-comment">// information to PacketBuilder, and returning an error if unsuccessful.  See</span><br><span class="hljs-comment">// the PacketBuilder documentation for more details.</span><br>Decode([]<span class="hljs-type">byte</span>, PacketBuilder) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>gopacket里定义的所有协议，包括以太网协议，IPv4协议，IPv6协议，TCP协议都实现了Decoder interface。</p><p>下面以数据链路层的以太网协议的实现为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Decoder calls EthernetTypeMetadata.DecodeWith&#x27;s decoder.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a EthernetType)</span></span> Decode(data []<span class="hljs-type">byte</span>, p gopacket.PacketBuilder) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> EthernetTypeMetadata[a].DecodeWith.Decode(data, p)<br>&#125;<br></code></pre></td></tr></table></figure><p>EthernetTypeMetadata的定义为 [65536]EnumMetadata，存储了数据链路层所有可能的协议。</p><p>最终调用的Decode(data, p)其实是每个协议定义的入参为([]byte, PacketBuilder)，返回值为 error 的函数。以Ethernet协议为例，其实现是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeEthernet</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>, p gopacket.PacketBuilder)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 此时接收到的 data 是完整的数据包的内容</span><br>eth := &amp;Ethernet&#123;&#125;<br>err := eth.DecodeFromBytes(data, p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">// AddLayer 同时会把 eth设置为 last</span><br>p.AddLayer(eth)<br><span class="hljs-comment">// 设置链路层的信息</span><br>p.SetLinkLayer(eth)<br><span class="hljs-comment">// eth 的 payload 是除了以太网头部的其他内容，包括 IP层头，TCP层头及以上层的内容</span><br><span class="hljs-comment">// 这里的 eth.EthernetType 可能是 IPv4</span><br><span class="hljs-comment">// NextDecoder 对于 lazyPacket 来说，只是将 eth.EthernetType 赋只给 p.next</span><br><span class="hljs-comment">// 对于 eagerPacket 来说，则会进行解码操作</span><br><span class="hljs-keyword">return</span> p.NextDecoder(eth.EthernetType)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的重点是DecodeFromBytes函数，DecodeFromBytes的实现为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(eth *Ethernet)</span></span> DecodeFromBytes(data []<span class="hljs-type">byte</span>, df gopacket.DecodeFeedback) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) &lt; <span class="hljs-number">14</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;Ethernet packet too small&quot;</span>)<br>&#125;<br>eth.DstMAC = net.HardwareAddr(data[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>])<br>eth.SrcMAC = net.HardwareAddr(data[<span class="hljs-number">6</span>:<span class="hljs-number">12</span>])<br>eth.EthernetType = EthernetType(binary.BigEndian.Uint16(data[<span class="hljs-number">12</span>:<span class="hljs-number">14</span>]))<br>eth.BaseLayer = BaseLayer&#123;data[:<span class="hljs-number">14</span>], data[<span class="hljs-number">14</span>:]&#125;<br>eth.Length = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> eth.EthernetType &lt; <span class="hljs-number">0x0600</span> &#123;<br>eth.Length = <span class="hljs-type">uint16</span>(eth.EthernetType)<br>eth.EthernetType = EthernetTypeLLC<br><span class="hljs-keyword">if</span> cmp := <span class="hljs-built_in">len</span>(eth.Payload) - <span class="hljs-type">int</span>(eth.Length); cmp &lt; <span class="hljs-number">0</span> &#123;<br>df.SetTruncated()<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> cmp &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Strip off bytes at the end, since we have too many bytes</span><br>eth.Payload = eth.Payload[:<span class="hljs-built_in">len</span>(eth.Payload)-cmp]<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>DecodeFromBytes其实就是读取固定的几个字节，这几个字节的内容是按照了Ethernet协议的标准存储的。故解析固定的字节可以得到Ethernet协议的一些字段，比如源Mac地址，目的Mac地址等等。这里最需要注意的就是EthernetType(binary.BigEndian.Uint16(data[12:14]))，第12到第14个字节存储的信息是Ethernet协议上一层的协议的表示，可能是IPv4协议，或者是IPv6协议，故eth.EthernetType的值为上一层的协议的标识。</p><p>最后执行的p.NextDecoder(eth.EthernetType)的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *lazyPacket)</span></span> NextDecoder(next Decoder) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> next == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errNilDecoder<br>&#125;<br>p.next = next<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码很简单，就是把上一层协议赋值给p.next。这里赋值的作用于上面的<code>func (p *lazyPacket) Layer(t LayerType) Layer </code>函数里<code>for p.next != nil &#123;</code>部分，<code>for p.next != nil </code>会使用p.next继续解码，如果p.next为IPv4协议或者IPv6协议，会使用p.next为IPv4协议或者IPv6协议会类似EthernetType，对应实现的，用IPv4协议或者IPv6协议实现的Decode函数进行解码，得到IPv4协议或者IPv6协议的内容。</p><h3 id="差不多每一层有字段记录上一层的协议"><a href="#差不多每一层有字段记录上一层的协议" class="headerlink" title="差不多每一层有字段记录上一层的协议"></a>差不多每一层有字段记录上一层的协议</h3><p>对包进行解码时如何知晓当前层的上一层是什么协议呢？其实每一层有字段记录上一层的协议。</p><p>比如数据链路层有的协议会记录上一层即网络层使用的协议是什么，比如这里就用两个字节记录了上一层的协议是IPv4协议。</p><p><img src="/../images/image-20240425172341705.png" alt="image-20240425172341705"></p><p>gopacket的以太网的解码操作也有对应的代码：</p><p><img src="/../images/image-20240425172536911.png" alt="image-20240425172536911"></p><p>第51行读取了对应的字节的内容，转换成了对应的协议，这里获取到的值就是IPv4，赋值给了EthernetType字段。</p><p>除了数据链路层，网络层的IP协议也会记录上一层传输层用的是什么协议</p><p><img src="/../images/image-20240425174555590.png" alt="image-20240425174555590"></p><p>在gopacket代码中也有对应的，</p><p><img src="/../images/image-20240425174626515.png" alt="image-20240425174626515"></p><p>这里的DecodeFromBytes传入的data不是完整的数据包的内容了，而是除掉了数据链路层的头部，用的是以下部分：</p><p><img src="/../images/image-20240425174821243.png" alt="image-20240425174821243"></p><h3 id="解码什么时候停止"><a href="#解码什么时候停止" class="headerlink" title="解码什么时候停止"></a>解码什么时候停止</h3><p>以gopacket定义的Payload协议为例：</p><p><img src="/../images/image-20240426112555437.png" alt="image-20240426112555437"></p><p>以UDP为例，在找不到对应类型的情况下都会使用Payload作为协议类型：</p><p><img src="/../images/image-20240426112958224.png" alt="image-20240426112958224"></p><h2 id="其他包和文件阅读"><a href="#其他包和文件阅读" class="headerlink" title="其他包和文件阅读"></a>其他包和文件阅读</h2><p>这部分写得比较随意，因为有不少因为源代码实在太难了，读不懂，就记录了我自己看懂的部分。可能比较随意。没什么有总结性和可参考性的内容，阅读时可以跳过。</p><h3 id="examples-x2F-arpscan-x2F-arpscan-go"><a href="#examples-x2F-arpscan-x2F-arpscan-go" class="headerlink" title="examples&#x2F;arpscan&#x2F;arpscan.go"></a>examples&#x2F;arpscan&#x2F;arpscan.go</h3><p>序列化就是自定义数据各层，然后将各层数据放到*pcap.Handle类型的handle里，使用  handle.WritePacketData(buf.Bytes()) 来写入handle里</p><p>序列化的调用参考这个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeARP</span><span class="hljs-params">(handle *pcap.Handle, iface *net.Interface, addr *net.IPNet)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// Set up all the layers&#x27; fields we can.</span><br>eth := layers.Ethernet&#123;<br>SrcMAC:       iface.HardwareAddr,<br>DstMAC:       net.HardwareAddr&#123;<span class="hljs-number">0xff</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0xff</span>&#125;,<br>EthernetType: layers.EthernetTypeARP,<br>&#125;<br>arp := layers.ARP&#123;<br>AddrType:          layers.LinkTypeEthernet,<br>Protocol:          layers.EthernetTypeIPv4,<br>HwAddressSize:     <span class="hljs-number">6</span>,<br>ProtAddressSize:   <span class="hljs-number">4</span>,<br>Operation:         layers.ARPRequest,<br>SourceHwAddress:   []<span class="hljs-type">byte</span>(iface.HardwareAddr),<br>SourceProtAddress: []<span class="hljs-type">byte</span>(addr.IP),<br>DstHwAddress:      []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>&#125;<br><span class="hljs-comment">// Set up buffer and options for serialization.</span><br>buf := gopacket.NewSerializeBuffer()<br>opts := gopacket.SerializeOptions&#123;<br>FixLengths:       <span class="hljs-literal">true</span>,<br>ComputeChecksums: <span class="hljs-literal">true</span>,<br>&#125;<br><span class="hljs-comment">// Send one packet for every address.</span><br><span class="hljs-keyword">for</span> _, ip := <span class="hljs-keyword">range</span> ips(addr) &#123;<br>arp.DstProtAddress = []<span class="hljs-type">byte</span>(ip)<br>gopacket.SerializeLayers(buf, opts, &amp;eth, &amp;arp)<br><span class="hljs-keyword">if</span> err := handle.WritePacketData(buf.Bytes()); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一些gopacket里定义的东西如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 设置缓冲区和序列化选项</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSerializeBuffer</span><span class="hljs-params">()</span></span> SerializeBuffer &#123;<br><span class="hljs-keyword">return</span> &amp;serializeBuffer&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 序列化选项</span><br><span class="hljs-keyword">type</span> SerializeOptions <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// FixLengths 确定在序列化期间，层是否应修复取决于有效负载的任何长度字段的值。</span><br>FixLengths <span class="hljs-type">bool</span><br><span class="hljs-comment">// ComputeChecksums 确定在序列化期间各层是否应根据其有效负载重新计算校验和</span><br>ComputeChecksums <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="examples-x2F-bidirectional-x2F-arpscan-go"><a href="#examples-x2F-bidirectional-x2F-arpscan-go" class="headerlink" title="examples&#x2F;bidirectional&#x2F;arpscan.go"></a>examples&#x2F;bidirectional&#x2F;arpscan.go</h3><p>bidirectional直接翻译为双向</p><p>这块好像是关于tcpassembly的，是只针对TCP的重组</p><p>streamPool :&#x3D; tcpassembly.NewStreamPool(streamFactory)</p><p>tcpassembly.NewStreamPool需要传递的值是一个interface：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 程序集使用 StreamFactory 为每个新的 TCP 会话创建一个新的流</span><br><span class="hljs-keyword">type</span> StreamFactory <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// 对于给定的TCP key，New函数应该返回一个新的流</span><br>New(netFlow, tcpFlow gopacket.Flow) Stream<br>&#125;<br><br><span class="hljs-comment">// assembly逻辑的执行顺序为：</span><br><span class="hljs-comment">// 1.通过StreamFactory.New创建流</span><br><span class="hljs-comment">// 2. 调用Reassembled 0次或多次，按顺序传入重组后的TCP数据</span><br><span class="hljs-comment">// 3. 调用 Re assemblyComplete 一次，之后该流将被程序集解除引用。</span><br><span class="hljs-keyword">type</span> Stream <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Reassembled被调用零次或多次。 assembly 保证在所有调用期间传入的所有 Reassemble 对象的集合按照它们在 TCP 流中出现的顺序呈现。</span><br>Reassembled([]Reassembly)<br><span class="hljs-comment">// 当程序集确定此流不再有数据时，将调用 ReassembleComplete，因为看到了 FIN 或 RST 数据包，或者因为流已超时，没有任何新数据包数据（由于调用 FlushOlderThan）。</span><br>ReassemblyComplete()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="afpacket包"><a href="#afpacket包" class="headerlink" title="afpacket包"></a>afpacket包</h3><p>TPacket struct，gpt说：TPacket 包提供了对 Linux TPACKETv3 捕获模式的支持。TPACKETv3 是一种高性能的数据包捕获模式，常用于高速网络流量分析和数据包处理。</p><p>相关代码备份：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTPacket</span><span class="hljs-params">(opts ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (h *TPacket, err <span class="hljs-type">error</span>) <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *TPacket)</span></span> ReadPacketData() (data []<span class="hljs-type">byte</span>, ci gopacket.CaptureInfo, err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><h3 id="bsdbpf包"><a href="#bsdbpf包" class="headerlink" title="bsdbpf包"></a>bsdbpf包</h3><p>关于BPF的Options的设置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBPFSniffer</span><span class="hljs-params">(iface <span class="hljs-type">string</span>, options *Options)</span></span> (*BPFSniffer, <span class="hljs-type">error</span>) <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BPFSniffer)</span></span> ReadPacketData() ([]<span class="hljs-type">byte</span>, gopacket.CaptureInfo, <span class="hljs-type">error</span>) <br></code></pre></td></tr></table></figure><h3 id="bytediff包"><a href="#bytediff包" class="headerlink" title="bytediff包"></a>bytediff包</h3><p>这是关于输出格式的设置</p><h3 id="defrag-x2F-lcmdefrag"><a href="#defrag-x2F-lcmdefrag" class="headerlink" title="defrag&#x2F;lcmdefrag"></a>defrag&#x2F;lcmdefrag</h3><p>defrag直接翻译为碎片整理</p><h3 id="dumpcommand"><a href="#dumpcommand" class="headerlink" title="dumpcommand"></a>dumpcommand</h3><p>这是一个示例程序</p><h3 id="ip4defrag"><a href="#ip4defrag" class="headerlink" title="ip4defrag"></a>ip4defrag</h3><p>defrag直接翻译为碎片整理</p><h3 id="layers"><a href="#layers" class="headerlink" title="layers"></a>layers</h3><p>定义了各层的协议，好像都实现了以下的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arp *ARP)</span></span> LayerType() gopacket.LayerType &#123; <span class="hljs-keyword">return</span> LayerTypeARP &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arp *ARP)</span></span> DecodeFromBytes(data []<span class="hljs-type">byte</span>, df gopacket.DecodeFeedback) <span class="hljs-type">error</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arp *ARP)</span></span> NextLayerType() gopacket.LayerType <br></code></pre></td></tr></table></figure><h3 id="macs"><a href="#macs" class="headerlink" title="macs"></a>macs</h3><p>定义mac地址的一些常量</p><h3 id="pcap"><a href="#pcap" class="headerlink" title="pcap"></a>pcap</h3><p>关于通过调用C语言来抓网卡的数据包</p><h3 id="pcapgo"><a href="#pcapgo" class="headerlink" title="pcapgo"></a>pcapgo</h3><p>NgReader 结构体用于从 Netgraph 接口读取数据包。Netgraph 是 FreeBSD 和一些其他 BSD 系统中的一种通用内核级网络处理框架，它允许用户通过定义节点和连接来构建网络拓扑，并在节点之间传递数据。</p><p>NgWriter struct</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NgInterface holds all the information of a pcapng interface.</span><br><span class="hljs-keyword">type</span> NgInterface <span class="hljs-keyword">struct</span><br></code></pre></td></tr></table></figure><p>pcapng 是一种新的数据包捕获文件格式，它是 pcap 格式的一个扩展，提供了更多的功能和灵活性。pcapng 文件格式支持更多的元数据、多个数据包流、更好的时间戳精度等功能，使得它在网络流量分析和数据包捕获方面更加强大和灵活。</p><p>read.go 文件：Reader 包装了一个底层 io.Reader 以读取 PCAP 格式的数据包数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reader)</span></span> ReadPacketData() (data []<span class="hljs-type">byte</span>, ci gopacket.CaptureInfo, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reader)</span></span> ZeroCopyReadPacketData() (data []<span class="hljs-type">byte</span>, ci gopacket.CaptureInfo, err <span class="hljs-type">error</span>) <br></code></pre></td></tr></table></figure><p>snoop.go:直接翻译为窥探，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SnoopReader <span class="hljs-keyword">struct</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSnoopReader</span><span class="hljs-params">(r io.Reader)</span></span> (*SnoopReader, <span class="hljs-type">error</span>) <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *SnoopReader)</span></span> ReadPacketData() (data []<span class="hljs-type">byte</span>, ci gopacket.CaptureInfo, err <span class="hljs-type">error</span>) <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *SnoopReader)</span></span> ZeroCopyReadPacketData() (data []<span class="hljs-type">byte</span>, ci gopacket.CaptureInfo, err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>write.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">struct</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewWriter</span><span class="hljs-params">(w io.Writer)</span></span> *Writer <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Writer)</span></span> WriteFileHeader(snaplen <span class="hljs-type">uint32</span>, linktype layers.LinkType) <span class="hljs-type">error</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Writer)</span></span> WritePacket(ci gopacket.CaptureInfo, data []<span class="hljs-type">byte</span>) <span class="hljs-type">error</span> <br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//  f, _ := os.Create(&quot;/tmp/file.pcap&quot;)</span><br><span class="hljs-comment">//  w := pcapgo.NewWriter(f)</span><br><span class="hljs-comment">//  w.WriteFileHeader(65536, layers.LinkTypeEthernet)  // new file, must do this.</span><br><span class="hljs-comment">//  w.WritePacket(gopacket.CaptureInfo&#123;...&#125;, data1)</span><br><span class="hljs-comment">//  f.Close()</span><br></code></pre></td></tr></table></figure><h3 id="pfring"><a href="#pfring" class="headerlink" title="pfring"></a>pfring</h3><p>Ring struct</p><p>Ring 结构体代表了一个环形缓冲区，用于存储数据包。环形缓冲区是一种循环队列的数据结构，它具有固定大小的缓冲区，可以循环存储和读取数据，当缓冲区的末尾被写满时，新的数据会从缓冲区的开头重新开始写入。</p><h3 id="reassembly"><a href="#reassembly" class="headerlink" title="reassembly"></a>reassembly</h3><p>memory.go：StreamPool struct StreamPool 结构体代表了一个用于管理流的池。流在网络数据包分析中是一个重要的概念，它代表了两个端点之间的通信会话，可以根据一系列的数据包来重构出完整的通信流程。</p><p>tcpassembly.go：直接翻译为TCP集会</p><p>tcpcheck.go：通过一些选项对TCP包进行检验？？？？？？好像也没啥用？？？</p><h3 id="routing"><a href="#routing" class="headerlink" title="routing"></a>routing</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Router根据内核的路由表实现简单的IPv4/IPv6路由。 这个路由库的功能很少，在某些情况下实际上可能会错误地路由，但它应该在大多数情况下都可以工作。</span><br><span class="hljs-keyword">type</span> Router <span class="hljs-keyword">interface</span> &#123;<br>Route(dst net.IP) (iface *net.Interface, gateway, preferredSrc net.IP, err <span class="hljs-type">error</span>)<br>RouteWithSrc(input net.HardwareAddr, src, dst net.IP) (iface *net.Interface, gateway, preferredSrc net.IP, err <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个包里有一个strcut实现了这个interface，可以通过<code>func New() (Router, error)</code>调用返回这个struct实现的interface</p><h3 id="tcpassembly"><a href="#tcpassembly" class="headerlink" title="tcpassembly"></a>tcpassembly</h3><blockquote><p>gopacket里<strong>Reassembly</strong>和<strong>Assembly</strong>的介绍：</p><p>Reassembly 主要用于处理分段传输或 IP 分片重组，将多个数据包片段组装成完整的数据包；</p><p>而 Assembly 则主要用于处理单个数据包的分解，将单个数据包分解成多个数据包片段。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://stackoverflow.com/questions/34085818/is-libpcap-implemented-by-socket-api">Is libpcap implemented by socket API?</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hping3简介与基本的使用</title>
    <link href="/2024/04/23/hping3%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/04/23/hping3%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>hping3是用于生成和解析TCP&#x2F;IP协议数据包汇编&#x2F;分析的命令行开源工具，可以用于模拟数据包发送，我使用这个工具的主要目的就是想要模拟指定数量的数据包发送的效果。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>centos安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install hping3<br></code></pre></td></tr></table></figure><p>安装完毕后输入<code>hping3 -v</code>验证是否成功</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>下面指定发送多少个数据包，且指定所有的数据包必须在给定的时间内发送完毕</p><p><code>-c</code>指定一共要发送多少个数据包</p><p><code>-i</code>指定发送的数据包的前后两个数据包的时间间隔，单位是秒，如果值前面加上’u’前缀，表示单位为微秒（microseconds）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo hping3 -c 100 -i 10 localhost<br></code></pre></td></tr></table></figure><p>这条命令的效果就是发送100个数据包，前后两个数据包的时间间隔是10秒，那么一共需要 100*10&#x3D;1000秒才能发送完毕。</p><p>这条命令对应的<code>tcpdump -i lo</code>抓到的部分内容为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">15:14:11.415231 IP localhost.cadabra-lm &gt; localhost.0: Flags [none], win 512, length 0<br>15:14:11.415257 IP localhost.0 &gt; localhost.cadabra-lm: Flags [R.], seq 0, ack 641111849, win 0, length 0<br>15:14:21.415339 IP localhost.pay-per-view &gt; localhost.0: Flags [none], win 512, length 0<br>15:14:21.415366 IP localhost.0 &gt; localhost.pay-per-view: Flags [R.], seq 0, ack 1902166683, win 0, length 0<br>15:14:31.415447 IP localhost.winddlb &gt; localhost.0: Flags [none], win 512, length 0<br>15:14:31.415471 IP localhost.0 &gt; localhost.winddlb: Flags [R.], seq 0, ack 1291643278, win 0, length 0<br>15:14:41.415547 IP localhost.corelvideo &gt; localhost.0: Flags [none], win 512, length 0<br>15:14:41.415572 IP localhost.0 &gt; localhost.corelvideo: Flags [R.], seq 0, ack 1150896678, win 0, length 0<br></code></pre></td></tr></table></figure><p>在<code>-i</code>参数加上<code>u</code>前缀则表示单位为微秒不是默认的秒，比如这里u1000表示前后两个数据包的时间间隔是1000微秒。PS：1秒等于 1,000,000 微秒。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo hping3 -c 100 -i u1000 localhost<br></code></pre></td></tr></table></figure><h2 id="传输数据包内容"><a href="#传输数据包内容" class="headerlink" title="传输数据包内容"></a>传输数据包内容</h2><p>如果想知晓传输的数据包的具体内容，可以使用tcpdump命令把数据包保存到pcap文件中，参考<code>tcpdump -i lo -w lo.pcap</code>，然后使用wireshark查看保存的pcap文件。</p><p>可以看到传输的都是一些TCP包，且没有TCP payload</p><p><img src="/../images/image-20240423161246453.png" alt="image-20240423161246453"></p><p>数据包的最后两个字节对应的是Urgent Pointer标识，没有TCP payload。</p><p><img src="/../images/image-20240423161403474.png" alt="image-20240423161403474"></p><h2 id="大流量的测试"><a href="#大流量的测试" class="headerlink" title="大流量的测试"></a>大流量的测试</h2><p>我想测试下在1秒内发送20000个数据包hping3能否实现，用<code>sudo hping3 -c 25000 -i u44 localhost</code>执行，同时用tcpdump到pcap文件中。hping3 执行完毕后，隔了一会停止了tcpdump，发现tcpdump抓到了50000个包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">tcpdump -i lo -w lo.pcap<br>tcpdump: listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes<br>^C50000 packets captured<br>100000 packets received by filter<br>0 packets dropped by kernel<br></code></pre></td></tr></table></figure><p>再查看pcap文件，25000*44微秒差不多是1秒，但是pcap第一条和最后一条的时间差距超过了1秒：</p><p><img src="/../images/image-20240423180737493.png" alt="image-20240423180737493"></p><p><img src="/../images/image-20240423180800102.png" alt="image-20240423180800102"></p><p>pcap文件里有50000条，是因为传输了25000条包含了来回的包，指定的25000个包只是单向的，50000条还包含了对应的返回。这个从Info里可以看出来</p><p><img src="/../images/image-20240423181110586.png" alt="image-20240423181110586"></p><p>总结：hping3 虽然发送了指定数量的包，但是没有在指定时间内完成。hping3 可能无法以如此高的速率连续发送数据包。实际的发送速率可能会受到网络和目标主机的限制。</p><p>在抓包的时候可以看出来，每次使用的端口是变化的。好像是递增的。</p><p>再次验证：使用<code>sudo hping3 -c 25000 -i u80 localhost</code>命令抓包，对应的pcap文件为：</p><p><img src="/../images/image-20240424101116282.png" alt="image-20240424101116282"></p><p>可以看到发送第一个包和第二个包的时间间隔是154微秒，而不是指定的80微秒。这是因为hping3可能无法实现这么高的速率，应该不是机器问题，因为我之前测试的时候用 iperf3打流的速率是可以实现每秒20000个数据包的发送的。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>zabbix介绍与使用</title>
    <link href="/2024/04/22/zabbix%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/04/22/zabbix%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>zabbix是一款开源的网络监控和管理系统，旨在监控各种网络服务，服务器，网络设备等等。</p><p>zabbix除了监控之外，还可以配置报警。</p><p>还提供了可视化图表。</p><p>还提供了丰富的插件和扩展接口，通过定制化插件来扩展功能和特性，满足不同的需求。</p><blockquote><p>本文介绍了zabbix非常基础的使用，因为是在工作过程中记录的，工作中只涉及到了这些比较基础的部分，所以一些其他用法或者比较高级的用法没有涉及。</p></blockquote><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>在物理机上，创建应用必须的目录和文件：</p><p>编辑docker-compose.yml文件为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">zabbix-web-nginx-mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">zabbix/zabbix-web-nginx-mysql:centos-5.2-latest</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_SERVER_HOST=zabbix-mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_DATABASE=zabbix</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_USER=zabbix</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_PASSWORD=zabbix</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=123qwe</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ZBX_SERVER_HOST=zabbix-server-mysql</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:8080</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">$PWD/fonts/DejaVuSans.ttf:/usr/share/zabbix/assets/fonts/DejaVuSans.ttf</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zbx_net</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zabbix-server-mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zabbix-mysql</span><br>  <span class="hljs-attr">zabbix-mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8.0.23</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">3306</span><span class="hljs-string">:3306</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_DATABASE=zabbix</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_USER=zabbix</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_PASSWORD=zabbix</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=123qwe</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysqld</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--character-set-server=utf8</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">--collation-server=utf8_bin</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">$PWD/db:/var/lib/mysql</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zbx_net</span><br>  <span class="hljs-attr">zabbix-java-gateway:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">zabbix/zabbix-java-gateway:centos-5.2-latest</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zbx_net</span><br>  <span class="hljs-attr">zabbix-server-mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">zabbix/zabbix-server-mysql:centos-5.2-latest</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zabbix-server-vol:/etc/zabbix</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">$PWD/alertscripts:/usr/lib/zabbix/alertscripts</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">10051</span><span class="hljs-string">:10051</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_SERVER_HOST=zabbix-mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_DATABASE=zabbix</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_USER=zabbix</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_PASSWORD=zabbix</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=123qwe</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ZBX_JAVAGATEWAY=zabbix-java-gateway</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ZBX_JAVAGATEWAY_ENABLE=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ZBX_JAVAGATEWAYPORT=10052</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zabbix-mysql</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zbx_net</span><br>  <span class="hljs-attr">zabbix-agent:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">zabbix/zabbix-agent:centos-5.2-latest</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">10050</span><span class="hljs-string">:10050</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ZBX_HOSTNAME=Zabbix</span> <span class="hljs-string">server</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ZBX_SERVER_HOST=zabbix-server-mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ZBX_SERVER_PORT=10051</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zbx_net</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">zbx_net:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">zabbix-server-vol:</span><br></code></pre></td></tr></table></figure><p>创建启动所必须的目录和文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir alertscripts db fonts<br>cd fonts<br>wget https://dl.cactifans.com/zabbix_docker/msty.ttf<br>mv msty.ttf DejaVuSans.ttf<br></code></pre></td></tr></table></figure><p>切换回上一级别，启动服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>docker compose up -d<br></code></pre></td></tr></table></figure><p>访问 localhost:8080 即可查看zabbix登陆地址，默认用户名和密码为Admin zabbix</p><p>启动后更改主机里的配置，改为监控agent，因为agent是和物理机交互，采集的是docker compose所运行的物理机上的指标，所以改为agent就能获取物理机的指标了。</p><p><img src="/../images/image-20240325145649691.png" alt="image-20240325145649691"></p><p><img src="/../images/image-20240325145807902.png" alt="image-20240325145807902"></p><p>点击update后刷新可以看到该主机状态为已启用，绿色的ZBX表示主机可用，监控指标检查已成功。</p><p><img src="/../images/image-20240325145849053.png" alt="image-20240325145849053"></p><h2 id="常用概念介绍"><a href="#常用概念介绍" class="headerlink" title="常用概念介绍"></a>常用概念介绍</h2><p>主机：要通过 IP&#x2F;DNS 监控的联网设备。<strong>对于主机的定义非常灵活。它可以是一台物理服务器，一个网络交换机，一个虚拟机或者某些应用程序。</strong></p><p>监控项：想要接收的主机的特定数据，一个度量&#x2F;指标数据。监控项是Zabbix中采集数据的基础。没有监控项，就没有数据——因为一个主机中只有监控项定义了单一的指标或者需要获得的数据。所有的监控项都是依赖主机的，所以一定要先配置主机再配置该主机的监控项。</p><h2 id="查看监控项"><a href="#查看监控项" class="headerlink" title="查看监控项"></a>查看监控项</h2><p>在第一个“部署”部分，已经实现了对主机的监控。这里添加对上述主机的监控项，下面查看对该主机的默认的监控项和这些监控项采集的值。</p><p>点击最新数据里，选择一条监控项，可以看到该条监控项目的最近检查记录和最新数据</p><p><img src="/../images/image-20240326105218121.png" alt="image-20240326105218121"></p><p>点击最右侧的图像，查看该监控项的可视化图形。</p><p><img src="/../images/image-20240326105340833.png" alt="image-20240326105340833"></p><blockquote><p>PS：我部署zabbix主要就是为了查找zabbix有没有类似的监控网卡总流量的指标，比如显示某段时间内某个网卡经过了多少数据的流量。但是搜索后发现没有这种指标，不能坐流量计费这种功能。</p></blockquote><p>参考文章</p><p><a href="https://juejin.cn/post/7085020149761179661">通过docker-compose一键部署zabbix监控平台</a></p><p><a href="https://www.zabbix.com/documentation/current/zh/manual">zh版使用手册</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CRC校验</title>
    <link href="/2024/04/20/CRC%E7%AE%80%E4%BB%8B/"/>
    <url>/2024/04/20/CRC%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CRC全程Cyclic redundancy check，即循环冗余校验。是一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。</p><p>在网络数据包的传输过程中，可能会产生一些错误，比如某个包的某一位本来是1，但是因为一些问题变成0了，那么接收数据包的接收端如何知晓数据包在传输过程中是否被更改过呢？使用CRC可以让接收端知晓数据包是否被更改过。</p><p>CRC的工作过程如下：因为CRC其实是一个散列函数，发送端在发送时将要发送的数据通过该散列函数计算，可以得到一些比较短的，固定长度的校验码也叫CRC码（比如8个字节）。发送端将校验码追加在要数据之后，一起发送给接收端。接收方接收后用相同的散列函数对数据进行计算，并将计算的结果和发送端传过来的校验码对比，如果一致则认为数据在传输过程中没有被更改，否则被更改过了。</p><h2 id="CRC在网络传输中的使用"><a href="#CRC在网络传输中的使用" class="headerlink" title="CRC在网络传输中的使用"></a>CRC在网络传输中的使用</h2><p>在计算机网络中，CRC通常被用于数据链路层的数据帧，以确保数据在物理传输过程中的完整性。几乎每个数据包都会有CRC校验码。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MSS</title>
    <link href="/2024/04/19/MSS/"/>
    <url>/2024/04/19/MSS/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>MSS全程最大报文段长度，在TCP连接建立时，收发方协商的每一个报文所能承担的最大数据长度，这个长度不包括报头。</p><p>MSS和MTU类似，都是用于定义最大数据长度的。MTU限制了数据链路层上传输的数据（网络层及网络层以上的所有层的数据大小，一般MTU的值是1500，也就是数据链路层的最大payload是1500，一般就是IP层的IP报头和IP层的payload加起来最大是1500）。</p><h2 id="MSS值的设置"><a href="#MSS值的设置" class="headerlink" title="MSS值的设置"></a>MSS值的设置</h2><p>MSS针对传输层的TCP协议，因为MSS作用于传输层，传输层在数据链路层之上，所以MSS会受到限制数据链路层payload长度的MTU的限制。</p><p>因为MTU一般是1500，通常 TCP MSS &#x3D; MTU - IP Header 长度 - TCP Header 长度。那么去掉IP报头的20个字节（通常为20个字节，IP报头的长度是可变的），去掉TCP报头的20个字节（通常为20个字节，TCP报头的长度是可变的），MSS最大可为1460字节。</p><p>MSS在发送方和接收方建立连接的传输过程中也是可以动态调整的，一般在刚建立连接时MSS比较小，然后会传输过程中会进行动态调整。</p><h2 id="MSS对网络传输的影响"><a href="#MSS对网络传输的影响" class="headerlink" title="MSS对网络传输的影响"></a>MSS对网络传输的影响</h2><p>如果MSS设置得过大，那么可能导致网络传输过程中数据包被分片，增加网络延时。如果MSS设置得过小，那么因为TCP payload占用数据包的比例太低，有用信息太少，网络传输效率会下降。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dd命令简介</title>
    <link href="/2024/02/21/dd%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/02/21/dd%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>dd命令的名字来源于“数据复制”（data duplication）的缩写，可以用于数据备份，磁盘克隆，数据转换等</p><p>以下是 <code>dd</code> 命令的一般格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">cssCopy <span class="hljs-selector-tag">code</span><br><span class="hljs-selector-tag">dd</span> <span class="hljs-selector-attr">[选项]</span><br></code></pre></td></tr></table></figure><p>主要选项：</p><ul><li><code>if=输入文件</code>：指定输入文件（input file），即源文件。</li><li><code>of=输出文件</code>：指定输出文件（output file），即目标文件。</li><li><code>bs=块大小</code>：指定每次读取或写入的数据块大小（block size）。</li><li><code>count=块数</code>：指定要处理的数据块数量。</li><li><code>skip=块数</code>：在输入文件中跳过指定数量的数据块后再开始操作。</li><li><code>seek=块数</code>：在输出文件中跳过指定数量的数据块后再开始写入。</li><li><code>status=进度输出频率</code>：指定进度输出频率，用于显示操作进度信息。</li><li><code>conv=选项</code>：指定转换操作，如 <code>conv=ucase</code>（将数据转换为大写）、<code>conv=lcase</code>（将数据转换为小写）等。</li></ul><p>示例用法：</p><ol><li><p><strong>复制文件</strong>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=inputfile <span class="hljs-attribute">of</span>=outputfile<br></code></pre></td></tr></table></figure></li><li><p><strong>从设备复制数据</strong>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=/dev/sda <span class="hljs-attribute">of</span>=image.img<br></code></pre></td></tr></table></figure></li><li><p><strong>创建指定大小的空白文件</strong>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=/dev/zero <span class="hljs-attribute">of</span>=emptyfile <span class="hljs-attribute">bs</span>=1M <span class="hljs-attribute">count</span>=100<br></code></pre></td></tr></table></figure></li><li><p><strong>备份和恢复磁盘</strong>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 备份整个磁盘</span><br>dd <span class="hljs-keyword">if</span>=<span class="hljs-regexp">/dev/</span>sda of=<span class="hljs-regexp">/path/</span>to/backup.img<br><br><span class="hljs-comment"># 恢复整个磁盘</span><br>dd <span class="hljs-keyword">if</span>=<span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/backup.img of=/</span>dev/sda<br></code></pre></td></tr></table></figure></li><li><p><strong>磁盘克隆</strong>：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">dd <span class="hljs-keyword">if</span>=<span class="hljs-regexp">/dev/</span>sda of=<span class="hljs-regexp">/dev/</span>sdb<br></code></pre></td></tr></table></figure></li><li><p>写入空字节流到文件，一般用于测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dd if=/dev/zero of=/root/test.img bs=500M<br></code></pre></td></tr></table></figure><p>这条命令会将 <code>/dev/zero</code> 设备中的数据写入到 <code>/root/test.img</code> 文件中。<code>/dev/zero</code> 是一个特殊的设备文件，它提供了一个无限连续的空字节流，即写入到这个设备的数据都是由零字节组成的。</p><p>因此，这条命令会将<strong>零字节流</strong>写入到 <code>/root/test.img</code> 文件中，其大小由 <code>bs=500M</code> 指定，表示每次写入的数据块大小为 500MB。这样就创建了一个名为 <code>test.img</code> 的文件，<strong>并将其中填充了大量的零字节。</strong>这会触发磁盘的写入操作，不会出发读取操作。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>golang的embed指令简介</title>
    <link href="/2024/02/19/golang%E7%9A%84embed%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/"/>
    <url>/2024/02/19/golang%E7%9A%84embed%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>embed直接翻译的意思就是嵌入，顾名思义go embed实现的效果就是嵌入指定的文件等内容到编译后的二进制可执行文件中。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>这个功能有很多应用场景，下面举两个例子：</p><h3 id="配置文件固定"><a href="#配置文件固定" class="headerlink" title="配置文件固定"></a>配置文件固定</h3><p>比如需要把程序的配置文件固定，又想要在运行时只运行一个二进制文件，不想再单独复制一份配置文件然后手动指定配置文件了，那么可以通过go embed将配置文件和程序打包到一个二进制文件中，运行该二进制文件即可，不需要手动指定配置文件。将程序交付给其他人时也只要交付go embed之后的二进制文件，不需要交付配置文件。不使用go embed时需要交付二进制文件和配置文件。</p><p><strong>注意一般嵌入的都是可读文件，不要把二进制文件嵌入，go embed并不适用二进制文件。</strong></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>embed是golang的编译器指令 compiler directives 中的一种</p><p>golang的编译器指令是通过在代码中嵌入类似注释的命令，来控制编译器。常见的编译器指令包括：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// go:linkname</span><br><span class="hljs-comment">// go:noinline</span><br><span class="hljs-comment">// go:noescape</span><br><span class="hljs-comment">// go:generate</span><br></code></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p> 下面是一个简单的例子（来源于Go By Example），这是main.go的内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;embed&quot;</span><br>)<br><br><span class="hljs-comment">//go:embed folder/single_file.txt</span><br><span class="hljs-keyword">var</span> fileString <span class="hljs-type">string</span><br><br><span class="hljs-comment">//go:embed folder/single_file.txt</span><br><span class="hljs-keyword">var</span> fileByte []<span class="hljs-type">byte</span><br><br><span class="hljs-comment">//go:embed folder/*.hash</span><br><span class="hljs-keyword">var</span> folder embed.FS<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-built_in">print</span>(fileString)<br><span class="hljs-built_in">print</span>(<span class="hljs-type">string</span>(fileByte))<br><br>content1, _ := folder.ReadFile(<span class="hljs-string">&quot;folder/file1.hash&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-type">string</span>(content1))<br><br>content2, _ := folder.ReadFile(<span class="hljs-string">&quot;folder/file2.hash&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-type">string</span>(content2))<br>&#125;<br></code></pre></td></tr></table></figure><p>文件目录为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">├── folder<br>│   ├── file1.hash<br>│   ├── file2.hash<br>│   └── single_file.txt<br>├── main.go<br></code></pre></td></tr></table></figure><p>folder目录下的各个文件都有各自的内容。</p><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">single_file.txt content<br>single_file.txt content<br>file1.hash content<br>file2.hash content<br></code></pre></td></tr></table></figure><p>下面关注下代码中比较重要的部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:embed folder/single_file.txt</span><br><span class="hljs-keyword">var</span> fileString <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>这里通过<code>//go:embed folder/single_file.txt</code>将<code>folder/single_file.txt</code>目录嵌入了程序，并且指定了fileString来接收文件的内容。然后可以直接<code>print(fileString)</code>打印出文件的内容。</p><p>除了指定具体的文件名，还可以用通配符来匹配所有需要的文件。比如上面的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:embed folder/*.hash</span><br><span class="hljs-keyword">var</span> folder embed.FS<br></code></pre></td></tr></table></figure><p><code>//go:embed folder/*.hash</code>指定将folder目录下所有.hash文件嵌入到程序，并用embed.FS类型的folder变量接收folder目录下所有.hash文件的内容。然后可以对folder操作，读取folder中指定文件的内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">content1, _ := folder.ReadFile(<span class="hljs-string">&quot;folder/file1.hash&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-type">string</span>(content1))<br></code></pre></td></tr></table></figure><p>此时可以打印出<code>folder/file1.hash</code>的内容。</p><p>除了直接go run运行，比较重要的用法就是go build编译后运行。编译后运行效果和上文相同。即使把编译后的二进制文件移动到其他位置，不移动folder目录，运行二进制文件得到的效果还是不变。仿佛通过embed指定的folder目录被嵌入到了二进制文件中，就算folder目录不是go程序。此时运行十分方便，没有额外冗余的部分了。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《clickhouse原理解析与应用实战》阅读笔记</title>
    <link href="/2024/02/06/clickhouse%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98/"/>
    <url>/2024/02/06/clickhouse%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p>记录的是阅读《clickhouse原理解析与应用实战》这本书是的笔记，主要记录了一些个人觉得比较重要的知识点，不是很系统性的，可能有些零散。纯主观。</p><h2 id="第1章-ClickHouse的前世今生"><a href="#第1章-ClickHouse的前世今生" class="headerlink" title="第1章 ClickHouse的前世今生"></a>第1章 ClickHouse的前世今生</h2><h3 id="1-1-传统BI系统之殇"><a href="#1-1-传统BI系统之殇" class="headerlink" title="1.1 传统BI系统之殇"></a>1.1 传统BI系统之殇</h3><h3 id="1-2-现代BI系统的新思潮"><a href="#1-2-现代BI系统的新思潮" class="headerlink" title="1.2 现代BI系统的新思潮"></a>1.2 现代BI系统的新思潮</h3><h3 id="1-3-OLAP常见架构分类"><a href="#1-3-OLAP常见架构分类" class="headerlink" title="1.3 OLAP常见架构分类"></a>1.3 OLAP常见架构分类</h3><p><strong>OLAP名为联机分析，又可以称为多维分析，</strong>是由关系 型数据库之父埃德加·科德(Edgar Frank Codd)于1993年提出的概 念。顾名思义，它指的是通过多种不同的维度审视数据，进行深层次 分析。维度可以看作观察数据的一种视角，例如人类能看到的世界是 三维的，它包含长、宽、高三个维度。直接一点理解，<strong>维度就好比是 一张数据表的字段，而多维分析则是基于这些字段进行聚合查询。</strong></p><h3 id="1-4-OLAP实现技术的演进"><a href="#1-4-OLAP实现技术的演进" class="headerlink" title="1.4 OLAP实现技术的演进"></a>1.4 OLAP实现技术的演进</h3><h3 id="1-5-一匹横空出世的黑马"><a href="#1-5-一匹横空出世的黑马" class="headerlink" title="1.5 一匹横空出世的黑马"></a>1.5 一匹横空出世的黑马</h3><h3 id="1-6-ClickHouse的发展历程"><a href="#1-6-ClickHouse的发展历程" class="headerlink" title="1.6 ClickHouse的发展历程"></a>1.6 ClickHouse的发展历程</h3><h3 id="1-7-ClickHouse的名称含义"><a href="#1-7-ClickHouse的名称含义" class="headerlink" title="1.7 ClickHouse的名称含义"></a>1.7 ClickHouse的名称含义</h3><p>在采集数据的过程中，一次页面click(点击)，会产生 一个event(事件)。至此，整个系统的逻辑就十分清晰了，那就是基 于页面的点击事件流，面向数据仓库进行OLAP分析。所以ClickHouse 的全称是Click Stream，Data WareHouse，简称ClickHouse</p><h3 id="1-8-ClickHouse适用的场景"><a href="#1-8-ClickHouse适用的场景" class="headerlink" title="1.8 ClickHouse适用的场景"></a>1.8 ClickHouse适用的场景</h3><p>在存储数据超过20万亿行的情况下， ClickHouse做到了90%的查询都能够在1秒内返回的惊人之举。</p><p>ClickHouse非常适用于商业智能领域(也就是我们所说的BI领 域)，除此之外，它也能够被广泛应用于广告流量、Web、App流量、 电信、金融、电子商务、信息安全、网络游戏、物联网等众多其他领 域。</p><h3 id="1-9-ClickHouse不适用的场景"><a href="#1-9-ClickHouse不适用的场景" class="headerlink" title="1.9 ClickHouse不适用的场景"></a>1.9 ClickHouse不适用的场景</h3><p>它 有以下几点不足。</p><p>·不支持事务。</p><p>·不擅长根据主键按行粒度进行查询(虽然支持)，故不应该把 ClickHouse当作Key-Value数据库使用。</p><p>·不擅长按行删除数据(虽然支持)。</p><h3 id="1-10-有谁在使用ClickHouse"><a href="#1-10-有谁在使用ClickHouse" class="headerlink" title="1.10 有谁在使用ClickHouse"></a>1.10 有谁在使用ClickHouse</h3><h3 id="1-11-本章小结"><a href="#1-11-本章小结" class="headerlink" title="1.11 本章小结"></a>1.11 本章小结</h3><p>本章开宗明义，介绍了作为一线从业者的我在经历BI系统从传统 转向现代的过程中的所思所想，以及如何在机缘巧合之下发现了令人 印象深刻的ClickHouse。本章抽丝剥茧，揭开了ClickHouse诞生的缘 由。原来ClickHouse背后的研发团队是来自俄罗斯的Yandex公司， Yandex为了支撑Web流量分析产品Yandex.Metrica，在历经MySQL、 Metrage和OLAPServer三种架构之后，集众家之所长，打造出了 ClickHouse。</p><h2 id="第2章-ClickHouse架构概述"><a href="#第2章-ClickHouse架构概述" class="headerlink" title="第2章 ClickHouse架构概述"></a>第2章 ClickHouse架构概述</h2><h3 id="2-1-ClickHouse的核心特性"><a href="#2-1-ClickHouse的核心特性" class="headerlink" title="2.1 ClickHouse的核心特性"></a>2.1 ClickHouse的核心特性</h3><p><strong>ClickHouse是一款MPP架构的列式存储数据库</strong></p><p>ClickHouse拥有完备的管理功能，所以它称得上是一个 DBMS(Database Management System，数据库管理系统)，而不仅是 一个数据库。作为一个DBMS，它具备了一些基本功能，如下所示。</p><p>·DDL(数据定义语言):可以动态地创建、修改或删除数据库、 表和视图，而无须重启服务。</p><p>·DML(数据操作语言):可以动态查询、插入、修改或删除数 据。</p><p>·权限控制:可以按照用户粒度设置数据库或者表的操作权限，保障数据的安全性。</p><p>·数据备份与恢复:提供了数据备份导出与导入恢复机制，满足生产环境的要求。</p><p>·分布式管理:提供集群模式，能够自动管理多个数据库节点。</p><p><strong>ClickHouse就是一款使用列式存储的数据库</strong>，数据按列进行组 织，属于同一列的数据会被保存在一起，列与列之间也会由不同的文 件分别保存(这里主要指MergeTree表引擎，表引擎会在后续章节详细 介绍)。数据默认使用LZ4算法压缩，在Yandex.Metrica的生产环境 中，数据总体的压缩比可以达到8:1(未压缩前17PB，压缩后2PB)。 列式存储除了降低IO和存储的压力之外，还为向量化执行做好了铺垫。</p><p>ClickHouse目前利用SSE4.2指令集实现向量化执行。向量化执行，可以简单地看作一项消除程序中循环的优化。</p><p>ClickHouse完全使用SQL作为查询语言(支持GROUP BY、 ORDER BY、JOIN、IN等大部分标准SQL)</p><p>ClickHouse共拥有 合并树、内存、文件、接口和其他6大类20多种表引擎。</p><p>ClickHouse也大量使用了多线程技术以实 现提速，以此和向量化执行形成互补。</p><p>HDFS、Spark、HBase和Elasticsearch这类分布式系统，都采用了 Master-Slave主从架构，由一个管控节点作为Leader统筹全局。而 ClickHouse则采用Multi-Master多主架构，集群中的每个节点角色对 等，客户端访问任意一个节点都能得到相同的效果。</p><p>ClickHouse当之无愧地阐释了“在线”二字的含义，即便 是在复杂查询的场景下，它也能够做到极快响应，且无须对数据进行 任何预处理加工。</p><p>数据分片是将数据进行横向切分，这是一种在面对海量数据的场 景下，解决存储和查询瓶颈的有效手段，是一种分治思想的体现。 <strong>ClickHouse支持分片</strong>，而分片则依赖集群。每个集群由1到多个分片组 成，而每个分片则对应了ClickHouse的1个服务节点。分片的数量上限 取决于节点数量(1个分片只能对应1个服务节点)。ClickHouse并不像其他分布式系统那样，拥有高度自动化的分片 功能。<strong>ClickHouse提供了本地表(Local Table)与分布式表 (Distributed Table)的概念</strong>。一张本地表等同于一份数据的分片。 而分布式表本身不存储任何数据，它是本地表的访问代理，其作用类 似分库中间件。借助分布式表，能够代理访问多个数据分片，从而实 现分布式查询。</p><h3 id="2-2-ClickHouse的架构设计"><a href="#2-2-ClickHouse的架构设计" class="headerlink" title="2.2 ClickHouse的架构设计"></a>2.2 ClickHouse的架构设计</h3><p><img src="/../images/image-20240118215609349.png" alt="image-20240118215609349"></p><p>虽然Column和Filed组成了数据的基本映射单元，但对应到 实际操作，它们还缺少了一些必要的信息，比如数据的类型及列的名 称。于是ClickHouse设计了<strong>Block</strong>对象，Block对象可以看作数据表的 子集。Block对象的本质是由数据对象、数据类型和列名称组成的三元 组，即Column、DataType及列名称字符串。</p><p><strong>在数据表的底层设计中并没有所谓的Table对象，它直接使用 IStorage接口指代数据表。</strong>表引擎是ClickHouse的一个显著特性，<strong>不 同的表引擎由不同的子类实现</strong>，例如IStorageSystemOneBlock(系统 表)、StorageMergeTree(合并树表引擎)和StorageTinyLog(日志 表引擎)等。</p><p>Parser和Interpreter是非常重要的两组接口:Parser分析器负责 创建AST对象;而Interpreter解释器则负责解释AST，并进一步创建查 询的执行管道。</p><p>ClickHouse主要提供两类函数——普通函数和聚合函数。普通函 数由IFunction接口定义，拥有数十种函数实现，例如 FunctionFormatDateTime、FunctionSubstring等。除了一些常见的函 数(诸如四则运算、日期转换等)之外，也不乏一些非常实用的函 数，例如网址提取函数、IP地址脱敏函数等。普通函数是没有状态 的，函数效果作用于每行数据之上。当然，在函数具体执行的过程 中，并不会一行一行地运算，而是采用向量化的方式直接作用于一整 列数据。聚合函数由IAggregateFunction接口定义，<strong>相比无状态的普通函 数，聚合函数是有状态的。</strong>以COUNT聚合函数为例，其 AggregateFunctionCount的状态使用整型UInt64记录。聚合函数的状 态支持序列化与反序列化，所以能够在分布式节点之间进行传输，以 实现增量计算。</p><h3 id="2-3-ClickHouse为何如此之快"><a href="#2-3-ClickHouse为何如此之快" class="headerlink" title="2.3 ClickHouse为何如此之快"></a>2.3 ClickHouse为何如此之快</h3><p>ClickHouse的设计则采用了自下而上 的方式。</p><p>针对同一个场景的不同状况，选择使用不同的实现方式，尽可能 将性能最大化。关于这一点，其实在前面介绍字符串查询时，针对不 同场景选择不同算法的思路就有体现了。类似的例子还有很多，例如 去重计数uniqCombined函数，会根据数据量的不同选择不同的算法: 当数据量较小的时候，会选择Array保存;当数据量中等的时候，会选 择HashSet;而当数据量很大的时候，则使用HyperLogLog算法。</p><p>ClickHouse的黑魔法并不是一项单一的技术，而是一种自底 向上的、追求极致性能的设计思路。这就是它如此之快的秘诀。</p><h3 id="2-4-本章小结"><a href="#2-4-本章小结" class="headerlink" title="2.4 本章小结"></a>2.4 本章小结</h3><p>本章我们快速浏览了世界第三大Web流量分析平台Yandex.Metrica 背后的支柱ClickHouse的核心特性和逻辑架构。通过对核心特性部分 的展示，ClickHouse如此强悍的缘由已初见端倪，列式存储、向量化 执行引擎和表引擎都是它的撒手锏。在架构设计部分，则进一步展示 了ClickHouse的一些设计思路，例如Column、Field、Block和 Cluster。了解这些设计思路，能够帮助我们更好地理解和使用 ClickHouse。最后又从另外一个角度探讨了ClickHouse如此之快的秘 诀。下一章将介绍如何安装、部署ClickHouse。</p><h2 id="第3章-安装与部署"><a href="#第3章-安装与部署" class="headerlink" title="第3章 安装与部署"></a>第3章 安装与部署</h2><h3 id="3-1-Clickhouse的安装过程"><a href="#3-1-Clickhouse的安装过程" class="headerlink" title="3.1 Clickhouse的安装过程"></a>3.1 Clickhouse的安装过程</h3><p>ClickHouse支持运行在主流64位CPU架构(X86、AArch和 PowerPC)的Linux操作系统之上，可以通过源码编译、预编译压缩 包、Docker镜像和RPM等多种方法进行安装。由于篇幅有限，本节着重 讲解离线RPM的安装方法。更多的安装方法请参阅官方手册，此处不再 赘述。</p><h3 id="3-2-客户端的访问接口"><a href="#3-2-客户端的访问接口" class="headerlink" title="3.2 客户端的访问接口"></a>3.2 客户端的访问接口</h3><p>ClickHouse的底层访问接口支持TCP和HTTP两种协议，其中，<strong>TCP 协议拥有更好的性能，其默认端口为9000，主要用于集群间的内部通 信及CLI客户端</strong>;而<strong>HTTP协议则拥有更好的兼容性，</strong>可以通过REST服务 的形式被广泛用于JAVA、Python等编程语言的客户端，其默认端口为 8123。通常而言，并不建议用户直接使用底层接口访问ClickHouse， 更为推荐的方式是通过CLI和JDBC这些封装接口，因为它们更加简单易 用。</p><p>CLI(Command Line Interface)即命令行接口，其底层是基于TCP接口进行通信 的，是通过clickhouse-client脚本运行的。它拥有两种执行模式。</p><p>交互式执行</p><p>非交互式执行</p><p>ClickHouse支持标准的JDBC协议，底层基于HTTP接口通信。使用下面的Maven依赖，即可 为Java程序引入官方提供的数据库驱动包</p><h3 id="3-3-内置的实用工具"><a href="#3-3-内置的实用工具" class="headerlink" title="3.3 内置的实用工具"></a>3.3 内置的实用工具</h3><p>ClickHouse除了提供基础的服务端与客户端程序之外，还内置了 clickhouse-local和clickhouse-benchmark两种实用工具</p><p>clickhouse-local可以独立运行大部分SQL查询，不需要依赖任何 ClickHouse的服务端程序，它可以理解成是ClickHouse服务的单机版微内 核，是一个轻量级的应用程序。</p><p>clickhouse-benchmark是基准测试的小工具，它可以自动运行SQL查询，并生成相应的运行指标报 告</p><h3 id="3-4-本章小结"><a href="#3-4-本章小结" class="headerlink" title="3.4 本章小结"></a>3.4 本章小结</h3><p>本章首先介绍了基于离线RPM包安装ClickHouse的整个过程。接着 介绍了ClickHouse的两种访问接口，其中TCP端口拥有更好的访问性 能，而HTTP端口则拥有更好的兼容性。但是在日常应用的过程中，更 推荐使用基于它们之上实现的封装接口。所以接下来，我们又分别介 绍了两个典型的封装接口，其中CLI接口是基于TCP封装的，它拥有交 互式和非交互式两种运行模式。而JDBC接口是基于HTTP封装的，是一 种标准的数据库访问接口。最后介绍了ClickHouse内置的几种实用工 具。从下一章开始将正式介绍ClickHouse的功能，首先会从数据定义 开始。</p><h2 id="第4章-数据定义"><a href="#第4章-数据定义" class="headerlink" title="第4章 数据定义"></a>第4章 数据定义</h2><p>ClickHouse支持较完备的DML语 句，包括INSERT、SELECT、UPDATE和DELETE。虽然UPDATE和DELETE可 能存在性能问题，但这些能力的提供确实丰富了各位架构师手中的筹 码，在架构设计时也能多几个选择。</p><p>作为一款完备的DBMS(数据库管理系统)，ClickHouse提供了DDL 与DML的功能，并支持大部分标准的SQL。</p><h3 id="4-1-ClickHouse的数据类型"><a href="#4-1-ClickHouse的数据类型" class="headerlink" title="4.1 ClickHouse的数据类型"></a>4.1 ClickHouse的数据类型</h3><p>基础类型只有数值、字符串和时间三种类型<strong>，没有Boolean类型， 但可以使用整型的0或1替代。</strong></p><p>字符串类型分为String、FixedString、UUID（数据库常见的主键类型）</p><p>时间类型分为DateTime、DateTime64、Date</p><p>符合类型包括Array（可以定义为array(T)或者[T]，需要明确数据类型）</p><p>Tuple：元组，由1-n个元素组成，每个元素允许设置不同的数据类型，且彼此之间不要求兼容。使用tuple(T)比如tuple(1,’a’,now())或者T比如(1,2,null,’a’)</p><p>Enum：包括Enum8和Enum16。</p><p>Nested：嵌套类型，类似go的 struct，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> nested_test &#123;<br>name String,<br>age UInt8,<br>dept Nested&#123;<br>id UInt8,<br>name String<br>&#125;<br>&#125;Engine <span class="hljs-operator">=</span> Memory;<br></code></pre></td></tr></table></figure><p>此外还有一些特殊类型：</p><p>Nullable：表示某个基础数据类型可以是Null值。</p><p>Domain：域名类型可以分为IPv4和IPv6类型。IPv4是基于UInt32封装的。</p><h3 id="4-2-如何定义数据表"><a href="#4-2-如何定义数据表" class="headerlink" title="4.2 如何定义数据表"></a>4.2 如何定义数据表</h3><p>数据表一共支持如下5种类型：</p><p>Ordinary：默认引擎，在此数据库下可以使用任意类型的表引擎。</p><p>Dictionary：字典引擎，此类数据库会自动为所有数据字典创建它们的数据表</p><p>Memory：内存引擎，用于存放临时数据。此类数据库下的数据表只会存放在内存中，不会涉及到任何磁盘操作，当服务器重启时数据会被清除。</p><p>Lazy：日志引擎，此类数据库下只能使用Log系列的表引擎。</p><p>MySQL：MySQL引擎，此类数据库下会自动拉取远端MySQL下的数据，并为它们创建MySQL表引擎的数据表。</p><p>clickhouse数据表的定义语法，是在标准SQL的基础上建立的。</p><p>使用[db_name.]参数可以为数据表指定数据库，如果不指定此参数，则默认会使用default数据库。建表语句参考：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] [db_name].table_name (<br>name1 [type] [<span class="hljs-keyword">DEFAULT</span><span class="hljs-operator">|</span>MATERIALIZED<span class="hljs-operator">|</span>ALAS expr<span class="hljs-operator">|</span>,<br>...<br>)<br></code></pre></td></tr></table></figure><p>建表可以把其他表结构复制过去，并且新表ENGINE表引擎可以和原表不同，参考：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> new_db.hots_v1 <span class="hljs-keyword">AS</span> default.hit_v1 ENGINE<span class="hljs-operator">=</span>TinyLog<br></code></pre></td></tr></table></figure><p>创建表的时候某个字段的值可以设置默认值为另一个字段的值，比如：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">CREATE TABLE dfv_v1 (<br>id String,<br>c1 DEFAULT 1000,<br>c2 String DEFAULT c1<br>) ENGINE = TinyLog<br></code></pre></td></tr></table></figure><p>使用ALTER修改字段默认值的时候并不会影响表内先前存在的数据。</p><p>clickhouse也有临时表的概念，临时表有以下特殊之处：</p><p>它的生命周期是会话绑定的，所以只支持Memory表引擎。</p><p>临时表不属于任何数据库，所以它的建表语句中，即没有数据库参数也没有表引擎参数。</p><p>临时表的优先级大于普通表。</p><p>假设数据表按照月份分区，那么数据就可以按照月份的粒度被替换更新。目前只有合并树（MergeTree）家族系列的表引擎才支持数据分区。可以用PARTITION BY指定分区键。</p><p>clickhouse拥有普通和物化两种视图，其中物化试图拥有独立的存储，而普通视图只是一层简单的查询代理，创建普通视图的完整语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] [db_name.]view_name <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> ...<br></code></pre></td></tr></table></figure><h3 id="4-3-数据库的基本操作"><a href="#4-3-数据库的基本操作" class="headerlink" title="4.3 数据库的基本操作"></a>4.3 数据库的基本操作</h3><p>如果修改某个字段的数据类型，实质上会调用相应的toType转型方法，如果当前的类型和期望的类型不能兼容，那么修改操作会失败。</p><h3 id="4-4-数据库的基本操作"><a href="#4-4-数据库的基本操作" class="headerlink" title="4.4 数据库的基本操作"></a>4.4 数据库的基本操作</h3><h3 id="4-5-分布式DDL执行"><a href="#4-5-分布式DDL执行" class="headerlink" title="4.5 分布式DDL执行"></a>4.5 分布式DDL执行</h3><p>将一条普通的DDL语句转换成分布式执行非常简单，只需要加上ON CLUSTER cluster_name声明即可。</p><h3 id="4-6-数据的写入"><a href="#4-6-数据的写入" class="headerlink" title="4.6 数据的写入"></a>4.6 数据的写入</h3><h3 id="4-7-数据的删除与修改"><a href="#4-7-数据的删除与修改" class="headerlink" title="4.7 数据的删除与修改"></a>4.7 数据的删除与修改</h3><p>clickhouse提供了DELETE和UPDATE的能力，这类操作被称为Mutation查询，它可以看作ALTER语句的变种。DELETE操作是一个异步的后台执行动作。</p><h3 id="4-8-本章小结"><a href="#4-8-本章小结" class="headerlink" title="4.8 本章小结"></a>4.8 本章小结</h3><p>通过对本章的学习，我们知道了ClickHouse的数据类型是由基础 类型、复合类型和特殊类型组成的。基础类型相比常规数据库显得精 简干练;复合类型很实用，常规数据库通常不具备这些类型;而特殊 类型的使用场景较少。同时我们也掌握了数据库、数据表、临时表、 分区表和视图的基本操作以及对元数据和分区的基本操作。最后我们 还了解到在ClickHouse中如何写入、修改和删除数据。本章的内容为 介绍后续知识点打下了坚实的基础。下一章我们将介绍数据字典。</p><h2 id="第5章-数据字典"><a href="#第5章-数据字典" class="headerlink" title="第5章 数据字典"></a>第5章 数据字典</h2><p>数据字典是ClickHouse提供的一种非常简单、实用的存储媒介， 它以键值和属性映射的形式定义数据。</p><h3 id="5-1-内置字典"><a href="#5-1-内置字典" class="headerlink" title="5.1 内置字典"></a>5.1 内置字典</h3><p>ClickHouse目前只有一种内置字典——Yandex.Metrica字典。从 名称上可以看出，这是用在ClickHouse自家产品上的字典，而它的设 计意图是快速存取geo地理数据。但较为遗憾的是，由于版权原因 Yandex并没有将geo地理数据开放出来。这意味着ClickHouse目前的内 置字典，只是提供了字典的定义机制和取数函数，而没有内置任何现 成的数据。所以内置字典的现状较为尴尬，需要遵照它的字典规范自 行导入数据。</p><h3 id="5-2-外部扩展字典"><a href="#5-2-外部扩展字典" class="headerlink" title="5.2 外部扩展字典"></a>5.2 外部扩展字典</h3><p>外部扩展字典是以插件形式注册到ClickHouse中的，由用户自行 定义数据模式及数据来源。</p><h3 id="5-3-本章小结"><a href="#5-3-本章小结" class="headerlink" title="5.3 本章小结"></a>5.3 本章小结</h3><p>通过对本章的学习，我们知道了ClickHouse拥有内置与扩展两类 数据字典，同时也掌握了数据字典的配置、更新和查询的基本操作。 在内置字典方面，目前只有一种YM字典且需要自行准备数据，而扩展 字典是更加常用的字典类型。在扩展字典方面，目前拥有7种类型，其 中flat、hashed和range_hashed依次拥有最高的性能。数据字典能够 有效地帮助我们消除不必要的JOIN操作(例如根据ID转名称)，优化 SQL查询，为查询性能带来质的提升。下一章将开始介绍MergeTree表 引擎的核心原理。</p><h2 id="第6章-MergeTree原理解析"><a href="#第6章-MergeTree原理解析" class="headerlink" title="第6章 MergeTree原理解析"></a>第6章 MergeTree原理解析</h2><p>ClickHouse拥有非常庞大的表引 擎体系，截至本书完成时，其共拥有合并树、外部存储、内存、文 件、接口和其他6大类20多种表引擎。</p><p>只有合 并树系列的表引擎才支持主键索引、数据分区、数据副本和数据采样 这些特性，同时也只有此系列的表引擎支持ALTER相关操作。</p><h3 id="6-1-MergeTree的创建方式与存储结构"><a href="#6-1-MergeTree的创建方式与存储结构" class="headerlink" title="6.1 MergeTree的创建方式与存储结构"></a>6.1 MergeTree的创建方式与存储结构</h3><p>MergeTree在写入一批数据时，数据总会以数据片段的形式写入磁 盘，且数据片段不可修改。为了避免片段过多，ClickHouse会通过后 台线程，定期合并这些数据片段，属于相同分区的数据片段会被合成 一个新的片段。这种数据片段往复合并的特点，也正是合并树名称的 由来。</p><p>创建MergeTree时可以指定参数SETTINGS，SETTINGS:index_granularity [选填]: index_granularity对于MergeTree而言是一项非常重要的参数，它表 示索引的粒度，默认值为8192。也就是说，MergeTree的索引在默认情 况下，每间隔8192行数据才生成一条索引</p><p>MergeTree表引擎中的数据是拥有物理存储的，数据会按照分区目 录的形式保存到磁盘之上</p><p><img src="/../images/image-20240123222834591.png" alt="image-20240123222834591"></p><h3 id="6-2-数据分区"><a href="#6-2-数据分区" class="headerlink" title="6.2 数据分区"></a>6.2 数据分区</h3><p>MergeTree伴随着每一批数据的写入(一次INSERT语句)， MergeTree都会生成一批新的分区目录。</p><h3 id="6-3-一级索引"><a href="#6-3-一级索引" class="headerlink" title="6.3 一级索引"></a>6.3 一级索引</h3><p>MergeTree的主键使用PRIMARY KEY定义，待主键定义之后， MergeTree会依据index_granularity间隔(默认8192行)，为数据表 生成一级索引并保存至primary.idx文件内，索引数据按照PRIMARY KEY排序。相比使用PRIMARY KEY定义，更为常见的简化形式是通过 ORDER BY指代主键。在此种情形下，PRIMARY KEY与ORDER BY定义相 同，所以索引(primary.idx)和数据(.bin)会按照完全相同的规则 排序。对于PRIMARY KEY与ORDER BY定义有差异的应用场景在 SummingMergeTree引擎章节部分会所有介绍，而关于数据文件的更多 细节，则留在稍后的6.5节介绍，本节重点讲解一级索引部分。</p><p>在稠密索引中每一行索引标记都会对应到一行具体的 数据记录。而在稀疏索引中，每一行索引标记对应的是一段数据，而 不是一行。</p><h3 id="6-4-二级索引"><a href="#6-4-二级索引" class="headerlink" title="6.4 二级索引"></a>6.4 二级索引</h3><p>除了一级索引之外，MergeTree同样支持二级索引。二级索引又称 跳数索引，由数据的聚合信息构建而成。根据索引类型的不同，其聚 合信息的内容也不同。跳数索引的目的与一级索引一样，也是帮助查 询时减少数据扫描的范围。</p><p>MergeTree共支持4种跳数索引，分别是minmax、set、 ngrambf_v1和tokenbf_v1。一张数据表支持同时声明多个跳数索引。</p><h3 id="6-5-数据存储"><a href="#6-5-数据存储" class="headerlink" title="6.5 数据存储"></a>6.5 数据存储</h3><p>在MergeTree中，数据按列存储。而具体到每个列字段，数据也是 独立存储的，每个列字段都拥有一个与之对应的.bin数据文件。也正 是这些.bin文件，最终承载着数据的物理存储。数据文件以分区目录 的形式被组织存放，所以在.bin文件中只会保存当前分区片段内的这 一部分数据，其具体组织形式已经在图6-2中展示过。按列独立存储的 设计优势显而易见:一是可以更好地进行数据压缩(相同类型的数据 放在一起，对压缩更加友好)，二是能够最小化数据扫描的范围。</p><p>一个.bin文件是由1至多个压缩数据块组成的，每 个压缩块大小在64KB~1MB之间。多个压缩数据块之间，按照写入顺序首尾相接，紧 密地排列在一起</p><h3 id="6-6-数据标记"><a href="#6-6-数据标记" class="headerlink" title="6.6 数据标记"></a>6.6 数据标记</h3><p>如果把MergeTree比作一本书，primary.idx一级索引好比这本书 的一级章节目录，.bin文件中的数据好比这本书中的文字，那么数据 标记(.mrk)会为一级章节目录和具体的文字之间建立关联。对于数据 标记而言，它记录了两点重要信息:其一，是一级章节对应的页码信 息;其二，是一段文字在某一页中的起始位置信息。这样一来，通过 数据标记就能够很快地从一本书中立即翻到关注内容所在的那一页， 并知道从第几行开始阅读。</p><p>读取压缩数据块: 在查询某一列数据时，MergeTree无须一 次性加载整个.bin文件，而是可以根据需要，只加载特定的压缩数据 块。而这项特性需要借助标记文件中所保存的压缩文件中的偏移量。</p><p>读取数据: 在读取解压后的数据时，MergeTree并不需要一 次性扫描整段解压数据，它可以根据需要，以index_granularity的粒 度加载特定的一小段。为了实现这项特性，需要借助标记文件中保存 的解压数据块中的偏移量。</p><h3 id="6-7-对于分区、索引、标记和压缩数据的协同总结"><a href="#6-7-对于分区、索引、标记和压缩数据的协同总结" class="headerlink" title="6.7 对于分区、索引、标记和压缩数据的协同总结"></a>6.7 对于分区、索引、标记和压缩数据的协同总结</h3><p>分区、索引、标记和压缩数据，就好比是MergeTree给出的一套组 合拳，使用恰当时威力无穷。那么，在依次介绍了各自的特点之后， 现在将它们聚在一块进行一番总结。接下来，就分别从写入过程、查 询过程，以及数据标记与压缩数据块的三种对应关系的角度展开介 绍。</p><p>数据查询的本质，可以看作一个不断减小数据范围的过程。在最 理想的情况下，MergeTree首先可以依次借助分区索引、一级索引和二 级索引，将数据扫描范围缩至最小。然后再借助数据标记，将需要解 压与计算的数据范围缩至最小。</p><h3 id="6-8-本章小结"><a href="#6-8-本章小结" class="headerlink" title="6.8 本章小结"></a>6.8 本章小结</h3><p>本章全方面、立体地解读了MergeTree表引擎的工作原理:首先， 解释了MergeTree的基础属性和物理存储结构;接着，依次介绍了数据 分区、一级索引、二级索引、数据存储和数据标记的重要特性;最 后，结合实际样例数据，进一步总结了MergeTree上述特性在一起协同 时的工作过程。掌握本章的内容，即掌握了合并树系列表引擎的精 髓。下一章将进一步介绍MergeTree家族中其他常见表引擎的具体使用 方法。</p><h2 id="第7章-MergeTree系列表引擎"><a href="#第7章-MergeTree系列表引擎" class="headerlink" title="第7章 MergeTree系列表引擎"></a>第7章 MergeTree系列表引擎</h2><p>目前在ClickHouse中，按照特点可以将表引擎大致分成6个系列， 分别是合并树、外部存储、内存、文件、接口和其他，每一个系列的 表引擎都有着独自的特点与使用场景。在它们之中，最为核心的当属 MergeTree系列，因为它们拥有最为强大的性能和最广泛的使用场合。</p><p>经过上一章的介绍，大家应该已经知道了MergeTree有两层含义: 其一，表示合并树表引擎家族;其二，表示合并树家族中最基础的 MergeTree表引擎。而在整个家族中，除了基础表引擎MergeTree之 外，常用的表引擎还有ReplacingMergeTree、SummingMergeTree、 AggregatingMergeTree、CollapsingMergeTree和 VersionedCollapsingMergeTree。每一种合并树的变种，在继承了基 础MergeTree的能力之后，又增加了独有的特性。其名称中的“合并” 二字奠定了所有类型MergeTree的基因，它们的所有特殊逻辑，都是在 触发合并的过程中被激活的。在本章后续的内容中，会逐一介绍它们 的特点以及使用方法。</p><h3 id="7-1-MergeTree"><a href="#7-1-MergeTree" class="headerlink" title="7.1 MergeTree"></a>7.1 MergeTree</h3><p>MergeTree作为家族系列最基础的表引擎，提供了数据分区、一级 索引和二级索引等功能。对于它们的运行机理，在上一章中已经进行 了详细介绍。本节将进一步介绍MergeTree家族独有的另外两项能力 ——数据TTL与存储策略。</p><p>TTL即Time To Live，顾名思义，它表示数据的存活时间。</p><p>再次查询ttl_table_v1则能够看到，由于第一行数据满足TTL过期条件(当前系统时间 &gt;&#x3D;create_time+10秒)，它们的code和type列会被还原为数据类型的默认值</p><h3 id="7-2-ReplacingMergeTree"><a href="#7-2-ReplacingMergeTree" class="headerlink" title="7.2 ReplacingMergeTree"></a>7.2 ReplacingMergeTree</h3><p>虽然MergeTree拥有主键，但是它的主键却没有唯一键的约束。这 意味着即便多行数据的主键相同，它们还是能够被正常写入。在某些 使用场合，用户并不希望数据表中含有重复的数据。</p><p>注意这里的ORDER BY是去除重复数据的关键，排序键ORDER BY所 声明的表达式是后续作为判断数据是否重复的依据。在这个例子中， 数据会基于id和code两个字段去重。</p><h3 id="7-3-SummingMergeTree"><a href="#7-3-SummingMergeTree" class="headerlink" title="7.3 SummingMergeTree"></a>7.3 SummingMergeTree</h3><p>如果需要同时定义ORDER BY与PRIMARY KEY，通常只有一种可能， 那便是明确希望ORDER BY与PRIMARY KEY不同。这种情况通常只会在使 用SummingMergeTree或AggregatingMergeTree时才会出现。</p><p>如果同时声明了ORDER BY与PRIMARY KEY，MergeTree会强制要求 PRIMARY KEY列字段必须是ORDER BY的前缀。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (B、C)<br><span class="hljs-keyword">PRIMARY</span> KEY B<br></code></pre></td></tr></table></figure><p>这里的ORDER BY是一项关键配置，SummingMergeTree在进行 数据汇总时，会根据ORDER BY表达式的取值进行聚合操作。</p><p>在第一个分区内，同为A001:wuhan的两条数据汇总 成了一行。其中，v1和v2被SUM汇总，不在汇总字段之列的create_time 则选取了同组内第一行数据的取值。</p><h3 id="7-4-AggregatingMergeTree"><a href="#7-4-AggregatingMergeTree" class="headerlink" title="7.4 AggregatingMergeTree"></a>7.4 AggregatingMergeTree</h3><p>有过数据仓库建设经验的读者一定知道“数据立方体”的概念，这是一个在数据仓库领域十分常见的模型。它通过以空间换时间的方法提升查询性能，将需要聚合的数据预先计算出来，并将结果保存起来。在后续进行聚合查询的时候，直接使用结果数据。</p><p>AggregatingMergeTree更为常见的应用方式是结合物化视图使用，将它作为物化视 图的表引擎。而这里的物化视图是作为其他数据表上层的一种查询视图，</p><h3 id="7-5-CollapsingMergeTree"><a href="#7-5-CollapsingMergeTree" class="headerlink" title="7.5 CollapsingMergeTree"></a>7.5 CollapsingMergeTree</h3><p>对于ClickHouse这类高性能分析型数据 库而言，对数据源文件修改是一件非常奢侈且代价高昂的操作。相较于直 接修改源文件，它们会将修改和删除操作转换成新增操作，即以增代删。</p><h3 id="7-6-VersionedCollapsingMergeTree"><a href="#7-6-VersionedCollapsingMergeTree" class="headerlink" title="7.6 VersionedCollapsingMergeTree"></a>7.6 VersionedCollapsingMergeTree</h3><h3 id="7-7-各种MergeTree之间的关系总结"><a href="#7-7-各种MergeTree之间的关系总结" class="headerlink" title="7.7 各种MergeTree之间的关系总结"></a>7.7 各种MergeTree之间的关系总结</h3><p>我们可以使用继承和组合这两种关系来理解整个MergeTree。</p><p><img src="/../images/image-20240124215927212.png" alt="image-20240124215927212"></p><p>在具体的实现逻辑部分，7种MergeTree共用一个主 体，在触发Merge动作时，它们调用了各自独有的合并逻辑。</p><h3 id="7-8-本章小结"><a href="#7-8-本章小结" class="headerlink" title="7.8 本章小结"></a>7.8 本章小结</h3><p>本章全面介绍了MergeTree表引擎系列，通过本章我们知道了，合 并树家族除了基础表引擎MergeTree之外，还有另外5种常用的变种来 引擎。对于MergeTree而言，继上一章介绍了它的核心工作原理之后， 本章又进一步介绍了它的TTL机制和多数据块存储。除此之外，我们还 知道了MergeTree各个变种表引擎的特点和使用方法，包括支持数据去 重的ReplacingMergeTree、支持预先聚合计算的SummingMergeTree与 AggregatingMergeTree，以及支持数据更新且能够折叠数据的 CollapsingMergeTree与VersionedCollapsingMergeTree。这些 MergeTree系列的表引擎，都用ORDER BY作为条件Key，在分区合并时 触发各自的处理逻辑。下一章将进一步介绍其他常见表引擎的具体使 用方法。</p><h2 id="第8章-其他常见类型表引擎"><a href="#第8章-其他常见类型表引擎" class="headerlink" title="第8章 其他常见类型表引擎"></a>第8章 其他常见类型表引擎</h2><p>本章将继续介绍其他常见类型的表引擎，它们以表作为接口，极 大地丰富了ClickHouse的查询能力。这些表引擎各自特点突出，或是 独立地应用于特定场景，或是能够与MergeTree一起搭配使用。例如， 外部存储系列的表引擎，能够直接读取其他系统的数据，ClickHouse 自身只负责元数据管理，类似使用外挂表的形式;内存系列的表引 擎，能够充当数据分发的临时存储载体或消息通道;日志文件系列的 表引擎，拥有简单易用的特点;接口系列表引擎，能够串联已有的数 据表，起到黏合剂的作用。在本章后续的内容中，会按照表引擎的分 类逐个进行介绍，包括它们的特点和使用方法。</p><h3 id="8-1-外部存储类型"><a href="#8-1-外部存储类型" class="headerlink" title="8.1 外部存储类型"></a>8.1 外部存储类型</h3><p>顾名思义，外部存储表引擎直接从其他的存储系统读取数据，例 如直接读取HDFS的文件或者MySQL数据库的表。这些表引擎只负责元数 据管理和数据查询，而它们自身通常并不负责数据的写入，数据文件 直接由外部系统提供。</p><p>HDFS是一款分布式文件系统，堪称Hadoop生态的基石，</p><p>MySQL表引擎可以与MySQL数据库中的数据表建立映射，并通过SQL向其发起远程查询，包括 SELECT和INSERT，它的声明方式如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ENGINE <span class="hljs-operator">=</span> MySQL(<span class="hljs-string">&#x27;host:port&#x27;</span>, <span class="hljs-string">&#x27;database&#x27;</span>, <span class="hljs-string">&#x27;table&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>[, replace_query, <span class="hljs-string">&#x27;on_duplicate_clause&#x27;</span>])<br></code></pre></td></tr></table></figure><p>File表引擎能够直接读取本地文件的数据，通常被作为一种扩充手段 来使用。</p><p>即便是手动创建的表目录和数据文件，仍然可以对数据表插入数据，</p><h3 id="8-2-内存类型"><a href="#8-2-内存类型" class="headerlink" title="8.2 内存类型"></a>8.2 内存类型</h3><p>接下来将要介绍的几款表引擎，都是面向内存查询的，数据会从 内存中被直接访问，所以它们被归纳为内存类型。</p><p>Memory表引擎直接将数据保存在内存中，数据既不会被压缩也不 会被格式转换，数据在内存中保存的形态与查询时看到的如出一辙。 正因为如此，当ClickHouse服务重启的时候，Memory表内的数据会全 部丢失。所以在一些场合，会将Memory作为测试表使用，很多初学者 在学习ClickHouse的时候所写的Hello World程序很可能用的就是 Memory表。由于不需要磁盘读取、序列化以及反序列等操作，所以 Memory表引擎支持并行查询，并且在简单的查询场景中能够达到与 MergeTree旗鼓相当的查询性能(一亿行数据量以内)。</p><p>Memory表更为广 泛的应用场景是在ClickHouse的内部，它会作为集群间分发数据的存 储载体来使用。例如在分布式IN查询的场合中，会利用Memory临时表 保存IN子句的查询结果，并通过网络将它传输到远端节点。</p><p>Buffer表引擎完全使用内存装载数据，不支持文件的持久化存储，所以当服务重启之后，表内的 数据会被清空。Buffer表引擎不是为了面向查询场景而设计的，它的作用是充当缓冲区的角色。假设 有这样一种场景，我们需要将数据写入目标MergeTree表A，由于写入的并发数很高，这可能会导致 MergeTree表A的合并速度慢于写入速度(因为每一次INSERT都会生成一个新的分区目录)。此时，可 以引入Buffer表来缓解这类问题，<strong>将Buffer表作为数据写入的缓冲区。数据首先被写入Buffer表，当 满足预设条件时，Buffer表会自动将数据刷新到目标表</strong></p><h3 id="8-3-日志类型"><a href="#8-3-日志类型" class="headerlink" title="8.3 日志类型"></a>8.3 日志类型</h3><p>TinyLog是日志家族系列中性能最低的表引擎，它的存储结构由数 据文件和元数据两部分组成。其中，数据文件是按列独立存储的，也 就是说每一个列字段都拥有一个与之对应的.bin文件。这种结构和 MergeTree有些相似，但是TinyLog既不支持分区，也没有.mrk标记文 件。由于没有标记文件，它自然无法支持.bin文件的并行读取操作， 所以它只适合在非常简单的场景下使用。</p><p>由于拥有数据标记且各列数据独立存储，所以Log既能够支持 并行查询，又能够按列按需读取，</p><h3 id="8-4-接口类型"><a href="#8-4-接口类型" class="headerlink" title="8.4 接口类型"></a>8.4 接口类型</h3><p>有这么一类表引擎，它们自身并不存储任何数据，而是像黏合剂一样可以整合其他的数据表。在使用这类表引擎的时候，不用担心底层的复杂性，它们就像接口一样，为用户提供了统一的访问界面，所以我将它们归为接口类表引擎。</p><p>被代理查询的数据表被要求处于同一个数据库内，且拥有相同的 表结构，但是它们可以使用不同的表引擎以及不同的分区定义(对于 MergeTree而言)。</p><p>Dictionary表引擎是数据字典的一层代理封装，它可以取代字典函数，让用户 通过数据表查询字典。字典内的数据被加载后，会全部保存到内存中，所以使用 Dictionary表对字典性能不会有任何影响。声明Dictionary表的方式如下所示:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">ENGINE</span> <span class="hljs-operator">=</span> Dictionary(dict_name)<br></code></pre></td></tr></table></figure><p>其中，dict_name对应一个已被加载的字典名称，例如下面的例子:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss">  <span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-built_in">tb_test_flat_dict</span> (<br>       id UInt64,<br><span class="hljs-built_in">code</span> <span class="hljs-keyword">String</span>,<br>       name <span class="hljs-keyword">String</span><br>   )Engine = <span class="hljs-built_in">Dictionary</span>(test_flat_dict);<br></code></pre></td></tr></table></figure><p>tb_test_flat_dict等同于数据字典test_flat_dict的代理表</p><p>在数据库领域，当面对海量业务数据的时候，一种主流的做法是 实施Sharding方案，即将一张数据表横向扩展到多个数据库实例。其 中，每个数据库实例称为一个Shard分片，数据在写入时，需要按照预 定的业务规则均匀地写至各个Shard分片;而在数据查询时，则需要在 每个Shard分片上分别查询，最后归并结果集。</p><h3 id="8-5-其他类型"><a href="#8-5-其他类型" class="headerlink" title="8.5 其他类型"></a>8.5 其他类型</h3><p>Live View是一种特殊的视图，虽然它并不属于表引擎，但是因为 它与数据表息息相关，所以我还是把Live View归类到了这里</p><p>Null表引擎的功能与作用，与Unix系统的空设备&#x2F;dev&#x2F;null很相 似。如果用户向Null表写入数据，系统会正确返回，但是Null表会自 动忽略数据，永远不会将它们保存。如果用户向Null表发起查询，那 么它将返回一张空表。</p><h3 id="8-6-本章小结"><a href="#8-6-本章小结" class="headerlink" title="8.6 本章小结"></a>8.6 本章小结</h3><p>本章全面介绍了除第7章介绍的表引擎之外的其他类型的表引擎， 知道了MergeTree家族表引擎之外还有另外5类表引擎。这些表引擎丰 富了ClickHouse的使用场景，扩充了ClickHouse的能力界限。</p><p>外部存储类型的表引擎与Hive的外挂表很相似，它们只负责元数 据管理和数据查询，自身并不负责数据的生成，数据文件直接由外部 系统维护。它们可以直接读取HDFS、本地文件、常见关系型数据库和 KafKa的数据。</p><p>内存类型的表引擎中的数据是常驻内存的，所以它们拥有堪比 MergeTree的查询性能(1亿数据量以内)。其中Set和Join表引擎拥有 物理存储，数据在写入内存的同时也会被刷新到磁盘;而Memory和 Buffer表引擎在服务重启之后，数据便会被清空。内存类表引擎是一 把双刃剑，在数据大于1亿的场景下不建议使用内存类表引擎。</p><p>日志类型表引擎适用于数据量在100万以下，并且是“一次”写入 多次查询的场景。其中TinyLog、StripeLog和Log的性能依次升高的。</p><p>接口类型的表引擎自身并不存储任何数据，而是像黏合剂一样可 以整合其他的数据表。其中Merge表引擎能够合并查询任意张表结构相 同的数据表;Dictionary表引擎能够代理查询数据字典;而 Distributed表引擎的作用类似分布式数据库的分表中间件，能够帮助 用户简化数据的分发和路由工作。</p><p>其他类型的表引擎用途迥异。其中Live View是一种特殊的视图， 能够对SQL查询进行准实时监听;Null表引擎类似于Unix系统的空设 备&#x2F;dev&#x2F;null，通常与物化视图搭配使用;而URL表引擎类似于HTTP客 户端，能够代理调用远端的REST服务。</p><h2 id="第9章-数据查询"><a href="#第9章-数据查询" class="headerlink" title="第9章 数据查询"></a>第9章 数据查询</h2><p>ClickHouse完全使用SQL作为查询语言，能够以 SELECT查询语句的形式从数据库中选取数据，</p><p>例如在绝大部分场景中，都应该避免使用SELECT * 形式来查询数据，因为通配符*对于采用列式存储的ClickHouse而言没有任何好处。假如面对一张拥有数 百个列字段的数据表，下面这两条SELECT语句的性能可能会相差100倍之多:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> datasets.hits_v1;<br><span class="hljs-keyword">SELECT</span> WatchID <span class="hljs-keyword">FROM</span> datasets.hits_v1;<br></code></pre></td></tr></table></figure><h3 id="9-1-WITH子句"><a href="#9-1-WITH子句" class="headerlink" title="9.1 WITH子句"></a>9.1 WITH子句</h3><h3 id="9-2-FROM子句"><a href="#9-2-FROM子句" class="headerlink" title="9.2 FROM子句"></a>9.2 FROM子句</h3><p>FROM子句表示从何处读取数据，目前支持如下3种形式。 (1)从数据表中取数:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> WatchID <span class="hljs-keyword">FROM</span> hits_v1<br></code></pre></td></tr></table></figure><p>(2)从子查询中取数:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> MAX_WatchID<br><span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(WatchID) <span class="hljs-keyword">AS</span> MAX_WatchID <span class="hljs-keyword">FROM</span> hits_v1)<br></code></pre></td></tr></table></figure><p>(3)从表函数中取数:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">number</span> <span class="hljs-keyword">FROM</span> numbers(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h3 id="9-3-SAMPLE子句"><a href="#9-3-SAMPLE子句" class="headerlink" title="9.3 SAMPLE子句"></a>9.3 SAMPLE子句</h3><p>SAMPLE子句能够实现数据采样的功能，使查询仅返回采样数据而不是全部数据， 从而有效减少查询负载。</p><h3 id="9-4-ARRAY-JOIN子句"><a href="#9-4-ARRAY-JOIN子句" class="headerlink" title="9.4 ARRAY JOIN子句"></a>9.4 ARRAY JOIN子句</h3><p>ARRAY JOIN子句允许在数据表的内部，与数组或嵌套类型的字段进行JOIN操作，从而将一行数组展开 为多行。</p><h3 id="9-5-JOIN子句"><a href="#9-5-JOIN子句" class="headerlink" title="9.5 JOIN子句"></a>9.5 JOIN子句</h3><p>JOIN子句可以对左右两张表的数据进行连接，这是最常用的查询 子句之一。它的语法包含连接精度和连接类型两部分。</p><p>OUTER JOIN表示外连接，它可以进一步细分为左外连接 (LEFT)、右外连接(RIGHT)和全外连接(FULL)三种形式。</p><p>CROSS JOIN表示交叉连接，它会返回左表与右表两个数据集合的 笛卡儿积。也正因为如此，CROSS JOIN不需要声明JOIN KEY，因为结 果会包含它们的所有组合</p><p>为了能够优化JOIN查询性能，首先应该遵循左大右小的原则 ，即 将数据量小的表放在右侧。</p><h3 id="9-7-GROUP-BY子句"><a href="#9-7-GROUP-BY子句" class="headerlink" title="9.7 GROUP BY子句"></a>9.7 GROUP BY子句</h3><p>GROUP BY又称聚合查询，是最常用的子句之一，它是让 ClickHouse最凸显卓越性能的地方。在GROUP BY后声明的表达式，通 常称为聚合键或者Key，数据会按照聚合键进行聚合。在ClickHouse的 聚合查询中，SELECT可以声明聚合函数和列字段，如果SELECT后只声 明了聚合函数，则可以省略GROUP BY关键字:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(data_compressed_bytes) <span class="hljs-keyword">AS</span> compressed , <br><span class="hljs-built_in">SUM</span>(data_uncompressed_bytes) <span class="hljs-keyword">AS</span> uncompressed<br><span class="hljs-keyword">FROM</span> system.parts<br></code></pre></td></tr></table></figure><p>在某些场合下，可以借助any、max和min等聚合函数访问聚合 键之外的列字段</p><p>ROLLUP能够按照聚合键从右向左上卷数据，基于聚合 函数依次生成分组小计和总计。如果设聚合键的个数为n，则最终会生 成小计的个数为n+1。例如执行下面的语句:</p><p><img src="/../images/image-20240125213243573.png" alt="image-20240125213243573"></p><p>可以看到在最终返回的结果中，附加返回了显示名称为空的小计 汇总行，包括所有表分区磁盘大小的汇总合计以及每张table内所有分 区大小的合计信息。</p><h3 id="9-8-HAVING子句"><a href="#9-8-HAVING子句" class="headerlink" title="9.8 HAVING子句"></a>9.8 HAVING子句</h3><p>HAVING子句需要与GROUP BY同时出现，不能单独使用。它能够在 聚合计算之后实现二次过滤数据。例如下面的语句是一条普通的聚合 查询，会按照table分组并计数:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>() <span class="hljs-keyword">FROM</span> system.parts <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">table</span> <br><span class="hljs-comment">--执行计划</span><br>Expression<br>       Expression<br>           Aggregating<br>               Concat<br>                   Expression<br><span class="hljs-keyword">One</span><br></code></pre></td></tr></table></figure><p>现在增加HAVING子句后再次执行上述操作，则数据在按照table聚 合之后，进一步截掉了table&#x3D;’query_v3’的部分。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>() <span class="hljs-keyword">FROM</span> system.parts <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;query_v3&#x27;</span> <br><span class="hljs-comment">--执行计划</span><br>Expression<br>       Expression<br>           <span class="hljs-keyword">Filter</span><br>               Aggregating<br>                   Concat<br>                       Expression<br>                           <span class="hljs-keyword">One</span><br></code></pre></td></tr></table></figure><p>观察两次查询的执行计划，可以发现HAVING的本质是在聚合之后 增加了Filter过滤动作。</p><p>假设现在需要按照table分组聚 合，并且返回均值bytes_on_disk大于10 000字节的数据表，在这种情 形下需要使用HAVING子句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">table</span> ,<span class="hljs-built_in">avg</span>(bytes_on_disk) <span class="hljs-keyword">as</span> avg_bytes<br>   <span class="hljs-keyword">FROM</span> system.parts <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">table</span><br>   <span class="hljs-keyword">HAVING</span> avg_bytes <span class="hljs-operator">&gt;</span> <span class="hljs-number">10000</span><br>┌─<span class="hljs-keyword">table</span>─────┬───avg_bytes───┐<br>│ hits_v1       │<span class="hljs-number">730190752</span> │<br>└─────────┴────────────┘<br></code></pre></td></tr></table></figure><p>这是因为WHERE的执行优先级大于GROUP BY，所以如果需要按照聚 合值进行过滤，就必须借助HAVING实现。</p><h3 id="9-9-ORDER-BY子句"><a href="#9-9-ORDER-BY子句" class="headerlink" title="9.9 ORDER BY子句"></a>9.9 ORDER BY子句</h3><p>对于数据中NULL值的排序，目前ClickHouse拥有NULL值最后和 NULL值优先两种策略，可以通过NULLS修饰符进行设置:</p><p>NULLS LAST</p><p>NULL值排在最后，这也是默认行为，修饰符可以省略。在这种情 形下，数据的排列顺序为其他值(value)→NaN→NULL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 顺序是value -&gt; NaN -&gt; NULL</span><br><span class="hljs-keyword">WITH</span> arrayJoin([<span class="hljs-number">30</span>,<span class="hljs-keyword">null</span>,<span class="hljs-number">60.5</span>,<span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>,<span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>,<span class="hljs-number">-1</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>,<span class="hljs-number">30</span>,<span class="hljs-keyword">null</span>,<span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>]) <span class="hljs-keyword">AS</span> v1 <span class="hljs-keyword">SELECT</span> v1 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> v1 <span class="hljs-keyword">DESC</span> NULLS <span class="hljs-keyword">LAST</span><br>┌───v1─┐<br>│ inf │<br>│ <span class="hljs-number">60.5</span> │<br>│ <span class="hljs-number">30</span> │<br>│    <span class="hljs-number">30</span>  │<br>│  <span class="hljs-operator">-</span>inf  │<br>│   nan  │<br>│   nan  │<br>│  <span class="hljs-keyword">NULL</span>  │<br>│  <span class="hljs-keyword">NULL</span>  │<br>└─────┘<br></code></pre></td></tr></table></figure><p>NULLS FIRST</p><p>NULL值排在最前，在这种情形下，数据的排列顺序为NULL→NaN→ 其他值(value)</p><h3 id="9-10-LIMIT-BY子句"><a href="#9-10-LIMIT-BY子句" class="headerlink" title="9.10 LIMIT BY子句"></a>9.10 LIMIT BY子句</h3><p>LIMIT BY子句和大家常见的LIMIT所有不同，它运行于ORDER BY之 后和LIMIT之前，能够按照指定分组，最多返回前n行数据(如果数据 少于n行，则按实际数量返回)，常用于TOP N的查询场景。LIMIT BY 的常规语法如下:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">LIMIT</span> n <span class="hljs-keyword">BY</span> express<br></code></pre></td></tr></table></figure><p>例如执行下面的语句后便能够在基于数据库和数据表分组的情况 下，查询返回数据占磁盘空间最大的前3张表:</p><p><img src="/../images/image-20240125214152493.png" alt="image-20240125214152493"></p><h3 id="9-11-LIMIT子句"><a href="#9-11-LIMIT子句" class="headerlink" title="9.11 LIMIT子句"></a>9.11 LIMIT子句</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">database</span>,<span class="hljs-keyword">table</span>,MAX(bytes_on_disk) <span class="hljs-keyword">AS</span> bytes <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">system</span>.parts<br>  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">database</span>,<span class="hljs-keyword">table</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> bytes <span class="hljs-keyword">DESC</span><br>  <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">3</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">database</span><br>  <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>上述语句表示，查询返回数据占磁盘空间最大的前3张表，而返回 的总数据行等于10。</p><h3 id="9-12-SELECT子句"><a href="#9-12-SELECT子句" class="headerlink" title="9.12 SELECT子句"></a>9.12 SELECT子句</h3><p>SELECT子句决定了一次查询语句最终返回哪些列字段或表达式。 与直观的感受不同，虽然SELECT位于SQL语句的起始位置，但它却是在 上述一众子句之后执行的。在其他子句执行之后，SELECT会将选取的 字段或表达式作用于每行数据之上。如果使用*通配符，则会返回数据 表的所有字段。正如本章开篇所言，在大多数情况下都不建议这么 做，因为对于一款列式存储的数据库而言，这绝对是劣势而不是优 势。</p><h3 id="9-13-DISTINCT子句"><a href="#9-13-DISTINCT子句" class="headerlink" title="9.13 DISTINCT子句"></a>9.13 DISTINCT子句</h3><p>DISTINCT子句能够去除重复数据，使用场景广泛。有时候，人们 会拿它与GROUP BY子句进行比较。</p><h3 id="9-14-UNION-ALL子句"><a href="#9-14-UNION-ALL子句" class="headerlink" title="9.14 UNION ALL子句"></a>9.14 UNION ALL子句</h3><p>UNION ALL子句能够联合左右两边的两组子查询，将结果一并返 回。</p><p>列字段的名称可以不同，查询结果中的列名会以左边 的子查询为准。</p><h3 id="9-15-查看SQL执行计划"><a href="#9-15-查看SQL执行计划" class="headerlink" title="9.15 查看SQL执行计划"></a>9.15 查看SQL执行计划</h3><p>通过将ClickHouse服务日志设置到DEBUG或者TRACE级别，可以变相实现EXPLAIN查询，以分析 SQL的执行日志。</p><h3 id="9-16-本章小结"><a href="#9-16-本章小结" class="headerlink" title="9.16 本章小结"></a>9.16 本章小结</h3><p>本章按照ClickHouse对SQL大致的解析顺序，依次介绍了各种查询 子句的用法。包括用于简化SQL写法的WITH子句、用于数据采样的 SAMPLE子句、能够优化查询的PREWHERE子句以及常用的JOIN和GROUP BY子句等。但是到目前为止，我们还是只介绍了ClickHouse的本地查 询部分，当面对海量数据的时候，单节点服务是不足以支撑的，所以 下一章将进一步介绍与ClickHouse分布式相关的知识。</p><h2 id="第10章-副本与分片"><a href="#第10章-副本与分片" class="headerlink" title="第10章 副本与分片"></a>第10章 副本与分片</h2><p>纵使单节点性能再强，也会有遇到瓶颈的那一天。业务量的持续 增长、服务器的意外故障，都是ClickHouse需要面对的洪水猛兽。常 言道，“一个篱笆三个桩，一个好汉三个帮”，而集群、副本与分 片，就是ClickHouse的三个“桩”和三个“帮手”。</p><h3 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h3><p>集群是副本和分片的基础，它将ClickHouse的服务拓扑由单节点 延伸到多个节点，但它并不像Hadoop生态的某些系统那样，要求所有 节点组成一个单一的大集群。ClickHouse的集群配置非常灵活，用户 既可以将所有节点组成一个单一集群，也可以按照业务的诉求，把节 点划分为多个小的集群。在每个小的集群区域之间，它们的节点、分 区和副本数量可以各不相同</p><p>副本和分片这对双胞胎兄弟，有时候看起来泾渭分明，有时候又 让人分辨不清。这里有两种区分的方法。一种是从数据层面区分，假 设ClickHouse的N个节点组成了一个集群，在集群的各个节点上，都有 一张结构相同的数据表Y。如果N1的Y和N2的Y中的数据完全不同，则N1 和N2互为分片;如果它们的数据完全相同，则它们互为副本。换言 之，分片之间的数据是不同的，而副本之间的数据是完全相同的。所 以抛开表引擎的不同，单纯从数据层面来看，副本和分片有时候只有 一线之隔。</p><p>另一种是从功能作用层面区分，使用副本的主要目的是防止数据 丢失，增加数据存储的冗余;而使用分片的主要目的是实现数据的水 平切分</p><h3 id="10-2-数据副本"><a href="#10-2-数据副本" class="headerlink" title="10.2 数据副本"></a>10.2 数据副本</h3><p>用ReplicatedMergeTree的数据表就是副 本。</p><p>正如前文所言，使用副本的好处甚多。首先，由于增加了数据的冗余存储，所以降低了数据丢失的风险;其次，由于副本采用了多主架构，所以每个副本实例都可以作为数据读、写的入口，这无疑分摊了节点的负载。</p><p>在使用副本时，不需要依赖任何集群配置(关于集群配置，在后 续小节会详细介绍)ReplicatedMergeTree结合ZooKeeper就能完成 全部工作。</p><p>对于zk_path而言，同一张数据表的同一个分片的不同副本，应该 定义相同的路径;而对于replica_name而言，同一张数据表的同一个 分片的不同副本，应该定义不同的名称。</p><p>是不是有些绕口呢?下面列举几个示例。</p><p>1个分片、1个副本的情形:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>分片，<span class="hljs-number">1</span>副本. zk_path相同，replica_name不同 ReplicatedMergeTree(<span class="hljs-string">&#x27;/clickhouse/tables/01/test_1, &#x27;</span>ch5.nauu.com<span class="hljs-string">&#x27;) ReplicatedMergeTree(&#x27;</span><span class="hljs-regexp">/clickhouse/</span>tables<span class="hljs-regexp">/01/</span>test_1, <span class="hljs-string">&#x27;ch6.nauu.com&#x27;</span>)<br></code></pre></td></tr></table></figure><p>多个分片、1个副本的情形:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>分片<span class="hljs-number">1</span><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>分片，<span class="hljs-number">1</span>副本. zk_path相同，其中&#123;shard&#125;=<span class="hljs-number">01</span>, replica_name不同 ReplicatedMergeTree(<span class="hljs-string">&#x27;/clickhouse/tables/01/test_1, &#x27;</span>ch5.nauu.com<span class="hljs-string">&#x27;) ReplicatedMergeTree(&#x27;</span><span class="hljs-regexp">/clickhouse/</span>tables<span class="hljs-regexp">/01/</span>test_1, <span class="hljs-string">&#x27;ch6.nauu.com&#x27;</span>) <span class="hljs-regexp">//</span>分片<span class="hljs-number">2</span><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>分片，<span class="hljs-number">1</span>副本. zk_path相同，其中&#123;shard&#125;=<span class="hljs-number">02</span>, replica_name不同 ReplicatedMergeTree(<span class="hljs-string">&#x27;/clickhouse/tables/02/test_1, &#x27;</span>ch7.nauu.com<span class="hljs-string">&#x27;) ReplicatedMergeTree(&#x27;</span><span class="hljs-regexp">/clickhouse/</span>tables<span class="hljs-regexp">/02/</span>test_1, <span class="hljs-string">&#x27;ch8.nauu.com&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="10-3-ReplicatedMergeTree原理解析"><a href="#10-3-ReplicatedMergeTree原理解析" class="headerlink" title="10.3 ReplicatedMergeTree原理解析"></a>10.3 ReplicatedMergeTree原理解析</h3><p>ReplicatedMergeTree作为复制表系列的基础表引擎，涵盖了数据 副本最为核心的逻辑，将它拿来作为副本的研究标本是最合适不过 了。因为只要剖析了ReplicatedMergeTree的核心原理，就能掌握整个 ReplicatedMergeTree系列表引擎的使用方法。</p><p>无论MERGE操作从哪个副本发起，其合并计划都会交由主副本来制定。</p><p>当监听到有新的MUTATION日志加入时，并不是所有副本都会直接做出响应，它们首先会判断 自己是否为主副本。</p><h3 id="10-4-数据分片"><a href="#10-4-数据分片" class="headerlink" title="10.4 数据分片"></a>10.4 数据分片</h3><p>通过引入数据副本，虽然能够有效降低数据的丢失风险(多份存储)，并提升查询的性能(分摊查询、读写分离)，但是仍然有一个问题没有解决，那就是数据表的容量问题。到目前为止，每个副本自身，仍然保存了数据表的全量数据。所以在业务量十分庞大的场景中，依靠副本并不能解决单表的性能瓶颈。想要从根本上解决这类问<br>题，需要借助另外一种手段，即进一步将数据水平切分，也就是我们将要介绍的数据分片。</p><p>ClickHouse中的每个服务节点都可称为一个shard(分片)。从理 论上来讲，假设有N(N&gt;&#x3D;1)张数据表A，分布在N个ClickHouse服务节 点，而这些数据表彼此之间没有重复数据，那么就可以说数据表A拥有 N个分片。然而在工程实践中，如果只有这些分片表，那么整个 Sharding(分片)方案基本是不可用的。对于一个完整的方案来说， 还需要考虑数据在写入时，如何被均匀地写至各个shard，以及数据在 查询时，如何路由到每个shard，并组合成结果集。所以，ClickHouse 的数据分片需要结合Distributed表引擎一同使用，</p><p><img src="/../images/image-20240205175818016.png" alt="image-20240205175818016"></p><p>Distributed表引擎自身不存储任何数据，它能够作为分布式表的 一层透明代理，在集群内部自动开展数据的写入、分发、查询、路由 等工作。</p><p>在前面介绍数据副本时为了创建多张副本 表，我们需要分别登录到每个ClickHouse节点，在它们本地执行各自的 CREATE语句。这是因为在默认的情况下，CREATE、DROP、RENAME和ALTER等 DDL语句并不支持分布式执行。而在加入集群配置后，就可以使用新的语法 实现分布式DDL执行了，其语法形式如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span><span class="hljs-operator">/</span><span class="hljs-keyword">DROP</span><span class="hljs-operator">/</span>RENAME<span class="hljs-operator">/</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>  <span class="hljs-keyword">ON</span> CLUSTER cluster_name<br></code></pre></td></tr></table></figure><p>cluster_name对应了配置文件中的集群名称，ClickHouse会根 据集群的配置信息顺藤摸瓜，分别去各个节点执行DDL语句。</p><h3 id="10-5-Distribution原理解析"><a href="#10-5-Distribution原理解析" class="headerlink" title="10.5 Distribution原理解析"></a>10.5 Distribution原理解析</h3><p>Distributed表引擎是分布式表的代名词，它自身不存储任何数 据，而是作为数据分片的透明代理，能够自动路由数据至集群中的各 个节点，所以Distributed表引擎需要和其他数据表引擎一起协同工 作，</p><p><img src="/../images/image-20240205180253001.png" alt="image-20240205180253001"></p><p>本地表:通常以_local为后缀进行命名。本地表是承接数据的 载体，<strong>可以使用非Distributed的任意表引擎</strong>，一张本地表对应了一个 数据分片。</p><p>分布式表:通常以_all为后缀进行命名。<strong>分布式表只能使用 Distributed表引擎</strong>，它与本地表形成一对多的映射关系，日后将通过分布式表代理操作多张本地表。</p><p>对于分布式表与本地表之间表结构的一致性检查，Distributed表 引擎采用了读时检查的机制，<strong>这意味着如果它们的表结构不兼容，只 有在查询时才会抛出错误，而在创建表时并不会进行检查。</strong>不同 ClickHouse节点上的<strong>本地表之间，使用不同的表引擎也是可行的</strong>，但 是通常不建议这么做，保持它们的结构一致，有利于后期的维护并避 免造成不可预计的错误。</p><p>Distributed表引擎的定义形式如下所示:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ENGINE <span class="hljs-operator">=</span> Distributed(cluster, database, <span class="hljs-keyword">table</span> [,sharding_key])<br></code></pre></td></tr></table></figure><p>其中，各个参数的含义分别如下:</p><p>·cluster:集群名称，与集群配置中的自定义名称相对应。在对 分布式表执行写入和查询的过程中，它会使用集群的配置信息来找到 相应的host节点。</p><p>·database和table:分别对应数据库和表的名称，分布式表使用 这组配置映射到本地表。</p><p>·sharding_key:分片键，选填参数。在数据写入的过程中，分 布式表会依据分片键的规则，将数据分布到各个host节点的本地表。</p><p>现在用示例说明Distributed表的声明方式，建表语句如下所示:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test_shard_2_all <span class="hljs-keyword">ON</span> CLUSTER sharding_simple (<br>      id UInt64<br>  )ENGINE <span class="hljs-operator">=</span> Distributed(sharding_simple, <span class="hljs-keyword">default</span>, test_shard_2_local,rand())<br></code></pre></td></tr></table></figure><p>上述表引擎参数的语义可以理解为，代理的本地表为 default.test_shard_2_local，它们分布在集群sharding_simple的各 个shard，在数据写入时会根据rand()随机函数的取值决定数据写入哪 个分片。值得注意的是，此时此刻本地表还未创建，所以从这里也能 看出，<strong>Distributed表运用的是读时检查的机制，对创建分布式表和本 地表的顺序并没有强制要求。</strong>同样值得注意的是，在上面的语句中使 用了ON CLUSTER分布式DDL，这意味着在集群的每个分片节点上，都会 创建一张Distributed表，如此一来便可以从其中任意一端发起对所有 分片的读、写请求，如图10-13所示。</p><p>在向集群内的分片写入数据时，通常有两种思路:一种是借助外部计算系 统，事先将数据均匀分片，再借由计算系统直接将数据写入ClickHouse集群的 各个本地表。这种方式很依赖外部，对clickhouse依赖不高。一般使用第二种思路：通过Distributed表引擎代理写入分片数据。</p><p>如果在集群的配置中包含了副本，那么除了刚才的分片写入流程之外，还 会触发副本数据的复制流程。数据在多个副本之间，有两种复制实现方式:一 种是继续借助Distributed表引擎，由它将数据写入副本;<strong>另一种则是借助 ReplicatedMergeTree表引擎实现副本数据的分发。</strong></p><p><img src="/../images/image-20240205180902811.png" alt="image-20240205180902811"></p><p>与数据写入有所不同，在面向集群查询数据的时候，只能通过Distributed表引擎实现。当 Distributed表接收到SELECT查询的时候，它会依次查询每个分片的数据，再合并汇总返回</p><p>在查询数据的时候，如果集群中的一个shard，拥有多个replica，那么Distributed表引擎需要面临 副本选择的问题。它会使用负载均衡算法从众多replica中选择一个，而具体使用何种负载均衡算法，则 由load_balancing参数控制</p><p>分布式查询与分布式写入类似，同样本着谁执行谁负责的原则，它会由接收SELECT查询的 Distributed表，并负责串联起整个过程。首先它会将针对分布式表的SQL语句，按照分片数量将查询拆分 成若干个针对本地表的子查询，然后向各个分片发起查询，最后再汇总各个分片的返回结果。如果对分布 式表按如下方式发起查询:</p><p>SELECT * FROM distributed_table</p><p>那么它会将其转为如下形式之后，再发送到远端分片节点来执行:</p><p>SELECT * FROM local_table</p><p><strong>为了解决查询放大的问题，可以使用GLOBAL IN或JOIN进行优化。</strong>现在对刚才的SQL进行改造，为其增 加GLOBAL修饰符:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> uniq(id) <span class="hljs-keyword">FROM</span> test_query_all <span class="hljs-keyword">WHERE</span> repo <span class="hljs-operator">=</span> <span class="hljs-number">100</span><br><span class="hljs-keyword">AND</span> id <span class="hljs-keyword">GLOBAL</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> test_query_all <span class="hljs-keyword">WHERE</span> repo <span class="hljs-operator">=</span> <span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p>再次分析查询的核心过程，如图10-21所示。 整个过程由上至下大致分成5个步骤: (1)将IN子句单独提出，发起了一次分布式查询。 (2)将分布式表转local本地表后，分别在本地和远端分片执行查询。 (3)将IN子句查询的结果进行汇总，并放入一张临时的内存表进行保存。 (4)将内存表发送到远端分片节点。(5)将分布式表转为本地表后，开始执行完整的SQL语句，<strong>IN子句直接使用临时内存表的数据。</strong></p><p>至此，整个核心流程结束。可以看到，在使用GLOBAL修饰符之后，ClickHouse使用内存表临时保存了 IN子句查询到的数据，并将其发送到远端分片节点，以此到达了数据共享的目的，从而避免了查询放大的 问题。由于数据会在网络间分发，所以需要特别注意临时表的大小，IN或者JOIN子句返回的数据不宜过 大。如果表内存在重复数据，也可以事先在子句SQL中增加DISTINCT以实现去重。</p><h3 id="10-6-本章小结"><a href="#10-6-本章小结" class="headerlink" title="10.6 本章小结"></a>10.6 本章小结</h3><p>本章全方面介绍了副本、分片和集群的使用方法，并且详细介绍了它们的作用以及核心工作流程。</p><p>首先我们介绍了数据副本的特点，并详细介绍了 ReplicatedMergeTree表引擎，它是MergeTree表引擎的变种，同时也 是数据副本的代名词;接着又介绍了数据分片的特点及作用，同时在 这个过程中引入了ClickHouse集群的概念，并讲解了它的工作原理; 最后介绍了Distributed表引擎的核心功能与工作流程，借助它的能 力，可以实现分布式写入与查询。</p><h2 id="第11章-管理与运维"><a href="#第11章-管理与运维" class="headerlink" title="第11章 管理与运维"></a>第11章 管理与运维</h2><p>本章会介绍ClickHouse的权限、熔断机 制、数据备份和服务监控等知识</p><h3 id="11-1-用户配置"><a href="#11-1-用户配置" class="headerlink" title="11.1 用户配置"></a>11.1 用户配置</h3><p>user.xml配置文件默认位于&#x2F;etc&#x2F;clickhouse-server路径下， ClickHouse使用它来定义用户相关的配置项，包括系统参数的设定、 用户的定义、权限以及熔断机制等。</p><p>用户profile的作用类似于用户角色。可以预先在user.xml中为 ClickHouse定义多组profile，并为每组profile定义不同的配置项， 以实现配置的复用。</p><p>constraints标签可以设置一组约束条件，以保障profile内的参 数值不会被随意修改。在default中默认定义的constraints约 束，将作为默认的全局约束，自动被其他profile继承。</p><h3 id="11-2-权限管理"><a href="#11-2-权限管理" class="headerlink" title="11.2 权限管理"></a>11.2 权限管理</h3><p>ClickHouse分别从访问、 查询和数据等角度出发，层层递进，为我们提供了一个较为立体的权 限体系。</p><p>访问层控制是整个权限体系的第一层防护，它又可进一步细分成两类权限：网络访问权限和数据库与字典访问权限。</p><p>网络访问权限使用networks标签设置，用于限制某个用户登录的客户端地 址，有IP地址、host主机名称以及正则匹配三种形式，可以任选其中一种进行 设置。</p><p>在客户端连入服务之后，可以进一步限制某个用户数据库和字典的访问权 限，它们分别通过allow_databases和allow_dictionaries标签进行设置。如果 不进行任何定义，则表示不进行限制。</p><p>查询权限是整个权限体系的第二层防护，它决定了一个用户能够执行的查询语句。查询权限可以分成以下四类:</p><p>·读权限:包括SELECT、EXISTS、SHOW和DESCRIBE查询。</p><p>·写权限:包括INSERT和<strong>OPTIMIZE</strong>查询。</p><p>·设置权限:包括SET查询。</p><p>·DDL权限:包括CREATE、DROP、ALTER、RENAME、ATTACH、 DETACH和TRUNCATE查询。</p><p>·其他权限:包括KILL和USE查询，任何用户都可以执行这些查 询。</p><p>数据权限是整个权限体系中的第三层防护，它决定了一个用户能够看到什么 数据。数据权限使用databases标签定义，它是用户定义中的一项选填设置。 database通过定义用户级别的查询过滤器来实现数据的行级粒度权限，它的定义 规则如下所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">databases</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">database_name</span>&gt;</span><span class="hljs-comment">&lt;!--数据库名称--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table_name</span>&gt;</span><span class="hljs-comment">&lt;!--表名称--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span> id &lt; 10<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-comment">&lt;!--数据过滤条件--&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">table_name</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">database_name</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中，database_name表示数据库名称;table_name表示表名称;而filter则 是权限过滤的关键所在，它等同于定义了一条WHERE条件子句，与WHERE子句类 似，它支持组合条件。</p><p>那么数据权限的设定是如何实现的呢?它是在上述代码在普通查询计划的基础之上自动附加了Filter过滤的步 骤。</p><p>对于数据权限的使用有一点需要明确，在使用了这项功能之后，PREWHERE优 化将不再生效。如果使用了数据权限，那么这条SQL将不会进行PREWHERE优化;反之，如 果没有设置数据权限，则会进行PREWHERE优化</p><h3 id="11-4-数据备份"><a href="#11-4-数据备份" class="headerlink" title="11.4 数据备份"></a>11.4 数据备份</h3><p>如果数据的体量较小，可以通过dump的形式将数据导出为本地文件。</p><p>还可以通过快照备份：快照表实质上就是普通的数据表，它通常按照业务规定的备份频率创建，例如按天或者按周创建。所 以首先需要建立一张与原表结构相同的数据表，然后再使用INSERT INTO SELECT句式，点对点地将数据从 原表写入备份表。</p><p>此外还可以按照分区备份。基于数据分区的备份，ClickHouse目前提供了FREEZE与FETCH两种方式。</p><p>FREEZE的完整语法如下所示:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name FREEZE <span class="hljs-keyword">PARTITION</span> partition_expr<br></code></pre></td></tr></table></figure><p>分区在被备份之后，会被统一保存到ClickHouse根路径&#x2F;shadow&#x2F;N子目录 下。其中，N是一个自增长的整数，它的含义是备份的次数(FREEZE执行过多 少次)，具体次数由shadow子目录下的increment.txt文件记录。而分区备份 实质上是对原始目录文件进行硬链接操作，所以并不会导致额外的存储空间。 整个备份的目录会一直向上追溯至data根路径的整个链路:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span>data<span class="hljs-operator">/</span>[database]<span class="hljs-operator">/</span>[<span class="hljs-keyword">table</span>]<span class="hljs-operator">/</span>[partition_folder]<br></code></pre></td></tr></table></figure><p>例如执行下面的语句，会对数据表partition_v2的201908分区进行备份:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">:) <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> partition_v2 FREEZE <span class="hljs-keyword">PARTITION</span> <span class="hljs-number">201908</span><br></code></pre></td></tr></table></figure><p>进入shadow子目录，即能够看到刚才备份的分区目录:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># pwd<br>   <span class="hljs-operator">/</span>chbase<span class="hljs-operator">/</span>data<span class="hljs-operator">/</span>shadow<span class="hljs-operator">/</span><span class="hljs-number">1</span><span class="hljs-operator">/</span>data<span class="hljs-operator">/</span><span class="hljs-keyword">default</span><span class="hljs-operator">/</span>partition_v2<br>   # ll<br>   total <span class="hljs-number">4</span><br>   drwxr<span class="hljs-operator">-</span>x<span class="hljs-comment">---. 2 clickhouse clickhouse 4096 Sep  1 00:22 201908_5_5_0</span><br></code></pre></td></tr></table></figure><p>对于备份分区的还原操作，则需要借助ATTACH装载分区的方式来实现。这 意味着如果要还原数据，首先需要主动将shadow子目录下的分区文件复制到相 应数据表的detached目录下，然后再使用ATTACH语句装载。</p><p>使用FETCH备份：FETCH只支持ReplicatedMergeTree系列的表引擎，它的完整语法如下所 示:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">FETCH</span> <span class="hljs-keyword">PARTITION</span> partition_id <span class="hljs-keyword">FROM</span> zk_path<br></code></pre></td></tr></table></figure><h3 id="11-5-服务监控"><a href="#11-5-服务监控" class="headerlink" title="11.5 服务监控"></a>11.5 服务监控</h3><p>在众多的<strong>SYSTEM系统表中</strong>，主要由以下三张表支撑了对ClickHouse运 行指标的查询，它们分别是metrics、events和asynchronous_metrics。</p><p>metrics表用于统计ClickHouse服务在运行时，当前正在执行的高层 次的概要信息，包括正在执行的查询总次数、正在发生的合并操作总次数 等。</p><p>events用于统计ClickHouse服务在运行过程中已经执行过的高层次的 累积概要信息，包括总的查询次数、总的SELECT查询次数等</p><p>asynchronous_metrics用于统计ClickHouse服务运行过程时，当前正 在后台异步运行的高层次的概要信息，包括当前分配的内存、执行队列中 的任务数量等。</p><p>查询日志目前主要有6种类型，它们分别从不同角度记录了ClickHouse的操作行为。分为如下类型：</p><p>query_log记录了ClickHouse服务中所有已经执行的查询记录</p><p>query_thread_log记录了所有线程的执行查询的信息</p><p>part_log日志记录了MergeTree系列表引擎的分区操作日志</p><p>text_log日志记录了ClickHouse运行过程中产生的一系列打印日志，包括INFO、DEBUG和Trace，</p><p>metric_log日志用于将system.metrics和system.events中的数据汇聚到一起。包括：collect_interval_milliseconds表示收集metrics和events数据的时间周期。metric_log开启 后，即可以通过相应的系统表对记录进行查询。</p><h3 id="11-6-本章小结"><a href="#11-6-本章小结" class="headerlink" title="11.6 本章小结"></a>11.6 本章小结</h3><p>通过对本章的学习，大家可进一步了解ClickHouse的安全性和健 壮性。本章首先站在安全的角度介绍了用户的定义方法和权限的设置 方法。在权限设置方面，ClickHouse分别从连接访问、资源访问、查 询操作和数据权限等几个维度出发，提供了一个较为立体的权限控制 体系。接着站在系统运行的角度介绍了如何通过熔断机制保护 ClickHouse系统资源不会被过度使用。最后站在运维的角度介绍了数 据的多种备份方法以及如何通过系统表和查询日志，实现对日常运行 情况的监控。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAID简介与设置</title>
    <link href="/2024/02/04/RAID%E7%AE%80%E4%BB%8B%E4%B8%8E%E8%AE%BE%E7%BD%AE/"/>
    <url>/2024/02/04/RAID%E7%AE%80%E4%BB%8B%E4%B8%8E%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RAID全称独立冗余磁盘阵列，主要功能是把多个独立的物理盘按照<strong>不同的方式</strong>组合形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和备份技术。</p><p>上面所说的“不同的方式”也可以叫不同的RAID级别，也就是根据RAID级别组合，不同的RAID级别的组合方式不一样。常见的RAID级别包括：RAID0、RAID1、RAID5、RAID6、RAID10等。</p><p>可以做完RAID把系统OS放到RAID里，所以RAID还是很重要的。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>关于RAID操作有以下常用命令：</p><h3 id="清除RAID："><a href="#清除RAID：" class="headerlink" title="清除RAID："></a>清除RAID：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">MegaCli64 -CfgLdDel -L&#123;&#123;LD&#125;&#125; -force -a&#123;&#123;Adapter&#125;&#125;<br></code></pre></td></tr></table></figure><p>LD表示RAID组序号，即下文硬盘Drive’s postion的DiskGroup字段值，Adapter表示当前使用的是哪个RAID适配器，一般一台机器上只有一个适配器，执行<code>MegaCli64 -PDList -aALL</code>命令输出的第一行<code>Adapter #0</code>可以看到当前机器的RAID适配器是0，这个地方LD传0，Adapter传0。</p><h3 id="创建RAID"><a href="#创建RAID" class="headerlink" title="创建RAID"></a>创建RAID</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">MegaCli64 -CfgLdAdd –r&#123;&#123;Raid&#125;&#125;&#123;&#123;Slot&#125;&#125; -a&#123;&#123;Adapter&#125;&#125;<br></code></pre></td></tr></table></figure><p>Raid参数表示RAID类型，如RAID0，或者RAID1，或者RAID2，slot表示使用的磁盘的槽位，Adapter与上文同意。</p><p>比如可以执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">MegaCli64 -CfgLdAdd –r1[8:9,8:8] -a0<br></code></pre></td></tr></table></figure><h3 id="设置硬盘状态为good"><a href="#设置硬盘状态为good" class="headerlink" title="设置硬盘状态为good"></a>设置硬盘状态为good</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">MegaCli64 -PDMakeGood -Physdrv &#123;&#123;Slot&#125;&#125; -force -a&#123;&#123;Adapter&#125;&#125;<br></code></pre></td></tr></table></figure><p>各参数与上文同意。</p><p>###设置硬盘状态为JBOD</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">MegaCli64 -PDMakeJBOD -Physdrv &#123;&#123;Slot&#125;&#125;  -a&#123;&#123;Adapter&#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><p>下面举个实际运行的例子，查看设置RAID前后硬盘的状态变化。</p><p>设置RAID前，查看硬盘状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">MegaCli64 -PDList -aALL<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs shell">Enclosure Device ID: 8<br>Slot Number: 8<br>Enclosure position: 1<br>Device Id: 12<br>WWN: 55cd2e4156058d2c<br>Sequence Number: 38<br>Media Error Count: 0<br>Other Error Count: 0<br>Predictive Failure Count: 0<br>Last Predictive Failure Event Seq Number: 0<br>PD Type: SATA<br><br>Raw Size: 3.492 TB [0x1bf1f72b0 Sectors]<br>Non Coerced Size: 3.492 TB [0x1bf0f72b0 Sectors]<br>Coerced Size: 3.492 TB [0x1bf0f0000 Sectors]<br>Emulated Drive: Yes<br>Firmware state: JBOD<br>Device Firmware Level: 0132<br>Shield Counter: 0<br>Successful diagnostics completion on :  N/A<br>SAS Address(0): 0x500e004aaaaaaa08<br>Connected Port Number: 0(path0)<br>Inquiry Data: PHYG234600QS3P8EGN  INTEL SSDSC2KG038T8                     XCV10132<br>FDE Capable: Not Capable<br>FDE Enable: Disable<br>Secured: Unsecured<br>Locked: Unlocked<br>Needs EKM Attention: No<br>Foreign State: None<br>Device Speed: 6.0Gb/s<br>Link Speed: 12.0Gb/s<br>Media Type: Solid State Device<br>Drive Temperature :27C (80.60 F)<br>PI Eligibility:  No<br>Drive is formatted for PI information:  No<br>PI: No PI<br>Port-0 :<br>Port status: Active<br>Port&#x27;s Linkspeed: 12.0Gb/s<br>Drive has flagged a S.M.A.R.T alert : No<br><br><br><br>Enclosure Device ID: 8<br>Slot Number: 9<br>Enclosure position: 1<br>Device Id: 10<br>WWN: 55cd2e415604f4f0<br>Sequence Number: 2<br>Media Error Count: 0<br>Other Error Count: 0<br>Predictive Failure Count: 0<br>Last Predictive Failure Event Seq Number: 0<br>PD Type: SATA<br><br>Raw Size: 3.492 TB [0x1bf1f72b0 Sectors]<br>Non Coerced Size: 3.492 TB [0x1bf0f72b0 Sectors]<br>Coerced Size: 3.492 TB [0x1bf0f0000 Sectors]<br>Emulated Drive: Yes<br>Firmware state: JBOD<br>Device Firmware Level: 0132<br>Shield Counter: 0<br>Successful diagnostics completion on :  N/A<br>SAS Address(0): 0x500e004aaaaaaa09<br>Connected Port Number: 0(path0)<br>Inquiry Data: PHYG2345005Z3P8EGN  INTEL SSDSC2KG038T8                     XCV10132<br>FDE Capable: Not Capable<br>FDE Enable: Disable<br>Secured: Unsecured<br>Locked: Unlocked<br>Needs EKM Attention: No<br>Foreign State: None<br>Device Speed: 6.0Gb/s<br>Link Speed: 12.0Gb/s<br>Media Type: Solid State Device<br>Drive Temperature :26C (78.80 F)<br>PI Eligibility:  No<br>Drive is formatted for PI information:  No<br>PI: No PI<br>Port-0 :<br>Port status: Active<br>Port&#x27;s Linkspeed: 12.0Gb/s<br>Drive has flagged a S.M.A.R.T alert : No<br></code></pre></td></tr></table></figure><p>下面设置这两块盘，使用RAID1，运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">MegaCli64 -CfgLdAdd –r1[8:9,8:8] -a0<br></code></pre></td></tr></table></figure><p>再次通过<code>MegaCli64 -PDList -aALL</code>查看结果，可以看到新的结果与旧的结果的不同：</p><p><img src="/../images/image-20240204160553983.png" alt="image-20240204160553983"></p><p><img src="/../images/image-20240204160608410.png" alt="image-20240204160608410"></p><p>这两块盘的Firmware state都由<code>JBOD</code>变成了<code>Online, Spun Up</code></p><p>Drive’s postion字段的值一个是：<code>Drive&#39;s postion: DiskGroup: 0, Span: 0, Arm: 1</code>，一个是<code>Drive&#39;s postion: DiskGroup: 0, Span: 0, Arm: 0</code>，DiskGroup表示在哪个RAID分组里</p><p>因为如果有多块硬盘的话，可以选择两块AB做RAID0，再选择不同的两块CD做RAID1或者RAID0，AB是属于同一个RAID组的，CD是属于同一个RAID组的，这是两个不同的RAID组。Drive’s postion字段里DiskGroup就表示银盘所属RAID组，可以看到这8:8和8:9这两块盘属于同一个RAID组，因为上述CfgLdAdd里就指定了[8:9,8:8]这两块盘要做一个RAID。注意如果要指定RAID组一定要在执行一个CfgLdAdd时把所有的硬盘都写入，每一行CfgLdAdd命令中的硬盘在一个RAID组里，下一行的指定的硬盘就在另一个RAID组了。</p><p>比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">MegaCli64 -CfgLdAdd –r1[8:9,8:8] -a0<br></code></pre></td></tr></table></figure><p>操作后，8:8和8:9的Drive’s postion信息分别为<code>DiskGroup: 0, Span: 0, Arm: 1</code>和<code>DiskGroup: 0, Span: 0, Arm: 0</code>。再执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">MegaCli64 -CfgLdAdd –r1[8:4,8:5] -a0<br></code></pre></td></tr></table></figure><p>8:4和8:5的Drive’s postion信息分别为<code>Drive&#39;s postion: DiskGroup: 1, Span: 0, Arm: 0</code>和<code>Drive&#39;s postion: DiskGroup: 1, Span: 0, Arm: 1</code>，8:8 8:9和8:4 8:5的DiskGroup是不一样的，因为它们处于不同的RAID组。</p><h2 id="RAID级别"><a href="#RAID级别" class="headerlink" title="RAID级别"></a>RAID级别</h2><p>不同RAID级别对硬盘数量的要求：</p><p>创建RAID0阵列，至少需要两块硬盘。</p><blockquote><p>相关命令解析：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">MegaCli64 -CfgLdAdd –r0[8:8] -a0<br></code></pre></td></tr></table></figure><p>这条命令尝试创建一个 RAID 0 阵列，指定的物理驱动器是 <code>[8:8]</code>。</p><p>在MegaCli64中，<code>[8:8]</code>不是指两块硬盘，而是指槽位号为8的硬盘。RAID 0 需要至少两块硬盘，但在这个命令中，只指定了一个硬盘的槽位号，因此它实际上不是有效的 RAID 0 配置。如果只有一块硬盘，这个命令可能会创建一个虚拟的 RAID 0 阵列，但是它不会提供任何冗余性或性能优势，因为 RAID 0 至少需要两块硬盘才能发挥作用。</p><p>要创建一个有效的 RAID 0 阵列，你需要至少两块硬盘，并在命令中指定它们的槽位号。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">MegaCli64 -CfgLdAdd -r0[8:8,9:9] -a0<br></code></pre></td></tr></table></figure><p>这个命令会创建一个 RAID 0 阵列，使用槽位号为8和9的两块硬盘。</p></blockquote><p><img src="/../images/image-20240204171330076.png" alt="image-20240204171330076"></p><p>RAID1要求硬盘数量为偶数，通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据</p><p><img src="/../images/image-20240204171404887.png" alt="image-20240204171404887"></p><p>RAID5要求硬盘数量大于等于3，数据条带形式分布，以奇偶校验作冗余</p><p><img src="/../images/image-20240204171431878.png" alt="image-20240204171431878"></p><p>RAID6要求硬盘数量大于等于4</p><p><img src="/../images/image-20240204171456385.png" alt="image-20240204171456385"></p><p>RAID10要求硬盘数量大于等于4且为偶数，也叫RAID1+0</p><p><img src="/../images/image-20240204171506169.png" alt="image-20240204171506169"></p><h2 id="设置RAID的方法"><a href="#设置RAID的方法" class="headerlink" title="设置RAID的方法"></a>设置RAID的方法</h2><p>如果硬盘已经有了RAID的话，需要清除之前的RAID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">MegaCli64 -CfgLdDel -L%s -force -a%s<br></code></pre></td></tr></table></figure><p>标记硬盘状态为Good，表示磁盘空闲</p><p>设置磁盘RAID</p><p>此外还可以设置硬盘的状态为<strong>JBOD</strong>，即Just a Bunch Of Disks，当一个磁盘被设置为JBOD状态时，它不会被包含在任何RAID阵列中，而是被视为单独的独立磁盘。在JBOD状态下，每个磁盘都可以单独访问，并且没有数据被分配或复制到其他磁盘上。这意味着如果一个磁盘出现故障，它不会影响其他磁盘上的数据。</p><h2 id="硬盘空间"><a href="#硬盘空间" class="headerlink" title="硬盘空间"></a>硬盘空间</h2><p>硬盘空间分为两类，一种是JBOD阵列，一种是RAID阵列。JBOD阵列里的多个硬盘互相独立。RAID阵列里可能有多个RAID组，一个RAID组里有多块硬盘。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">- JBOD <span class="hljs-selector-attr">[硬盘1， 硬盘2]</span><br>- RAID阵列 - RAID组<span class="hljs-number">1</span>：<span class="hljs-selector-attr">[硬盘1，硬盘2]</span><br>           - RAID组<span class="hljs-number">2</span>：<span class="hljs-selector-attr">[硬盘2，硬盘3]</span><br></code></pre></td></tr></table></figure><h2 id="硬盘状态"><a href="#硬盘状态" class="headerlink" title="硬盘状态"></a>硬盘状态</h2><p>硬盘状态即Firmware state字段有以下可能值：</p><ul><li><p>Online, Spun Up：表示该盘已经被进行了RAID操作，其Drive’s postion字段可以查看该盘的所在RAID阵列。</p></li><li><p>Unconfigured(good), Spun Up：表示该状态良好，可以对该盘进行RAID操作</p></li><li><p>JBOD：盘在JBOD阵列中。</p></li></ul><p>如果当前硬盘状态就是要设置的状态，那么可以不用执行设置状态的命令了，因为是重复设置了，否则可能会报错。<br>参考</p><p><a href="https://www.cnblogs.com/123456789SI/p/16793811.html">RAID配置与解释</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gin之cleanPath函数阅读</title>
    <link href="/2024/01/17/gin%E4%B9%8BcleanPath%E5%87%BD%E6%95%B0%E9%98%85%E8%AF%BB/"/>
    <url>/2024/01/17/gin%E4%B9%8BcleanPath%E5%87%BD%E6%95%B0%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>最近在阅读gin框架的源代码，发现gin里有一个挺重要的函数cleanPath，这个函数和path.Clean类似，但是是url的实现方式，和go的path.Clean源码的实现方式还是有些不一样的。但是主要的功能就是给定一个路径，返回这个路径计算之后的结果，主要就是对一些相对路径如<code>.</code>，<code>..</code>的处理，比如输入<code>/a/b/../d</code>，那么就输出计算后的路径：<code>/a/d</code>，输入<code>/a/b/c/.</code>，输出<code>/a/b/c</code>。</p><p>下面是gin里cleanPath的实现，这个函数在<code>path.go</code>文件里：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// cleanPath is the URL version of path.Clean, it returns a canonical URL path</span><br><span class="hljs-comment">// for p, eliminating . and .. elements.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The following rules are applied iteratively until no further processing can</span><br><span class="hljs-comment">// be done:</span><br><span class="hljs-comment">//  1. Replace multiple slashes with a single slash.</span><br><span class="hljs-comment">//  2. Eliminate each . path name element (the current directory).</span><br><span class="hljs-comment">//  3. Eliminate each inner .. path name element (the parent directory)</span><br><span class="hljs-comment">//     along with the non-.. element that precedes it.</span><br><span class="hljs-comment">//  4. Eliminate .. elements that begin a rooted path:</span><br><span class="hljs-comment">//     that is, replace &quot;/..&quot; by &quot;/&quot; at the beginning of a path.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If the result of this process is an empty string, &quot;/&quot; is returned.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cleanPath</span><span class="hljs-params">(p <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">const</span> stackBufSize = <span class="hljs-number">128</span><br><span class="hljs-comment">// Turn empty string into &quot;/&quot;</span><br><span class="hljs-keyword">if</span> p == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/&quot;</span><br>&#125;<br><br><span class="hljs-comment">// Reasonably sized buffer on stack to avoid allocations in the common case.</span><br><span class="hljs-comment">// If a larger buffer is required, it gets allocated dynamically.</span><br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>, stackBufSize)<br><br>n := <span class="hljs-built_in">len</span>(p)<br><br><span class="hljs-comment">// Invariants:</span><br><span class="hljs-comment">//      reading from path; r is index of next byte to process.</span><br><span class="hljs-comment">//      writing to buf; w is index of next byte to write.</span><br><br><span class="hljs-comment">// path must start with &#x27;/&#x27;</span><br>r := <span class="hljs-number">1</span><br>w := <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> p[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;/&#x27;</span> &#123;<br>r = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">if</span> n+<span class="hljs-number">1</span> &gt; stackBufSize &#123;<br>buf = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, n+<span class="hljs-number">1</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>buf = buf[:n+<span class="hljs-number">1</span>]<br>&#125;<br>buf[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;/&#x27;</span><br>&#125;<br><br>trailing := n &gt; <span class="hljs-number">1</span> &amp;&amp; p[n<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;/&#x27;</span><br><br><span class="hljs-comment">// A bit more clunky without a &#x27;lazybuf&#x27; like the path package, but the loop</span><br><span class="hljs-comment">// gets completely inlined (bufApp calls).</span><br><span class="hljs-comment">// loop has no expensive function calls (except 1x make)// So in contrast to the path package this loop has no expensive function</span><br><span class="hljs-comment">// calls (except make, if needed).</span><br><br><span class="hljs-keyword">for</span> r &lt; n &#123;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> p[r] == <span class="hljs-string">&#x27;/&#x27;</span>:<br><span class="hljs-comment">// empty path element, trailing slash is added after the end</span><br>r++<br><br><span class="hljs-keyword">case</span> p[r] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; r+<span class="hljs-number">1</span> == n:<br>trailing = <span class="hljs-literal">true</span><br>r++<br><br><span class="hljs-keyword">case</span> p[r] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; p[r+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;/&#x27;</span>:<br><span class="hljs-comment">// . element</span><br>r += <span class="hljs-number">2</span><br><br><span class="hljs-keyword">case</span> p[r] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; p[r+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; (r+<span class="hljs-number">2</span> == n || p[r+<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;/&#x27;</span>):<br><span class="hljs-comment">// .. element: remove to last /</span><br>r += <span class="hljs-number">3</span><br><br><span class="hljs-keyword">if</span> w &gt; <span class="hljs-number">1</span> &#123;<br><span class="hljs-comment">// can backtrack</span><br>w--<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(buf) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> w &gt; <span class="hljs-number">1</span> &amp;&amp; p[w] != <span class="hljs-string">&#x27;/&#x27;</span> &#123;<br>w--<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> w &gt; <span class="hljs-number">1</span> &amp;&amp; buf[w] != <span class="hljs-string">&#x27;/&#x27;</span> &#123;<br>w--<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// Real path element.</span><br><span class="hljs-comment">// Add slash if needed</span><br><span class="hljs-keyword">if</span> w &gt; <span class="hljs-number">1</span> &#123;<br>bufApp(&amp;buf, p, w, <span class="hljs-string">&#x27;/&#x27;</span>)<br>w++<br>&#125;<br><br><span class="hljs-comment">// Copy element</span><br><span class="hljs-keyword">for</span> r &lt; n &amp;&amp; p[r] != <span class="hljs-string">&#x27;/&#x27;</span> &#123;<br>bufApp(&amp;buf, p, w, p[r])<br>w++<br>r++<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Re-append trailing slash</span><br><span class="hljs-keyword">if</span> trailing &amp;&amp; w &gt; <span class="hljs-number">1</span> &#123;<br>bufApp(&amp;buf, p, w, <span class="hljs-string">&#x27;/&#x27;</span>)<br>w++<br>&#125;<br><br><span class="hljs-comment">// If the original string was not modified (or only shortened at the end),</span><br><span class="hljs-comment">// return the respective substring of the original string.</span><br><span class="hljs-comment">// Otherwise return a new string from the buffer.</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(buf) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> p[:w]<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(buf[:w])<br>&#125;<br><br><span class="hljs-comment">// Internal helper to lazily create a buffer if necessary.</span><br><span class="hljs-comment">// Calls to this function get inlined.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bufApp</span><span class="hljs-params">(buf *[]<span class="hljs-type">byte</span>, s <span class="hljs-type">string</span>, w <span class="hljs-type">int</span>, c <span class="hljs-type">byte</span>)</span></span> &#123;<br>b := *buf<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(b) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// No modification of the original string so far.</span><br><span class="hljs-comment">// If the next character is the same as in the original string, we do</span><br><span class="hljs-comment">// not yet have to allocate a buffer.</span><br><span class="hljs-keyword">if</span> s[w] == c &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// Otherwise use either the stack buffer, if it is large enough, or</span><br><span class="hljs-comment">// allocate a new buffer on the heap, and copy all previous characters.</span><br>length := <span class="hljs-built_in">len</span>(s)<br><span class="hljs-keyword">if</span> length &gt; <span class="hljs-built_in">cap</span>(b) &#123;<br>*buf = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, length)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>*buf = (*buf)[:length]<br>&#125;<br>b = *buf<br><br><span class="hljs-built_in">copy</span>(b, s[:w])<br>&#125;<br>b[w] = c<br>&#125;<br></code></pre></td></tr></table></figure><p>我阅读的时候主要就是使用go的调试工具来逐行查看运行效果的。主要就是多输入集中能想到的情况，尽可能让代码运行时覆盖掉所有路径。</p><p>这个函数最重要的就是w和r两个变量，r记录了处理到了输入路径的第几个字符，w用于标记当前为运行当前判断出来的在最后结果中的下标，这个下标可能是p的下标（如果buf为空），也可能是buf的下标（如果buf非空）。</p><p>还有比较重要的就是buf，buf用于存储最终会用到的路径，存储的内容可能比最终的真实结果长，但是因为程序运行结束前，w标记了应该存储到buf的第几个下标，最终返回的结果是buf[:w]</p><p>&#x2F;&#x2F; 举一个需要注意的例子</p><p>&#x2F;&#x2F; 如果输出参数是  “&#x2F;tttttttttt&#x2F;c&#x2F;..&#x2F;d&#x2F;..&#x2F;..&#x2F;aaa&#x2F;yy”</p><p>那么程序运行过程中w和buf的值变化为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">w: 1, buf:<br>w: 2, buf:<br>w: 3, buf:<br>w: 4, buf:<br>w: 5, buf:<br>w: 6, buf:<br>w: 7, buf:<br>w: 8, buf:<br>w: 9, buf:<br>w: 10, buf:<br>w: 11, buf:<br>w: 12, buf:<br>w: 11, buf:<br>w: 12, buf: /tttttttttt/d  这里是 /tttttttttt/c/../d 得到的结果<br>w: 1, buf: /attttttttt/d 后面因为遇到了/aaa，因为前面的两个../，w不断回退，然后aaaa开始从w的位置也就是1开始覆盖buf<br>w: 2, buf: /aatttttttt/d<br>w: 3, buf: /aaattttttt/d<br>w: 4, buf: /aaa/tttttt/d<br>w: 5, buf: /aaa/yttttt/d<br>w: 6, buf: /aaa/yytttt/d w为6，虽然buf的长度不止6，但是w是标记哪些是真正计算出来的实际值的下标，返回的是用w截断的，返回的是buf[:w]<br></code></pre></td></tr></table></figure><p>buf运行中之前写入的值可能会在之后被覆盖掉，最终运行的结果是以w和buf综合起来的，是buf在w处被截断的结果，为buf[:w]。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gorm实现数据库不存在时自动创建</title>
    <link href="/2024/01/04/gorm%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA/"/>
    <url>/2024/01/04/gorm%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>可以参考下面的写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ConnMysql</span><span class="hljs-params">()</span></span> *gorm.DB &#123;<br>checkDatabase()<br>dsn := fmt.Sprintf(<span class="hljs-string">&quot;%s:%s@tcp(%s:%d)/%s?charset=%s&amp;collation=%s&amp;%s&quot;</span>,<br>config.Conf.Mysql.Username,<br>config.Conf.Mysql.Password,<br>config.Conf.Mysql.Host,<br>config.Conf.Mysql.Port,<br>config.Conf.Mysql.Database,<br>config.Conf.Mysql.Charset,<br>config.Conf.Mysql.Collation,<br>config.Conf.Mysql.Query,<br>)<br><span class="hljs-comment">// 隐藏密码</span><br>showDsn := fmt.Sprintf(<br><span class="hljs-string">&quot;%s:******@tcp(%s:%d)/%s?charset=%s&amp;collation=%s&amp;%s&quot;</span>,<br>config.Conf.Mysql.Username,<br>config.Conf.Mysql.Host,<br>config.Conf.Mysql.Port,<br>config.Conf.Mysql.Database,<br>config.Conf.Mysql.Charset,<br>config.Conf.Mysql.Collation,<br>config.Conf.Mysql.Query,<br>)<br>db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;<br><span class="hljs-comment">// 禁用外键(指定外键时不会在mysql创建真实的外键约束)</span><br>DisableForeignKeyConstraintWhenMigrating: <span class="hljs-literal">true</span>,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>logger.Log.Panicf(<span class="hljs-string">&quot;初始化mysql数据库异常: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 开启mysql日志</span><br><span class="hljs-keyword">if</span> config.Conf.Mysql.LogMode &#123;<br>db.Debug()<br>&#125;<br>logger.Log.Infof(<span class="hljs-string">&quot;初始化mysql数据库完成! dsn: %s&quot;</span>, showDsn)<br><span class="hljs-keyword">return</span> db<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkDatabase</span><span class="hljs-params">()</span></span> &#123;<br>dsn := fmt.Sprintf(<span class="hljs-string">&quot;%s:%s@tcp(%s:%d)/?charset=%s&amp;collation=%s&amp;%s&quot;</span>,<br>config.Conf.Mysql.Username,<br>config.Conf.Mysql.Password,<br>config.Conf.Mysql.Host,<br>config.Conf.Mysql.Port,<br>config.Conf.Mysql.Charset,<br>config.Conf.Mysql.Collation,<br>config.Conf.Mysql.Query,<br>)<br>db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;<br>DisableForeignKeyConstraintWhenMigrating: <span class="hljs-literal">true</span>,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>logger.Log.Panicf(<span class="hljs-string">&quot;初始化mysql数据库异常: %v&quot;</span>, err)<br>&#125;<br>sqlDB, err := db.DB()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>logger.Log.Panicf(<span class="hljs-string">&quot;获取SQL DB失败: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> sqlDB.Close()<br>createDBStatement := fmt.Sprintf(<span class="hljs-string">&quot;CREATE DATABASE IF NOT EXISTS %s&quot;</span>, config.Conf.Mysql.Database)<br>_, err = sqlDB.Exec(createDBStatement)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>logger.Log.Panicf(<span class="hljs-string">&quot;验证数据库信息失败: %v&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go-restful使用定义swagger</title>
    <link href="/2023/12/28/restful%E4%BD%BF%E7%94%A8%E5%AE%9A%E4%B9%89swagger/"/>
    <url>/2023/12/28/restful%E4%BD%BF%E7%94%A8%E5%AE%9A%E4%B9%89swagger/</url>
    
    <content type="html"><![CDATA[<p>开发使用的框架是github.com&#x2F;emicklei&#x2F;go-restful，下面介绍关于如何在这个框架中定义swagger文档并开启swagger路由。</p><h2 id="下载UI"><a href="#下载UI" class="headerlink" title="下载UI"></a>下载UI</h2><p>下载<a href="https://github.com/swagger-api/swagger-ui%EF%BC%8C%E5%B0%86%E9%87%8C%E9%9D%A2%E7%9A%84dist%E7%9B%AE%E5%BD%95%E5%A4%8D%E5%88%B6%E5%88%B0%E5%BC%80%E5%8F%91%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%8C%E6%88%91%E8%BF%99%E9%87%8C%E6%8A%8Adist%E7%9B%AE%E5%BD%95%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%BAswagger%E3%80%82%E5%B0%86dist%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%90%AB%E6%9C%89%60window.onload">https://github.com/swagger-api/swagger-ui，将里面的dist目录复制到开发的项目中，我这里把dist目录重命名为swagger。将dist目录下的含有`window.onload</a> &#x3D; function () &#96;部分的url替换成swag命令生成的swagger.json的路径，比如这里准备把生成的swagger.json也放到swagger目录下，那么url的值就是swagger.json。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">//&lt;editor-fold desc=&quot;Changeable Configuration Block&quot;&gt;</span><br><br><span class="hljs-comment">// the following lines will be replaced by docker/configurator, when it runs in a docker-container</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">ui</span> = <span class="hljs-title class_">SwaggerUIBundle</span>(&#123;<br><span class="hljs-attr">url</span>: <span class="hljs-string">&quot;swagger.json&quot;</span>,<br><span class="hljs-attr">dom_id</span>: <span class="hljs-string">&#x27;#swagger-ui&#x27;</span>,<br><span class="hljs-attr">deepLinking</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-attr">presets</span>: [<br><span class="hljs-title class_">SwaggerUIBundle</span>.<span class="hljs-property">presets</span>.<span class="hljs-property">apis</span>,<br><span class="hljs-title class_">SwaggerUIStandalonePreset</span><br>],<br><span class="hljs-attr">plugins</span>: [<br><span class="hljs-title class_">SwaggerUIBundle</span>.<span class="hljs-property">plugins</span>.<span class="hljs-property">DownloadUrl</span><br>],<br><span class="hljs-attr">layout</span>: <span class="hljs-string">&quot;StandaloneLayout&quot;</span><br>&#125;);<br><br><span class="hljs-comment">//&lt;/editor-fold&gt;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="定义API"><a href="#定义API" class="headerlink" title="定义API"></a>定义API</h2><p>定义API，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// @Summary获取CPU数量</span><br><span class="hljs-comment">// @Description获取CPU数量</span><br><span class="hljs-comment">// @Tags基本信息</span><br><span class="hljs-comment">// @Producejson</span><br><span class="hljs-comment">// @Success200&#123;object&#125;types.Resp</span><br><span class="hljs-comment">// @Router/info/cpu [get]</span><br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">swag init -g main.go -o swagger<br></code></pre></td></tr></table></figure><p>可以看到生成的文件在swagger目录下。</p><h2 id="添加访问swagger文档的路由"><a href="#添加访问swagger文档的路由" class="headerlink" title="添加访问swagger文档的路由"></a>添加访问swagger文档的路由</h2><p>参考如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> swagger<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/emicklei/go-restful&quot;</span><br>restfulswagger <span class="hljs-string">&quot;github.com/emicklei/go-restful-swagger12&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(container *restful.Container)</span></span> &#123;<br>config := restfulswagger.Config&#123;<br>WebServices:     container.RegisteredWebServices(),<br>ApiPath:         <span class="hljs-string">&quot;docs&quot;</span>,<br>SwaggerPath:     <span class="hljs-string">&quot;/apidoc/&quot;</span>,<br>SwaggerFilePath: <span class="hljs-string">&quot;swagger&quot;</span>,<br>ApiVersion:      <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>&#125;<br>restfulswagger.InstallSwaggerService(config)<br>restfulswagger.RegisterSwaggerService(config, container)<br>&#125;<br></code></pre></td></tr></table></figure><p>访问apidoc路径即可查看</p><p><img src="/../images/image-20231228173321529.png" alt="image-20231228173321529"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GO专家编程阅读记录</title>
    <link href="/2023/12/12/%E3%80%8AGO%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/12/%E3%80%8AGO%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>下面的记录是关于我在阅读《GO专家编程》这本书的笔记，笔记的内容主要是关于一些我不太熟悉的需要记忆的知识点。</p><p>因为这本书比较短，而且内容也不是特别深，所以记录的内容也没有特别多。记录的内容关注点在自己不熟悉的知识点。也没有完全按照每章的目录结构记录。</p></blockquote><h2 id="第一章-常见数据结构实现原理"><a href="#第一章-常见数据结构实现原理" class="headerlink" title="第一章 常见数据结构实现原理"></a>第一章 常见数据结构实现原理</h2><p>channel是Golang在语言级别提供的goroutine之间的通信方式，比Unix管道更易用也更轻便。</p><h3 id="channel的数据结构"><a href="#channel的数据结构" class="headerlink" title="channel的数据结构"></a>channel的数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span>&#123;<br>qcount <span class="hljs-type">uint</span> <span class="hljs-comment">// 当前队列中剩余元素个数</span><br>dataqsiz <span class="hljs-type">uint</span> <span class="hljs-comment">// 环形队列长度，即可以存放的元素个数</span><br>buf unsafe.Pointer <span class="hljs-comment">// 环形队列指针</span><br>elemsize <span class="hljs-type">uint16</span> <span class="hljs-comment">// 每个元素的大小</span><br>closed <span class="hljs-type">uint32</span> <span class="hljs-comment">// 标识关闭状态</span><br>elemtype *_type <span class="hljs-comment">// 元素类型</span><br>sendx <span class="hljs-type">uint</span> <span class="hljs-comment">// 队列下标，指示元素写入时存放到队列中的位置</span><br>recvx <span class="hljs-type">uint</span> <span class="hljs-comment">// 队列下标，指示元素从队列的该位置读出</span><br>recvq waitq <span class="hljs-comment">// 等待读消息的goroutine队列</span><br>sendq waitq <span class="hljs-comment">// 等待写消息的goroutine队列</span><br>lock mutex <span class="hljs-comment">// 互斥锁，chan不允许并发读写</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从数据结构的定义就可以看出来，chan内部实现了一个环形队列作为其缓冲区，队列的长度是在创建chan时指定的。</p><blockquote><p><strong>读&#x2F;写数据的goroutine阻塞的场景：</strong></p><p>从channel中读取数据时，如果缓冲区为空或者没有缓冲区，那么读取数据的goroutine会阻塞。</p><p>向channel中写数据时，如果缓冲区满了或者没有缓冲区，会导致向channel写数据的goroutine阻塞。</p><p>所以只要没有缓冲区，以上两种操作都会阻塞。</p></blockquote><h3 id="单向channel"><a href="#单向channel" class="headerlink" title="单向channel"></a>单向channel</h3><p>单向channel顾名思义，就是只能读或者只能写的channel。单向channel是对使用行为的一种限制，在实际使用过程中可以通过参数的定义来实现单项channel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span><span class="hljs-params">(chName &lt;- ch <span class="hljs-type">int</span>)</span></span> <span class="hljs-comment">// 通过参数限制只能从channel里读数据，传入的channel在read函数里只能读</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">(chName  ch &lt;- <span class="hljs-type">int</span>)</span></span> <span class="hljs-comment">// 通过参数限制只能从channel里写数据，传入的channel在write函数里只能写</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">noLimit</span><span class="hljs-params">(chName ch <span class="hljs-type">int</span>)</span></span> <span class="hljs-comment">// 没有只读或者只写的限制</span><br></code></pre></td></tr></table></figure><p>注意这里参数定义的写法，channel的ch关键字的位置和&lt;-的位置决定了是可读的还是可以写的，而channel的类型int总是放在最后。</p><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>示例程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> array [<span class="hljs-number">10</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> slice = array[<span class="hljs-number">5</span>:<span class="hljs-number">6</span>]<br>fmt.Println(<span class="hljs-string">&quot;length of slice: &quot;</span>, <span class="hljs-built_in">len</span>(slice))<br>fmt.Println(<span class="hljs-string">&quot;capacity of slice: &quot;</span>, <span class="hljs-built_in">cap</span>(slice))<br>fmt.Println(&amp;slice[<span class="hljs-number">0</span>]==&amp;array[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">length of slice:  1<br>capacity of slice:  5<br>false<br></code></pre></td></tr></table></figure><p>解释：slice和array共享内存空间，slice在数组的初试位置是array[5]，其容量一直到array的结尾也就是5，slice取array[5:6]是左闭右开的，slice的长度是1。slice[0]和array[5]的地址相同。这里slice不会用到数组头，除非slice指定从array[0]开始切片，<strong>默认slice占用的空间是到数组结束位置的。</strong></p><p>关于slice的长度增长：对slice进行append操作时，可能会使得slice占用的空间增长。append时如果slice检测到空间不足，会申请新空间，新存储空间的大小是原来的2倍或者1.25倍。如果append时空间充足，则slice不会扩容。一般扩容操作是如果原slice容量小于1024，则新slice的容量为原来的2倍。如果原slice的容量大于等于1024，则新slice的容量是原来的1.25倍。</p><p>切片时指定容量：比如<code>order[low:high:max]</code>表示新切片范围时[low:high)，新切片的容量是max-low。比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> array [<span class="hljs-number">10</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> slice = array[<span class="hljs-number">5</span>:<span class="hljs-number">6</span>:<span class="hljs-number">7</span>]<br>fmt.Println(<span class="hljs-string">&quot;length of slice: &quot;</span>, <span class="hljs-built_in">len</span>(slice))<br>fmt.Println(<span class="hljs-string">&quot;capacity of slice: &quot;</span>, <span class="hljs-built_in">cap</span>(slice))<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">length of slice:  1<br>capacity of slice:  2<br></code></pre></td></tr></table></figure><p>slice依据数组实现，底层数组对用户屏蔽，如果底层数组容量不足，则会实现自动重新分配并生成新的slice。所以数组和切片操作时可以作用于同一块内存，这个是需要格外注意的。</p><h3 id="slice-copy"><a href="#slice-copy" class="headerlink" title="slice copy"></a>slice copy</h3><p>使用copy操作两个切片时，会将源切片的数据逐一拷贝到目标切片指向的数组中，<strong>拷贝数量取两个切片长度的最小值。</strong>比如长度为10的切片拷贝到长度为5的切片时，只会拷贝5个元素，因为拷贝数量是两个切片长度的最小值，所以拷贝过程中不会发生扩容。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>创建slice可以预先分配理想的长度，避免切片扩容，这样可以提升性能。</p><p><strong>通过函数传递切片时，不会拷贝整个切片，因为切片只是一个struct而已。但是函数修改切片会影响到原始切片的值。</strong>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> array [<span class="hljs-number">10</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> slice = array[<span class="hljs-number">5</span>:<span class="hljs-number">6</span>:<span class="hljs-number">7</span>]<br>set(slice)<br>fmt.Println(array)<br>fmt.Println(slice)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">set</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span>&#123;<br>a[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[0 0 0 0 0 1 0 0 0 0]<br>[1]<br></code></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map底层是使用哈希表实现的。</p><p>哈希表可能会出现一个问题就是哈希冲突，负载因子就是一个衡量哈希冲突情况的指标，公式为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">负载因子 = 键数量/bucket数量<br></code></pre></td></tr></table></figure><blockquote><p>bucket相当于key进行某个操作后得到的哈希值，bucket里存储了key和key对应的value。如果map里的两个key的哈希值相同，那么这个哈希值对应的bucket里就存储了两条数据。查找时先找到key对应的bucket，再到bucket里找到这两对key value，看看哪个key才是要查找的那个key。某个bucket里存储的键值对越多，则存取效率越低。</p></blockquote><p>哈希表需要将负载因子控制在合理范围内，超过阈值需要重新进行rehash，也就是键值对重新组织：</p><p>如果哈希因子过小，则表示空间利用率比较小。如果哈希因子过大，则说明冲突严重，存取效率低。</p><blockquote><p>go的struct的字段经常携带Tag，该Tag主要用于反射场景。在reflect包里使用较多。</p></blockquote><h2 id="第二章-常见控制结构实现原理"><a href="#第二章-常见控制结构实现原理" class="headerlink" title="第二章 常见控制结构实现原理"></a>第二章 常见控制结构实现原理</h2><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>iota代表了const声明块的行索引。</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>Go标准库builtin给出了所有内置类型的定义，源代码位于src&#x2F;builtin&#x2F;builtin.go。</p><p>字符串拼接可以使用<code>str=&quot;aa&quot;+&quot;bbb&quot;</code>这样的方式拼接，即使有非常多的字符串需要拼接，性能上也会有比较好的保障，因为新字符串的内存空间是一次性分配完成的，所以性能主要在拷贝数据上。</p><p>问题：[]byte转换为string一定会拷贝内存吗？回答：不一定，编译器会识别场景，有时候会拷贝有时候不会，有时候只是需要临时字符串的场景下，byte切片转换为string不需要拷贝内存，而是直接返回一个string，这个string的指针（string.str）指向切片的内存。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>问题：下面的代码会输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deferFuncParameter</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> aInt = <span class="hljs-number">1</span><br><span class="hljs-keyword">defer</span> fmt.Println(aInt)<br><br>aaInt = <span class="hljs-number">2</span><br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出是1，因为fmt.Println(aInt)的参数在defer语句出现时就出现了，一直都是1，这个参数是一个值也不是引用。后面的修改不会影响defer时的值。</p><p>每次申请到一个需要释放的资源时，后面立刻追加释放资源的defer语句是一个好习惯。</p><p>关键词return不是一个原子操作，实际上执行了汇编指令ret，即执行跳转程序。比如return i，实际上是分两步，先将i值存入栈中作为返回值，然后执行跳转。</p><p>return是先保存返回值，执行defer（如果有的话），执行ret跳转</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span>&#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>i++<br>  &#125;()<br><span class="hljs-keyword">return</span> i<br>&#125; <span class="hljs-comment">// 运行结果是0</span><br></code></pre></td></tr></table></figure><p>这里foo函数的返回值是一个匿名返回值，对于匿名返回值，可以假定有一个变量存储了返回值，假设变量名叫annoy，上面的返回语句可以拆分成以下三个过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">annoy = i<br>i++<br><span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>所以defer中修改i值，对函数返回值不会影响。</p><p>那么对于非匿名的返回值，主函数声明一个带名字的返回值，会被初始化成一个局部变量，函数内部可以像使用局部变量一样使用该返回值。上面的函数，改成非匿名返回值运行结果是1，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> (i <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i++<br>&#125;()<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每个goroutine数据结构中实际上也有一个defer指针，该指针指向一个defer的单链表。每次声明一个defer就将defer插入单链表，每次执行defer时就从单链表表头取出一个defer执行。</p><p><strong>已经关闭的channel也是可读的。</strong></p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>执行下面的函数会有什么结果？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">select</span> &#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于空的select，程序会阻塞，准确说是当前协程被阻塞。但是go自带死锁检测机制，就发现当前协程再也没有机会被唤醒，程序会Panic。</p><p>Golang实现select时，定义了一个数据结构存储每个case，default实际上是一种特殊的case，select执行可以类比成一个函数，输入多个case，选出要执行的case输出，然后程序流转到选中的case上。</p><p>select语句除了default外，各个case的执行顺序是随机的。</p><p>select除了default外，每个case操作一个channel，要么读要么写。</p><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>问题：下面的函数能正常结束吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>v:=[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> i:=<span class="hljs-keyword">range</span> v&#123;<br>v=<span class="hljs-built_in">append</span>(v, i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>能正常结束，因为v的长度在循环前就确定了，循环内改变切片的长度也不会影响之前的结果。遍历slice前会先获取slice的长度作为循环次数。</p><p>对于map的遍历，map底层使用的是hash表实现，hash插入顺序是随机的，所以在循环过程中map中新增元素不一定能遍历到。</p><p>编程Tips：遍历过程中放弃接收index和value，可以一定程度提升性能。</p><p><strong>什么是自旋？</strong>自旋对应CPU的“PAUSE”命令，也就是CPU对该指令什么操作也不做，相当于CPU空转。对程序来说是sleep了一小段时间，时间非常短，当前实现是30个时钟周期。协程调度机制中的Process数量必须大于1，比如GOMAXPROCS()将处理器值设置为1就benign启用自旋。自旋的条件是很苛刻的，总而言之就是不忙的时候才会启用自旋。如果自旋过程中获得锁，那么之前被阻塞的协程则无法获取锁，如果加锁的协程特别多，每次都通过自旋获得锁，那么之前被阻塞的进程则很难获得锁，进而进入饥饿状态。</p><p>处于饥饿状态下，不会启用自旋。也就是一旦有协程释放了锁，那么一定会唤醒协程，被唤醒的协程将获得锁，同时把等待计数器减1。</p><p>重复加锁解锁会Panic，应该避免这样的操作。</p><p>读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁。</p><p><strong>读写锁是如何阻止读操作的？</strong></p><p>当写锁定进行时，会先把readerCount减去2^30，从而readerCount变成了负数，此时再有读锁定到来时，会检测到readerCount为负数，便知道此时有写操作在执行，只好阻塞等待。而真正的读操作个数并不会丢失，只需要将readCount加上2^30即可获得。所以，写操作时通过将readerCount变成负数来实现的。</p><h2 id="第三章-协程"><a href="#第三章-协程" class="headerlink" title="第三章 协程"></a>第三章 协程</h2><p>在高并发的场景下频繁创建线程会造成不必要的开销，所以有了线程池。线程池预留一定数量的线程，而新任务将不会以创建线程的方式去执行。</p><p>Goroutine调度器</p><p>Go提供了一种调度机制，可以在线程中自己实现调度，上下文切换更少，从而达到了线程数量更少，而并发数不会少的效果。而线程中调度的就是Goroutine。</p><p>Goroutine的主要概念如下：</p><p>G（Goroutine）：即Go协程，每个go关键字都会创建一个协程。</p><p>M（Machine）：工作线程，在Go中被称为Machine。</p><p>P（Processor）：处理器（Go中定义的一个概念，不是指CPU），包含运行Go代码的必要资源，也有调度goroutine的能力。</p><p>M必须拥有P才能执行G中的代码，P中包含多个G的队列，<strong>P可以提交G交给M执行。</strong>因为M必须拥有P才能运行Go代码，所以同时运行的M个数，也即线程数一般等于CPU的个数。一般情况下M的个数会略大于P的个数，多出来的M将会在G 产生系统调用的时候发挥作用。空闲的P也会把其他P中空闲的G投过来，每次偷去一半，来实现全局的执行加速。</p><h2 id="第四章-内存管理"><a href="#第四章-内存管理" class="headerlink" title="第四章 内存管理"></a>第四章 内存管理</h2><h3 id="自动垃圾回收机制"><a href="#自动垃圾回收机制" class="headerlink" title="自动垃圾回收机制"></a>自动垃圾回收机制</h3><p>C语言可以通过malloc()方法动态申请内存，其中内存分配器使用的是glibc提供的ptmalloc2。</p><p>span是用于管理arena页的关键因素。</p><p>所谓的垃圾就是不再需要的内存块，这些垃圾如果不被清理就没办法再次被分配利用，在不支持垃圾回收的编程语言里，这些垃圾内存就是泄露的内存。</p><p>为了防止内存分配过快，在GC的过程中，如果goroutine需要分配内存，那么这个goroutine会参与一部分GC的工作，即帮GC做一部分工作，这个机制叫Mutator Assist。</p><p>程序代码可以手动执行runtime.GC()来手动触发GC。</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>所谓逃逸分析（Escape  analysis）是指由编译器决定内存分配的位置，不需要程序员指定。函数中申请一个新对象：</p><ul><li>如果分配在栈中，则函数执行结束后可自动将内存回收。</li><li>如果分配在堆中，则函数执行结束后可交给GC（垃圾回收）处理。</li></ul><p>对于函数外部没有引用的对象，也有可能放到堆中，比如内存过大超过栈的存储能力。</p><p>下面是一个指针逃逸分析的场景：</p><p>Go可以返回局部变量地址，这是一个典型的变量逃逸的例子。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span>&#123;<br>Name <span class="hljs-type">string</span><br>Age <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StudentRegister</span><span class="hljs-params">(name <span class="hljs-type">string</span>, age <span class="hljs-type">int</span>)</span></span> *Student&#123;<br>s := <span class="hljs-built_in">new</span>(Student) <span class="hljs-comment">// 局部变量s逃逸到堆</span><br>s.Name =name<br>s.Age = age<br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>StudentRegister(<span class="hljs-string">&quot;Jim&quot;</span>, <span class="hljs-number">19</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>StudentRegister里的s是局部变量，其值通过函数返回值返回，s本身是一个指针，其指针指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。</p><p>通过编译参数-gcflag&#x3D;-m可以查编译过程中的逃逸分析。</p><p>总结：逃逸分析在编译阶段完成。</p><p>传递指针可以减少底层值的拷贝，可以提高效率，如果拷贝的数据量小，由于指针可能会产生逃逸，然后可能就会使用堆，增加GC负担，所以传递指针也不一定是高效的。</p><h2 id="第五章-并发控制"><a href="#第五章-并发控制" class="headerlink" title="第五章 并发控制"></a>第五章 并发控制</h2><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>Golang context是Golang常用的并发控制技术，它与WaitGroup的最大不同就是context对于派生的goroutine有更强的控制能力，它可以控制多级的goroutine。context翻译成中文就是上下文，它可以控制一组呈树状的goroutine，每个goroutine都有相同的上下文。比如某个goroutine派生来子goroutine，子goroutine派生出了新的子goroutine，此时使用WaitGroup就不方便，因为子goroutine的数量容易确定，此时使用context就很容易实现。</p><p>context实际上只定义了接口，只要实现了这个接口的类都可以是一种context，context的接口定义如下：</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span>&#123;<br>Deadline() (deadling time.Time, ok <span class="hljs-type">bool</span>)<br>Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>Err() <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当context关闭时，Done()返回了一个被关闭的管道，关闭的管道依然是可读的，据此goroutine可以收到关闭请求；当context还没有关闭时，Done()返回nil。</p><p>当context关闭时，Err()返回context的关闭原因。当context还没有关闭时，Err()返回nil。</p><p>context提供了4种方法创建不同类型的context，使用这4种方法如果没有父context，都需要传入background，即background作为其父节点：</p><ul><li>WithCancel()</li><li>WithDeadline()</li><li>WithTimeout()</li><li>WithValue()</li></ul><p>下面介绍一些实现了context的struct，比如valueCtx:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span>&#123;<br>Context<br>key, val <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>valueCtx只是在Context的基础上加了一个key-val对，用于在各级协程之间传递一些数据。由于valueCtx不需要cancel，也不需要deadline，那么只需要实现Value()接口即可。</p><p>下面是一个使用valueCt的案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleRequest</span><span class="hljs-params">(ctx context.Context)</span></span>&#123;<br><span class="hljs-keyword">for</span>&#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;HandleRequest Done.&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;HandleRequest running, parameter: &quot;</span>, ctx.Value(<span class="hljs-string">&quot;parameter&quot;</span>))<br>time.Sleep(<span class="hljs-number">2</span>*time.Second)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ctx:=context.WithValue(context.Background(), <span class="hljs-string">&quot;parameter&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)<br><span class="hljs-keyword">go</span> HandleRequest(ctx)<br><br>time.Sleep(<span class="hljs-number">10</span>*time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>本例中子协程无法结束，因为context是不可以cancel的，也就是&lt;-ctx.Done()永远无法返回。如果需要返回，则需要在创建context的时候指定一个可以cancel的context的作为父节点，使用父节点的cancel()在适当时机结束整个context。</p><h2 id="第六章-反射"><a href="#第六章-反射" class="headerlink" title="第六章 反射"></a>第六章 反射</h2><p>Go是静态类型语言，也就是每个变量都有一个静态类型，而且是在编译时就确定好了的。</p><p>interface代表了一种特殊的类型，它代表方法集合，它可以存放任何实现了该方法的值。空interface类型的方法集合是空，也就是说所有类型都可以认为是实现了该接口。</p><p>至于interface类型是如何表示的，可以查看下面的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> r io.Reader<br>tty, err:=os.OpenFile(<span class="hljs-string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>r = tty<br></code></pre></td></tr></table></figure><p>r的类型始终都是io.Reader interface类型，无论其存储的是什么值。</p><p>那么File类型体现在哪里呢？答案是r保存了一对(value, type)对来表示其存储的信息，value即r所持有的元素的值，type即其所持有的元素的底层值。</p><p><strong>interface类型是有个(value, type)对的，而反射就是检查interface的这个(valuel type)对的。</strong></p><p>下面的程序可以输出interface存储的类型和值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-type">float64</span> = <span class="hljs-number">3.4</span><br>t:=reflect.TypeOf(x) <span class="hljs-comment">// t is reflect.Type</span><br>fmt.Println(<span class="hljs-string">&quot;type:&quot;</span>, t)<br><br>v:=reflect.ValueOf(x) <span class="hljs-comment">// x is reflect.Value</span><br>fmt.Println(<span class="hljs-string">&quot;value:&quot;</span>, v)<br>&#125;<br></code></pre></td></tr></table></figure><p>反射是针对interface类型变量的，TypeOf()和ValueOf()接受的参数都是interface类型的，也就是x值是被转换成interface类型然后传入的。</p><p>再看下面的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-type">float64</span> = <span class="hljs-number">3.4</span><br>v:=reflect.ValueOf(x) <span class="hljs-comment">// v is reflect.Value</span><br><span class="hljs-keyword">var</span> y <span class="hljs-type">float64</span> = v.Interface().(<span class="hljs-type">float64</span>)<br>fmt.Println(<span class="hljs-string">&quot;value:&quot;</span>, y)<br>&#125;<br></code></pre></td></tr></table></figure><p>对象x转换成反射对象v，v又通过Interface()接口转换成interface对象。</p><p>reflect.ValueOf函数传入的其实是x的值，而非x本身。所以通过修改v是无法影响到x的。如果reflect.Value传入的是x的地址，那么之后修改v就会影响原始的x了。</p><p>reflect.Value提供了Elem()方法，可以获取指针指向的value，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-type">float64</span>=<span class="hljs-number">3.4</span><br>v:=reflect.ValueOf(&amp;x)<br>v.Elem().SetFloat(<span class="hljs-number">7.1</span>)<br>fmt.Println(<span class="hljs-string">&quot;x:&quot;</span>, v.Elem().Interface())<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果是：<code>x: 7.1</code></p><h2 id="第七章-go-test"><a href="#第七章-go-test" class="headerlink" title="第七章 go test"></a>第七章 go test</h2><p>测试文件可以和源文件在同一个包，但是常见的做法是创建一个包专门用于测试，这样可以使得测试文件和源文件隔离。GO源代码以及其他知名开源框架通常会创建测试包，测试的包的名字是原包的名字加上”_test”。</p><p>测试函数的命名规则是”Test__”，其中Test是单元测试的固定开头。</p><p>除了单元测试，还有种测试叫例子测试，例子测试函数名需要以”Example”开头。</p><p>此外还有TestMain。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMain</span><span class="hljs-params">(m *testing.M)</span></span>&#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;TestMain setup.&quot;</span>)<br>retCode := m.Run() <span class="hljs-comment">// 执行测试，包括单元测试，性能测试和示例测试</span><br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;TestMain tear-down.&quot;</span>)<br>os.Rxit(retCode)<br>&#125;<br></code></pre></td></tr></table></figure><p>日志打印的两行分别对应Setup和Tear-Down代码。m.Run()即为执行所有的测试，m.Run()的返回结果通过os.Exit()返回。</p><p>testing.T和testing.B属于testing包中的两个数据类型，该类型提供一系列的方法用于控制函数执行流程，考虑到二者有一定的相似性，所以Go实现时抽象出了一个testing.common作为一个基础类型。而testing.T和testing.B则属于testing.common的扩展。</p><p>common有很多方法，比如common.hasSub标记当前测试是否包含子测试，当测试使用t.Run()方法启动子测试时，t.hasSub则置为1。</p><p>common还有一个方法叫common.Log()用于记录简单日志，通过fmt.Sprintln()方法生成日志字符串后记录。</p><p>性能测试在代码里定义的结构体名字叫B，其有一个停止计时的函数：B.StopTimer()，StopTimer()负责停止计时，并累加响应的统计值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *B)</span></span> StopTimer()&#123;<br><span class="hljs-keyword">if</span> b.timderOn&#123;<br>b.duration = time.Since(b.Start) <span class="hljs-comment">// 累加测试耗时</span><br>runtime.ReadMemStats(&amp;memStats) <span class="hljs-comment">// 读取当前栈内存分配信息</span><br>b.netAllocs +=memStats.Mallocs = b.startAllocs <span class="hljs-comment">// 累加堆内存分配的字节数</span><br>b.timerOn=<span class="hljs-literal">false</span> <span class="hljs-comment">// 标记计时标志</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>StopTimer()并不一定是测试结束，一个测试中可能有多个统计阶段，所以其统计值是累加的。</p><p>性能测试的测试结果以最后一次迭代的数据为准，当然最后一次迭代则表示b.N更大，测试准确性更高。</p><p>关于测试结果的比较：输出有序的情况下，比较很简单，就是比较两个String的内容是否一致，无序的情况就是把String排序后再比较。</p><p>源代码里定义了一个testing.M的数据结构，单元测试、性能测试和示例测试在经过编译后都会被存放到一个testing.M的数据结构中，在执行测试时，该数据结构将传递给TestMain()，真正执行测试的是testimg.M的Run()方法。</p><p><strong>TestMain()函数通常有一个m.Run()函数，该方法会执行单元测试、性能测试和示例测试。</strong>如果用户实现了TestMain()但是没有调用m.Run()的话，则什么测试都不会被执行。</p><p>m.Run()不仅会执行测试，还会做一些初始化的工作，比如解析参数、启动定时器、根据工具参数指示创建一系列的文件等。</p><p>m.Run()会使用三个独立的方法来执行三种测试：</p><ul><li>单元测试：runTest(m.deps.MatchString, m.tests)</li><li>性能测试：runExample(m.deps.MatchString, m.examples)</li><li>示例测试：runBenchmarks(m.deps.ImportPath(), m.deps.MatchString, m.benchmarks)其中m.deps存放了测试匹配相关的内容。</li></ul><p>包列表模式是从Go1.10版本才引入的，它会把每个包的测试结果写入到本地临时文件作为缓存，下次执行时直接从缓存读取结果，从而节省测试时间。</p><p>go test有一个参数叫-cpu，比如-cpu 1,2,4，-cpu提供了一个CPU个数的参数，提供此列表后，那么测试将按照这个列表指定的CPU个数设置GOMAXPROCS并分别测试。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-built_in">AfterFuncDemo</span>()&#123;<br>log<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;AfterFuncDemo start:&quot;</span>, <span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Now</span>())<br><span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.After</span>(<span class="hljs-number">1</span>*<span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Second</span>, <span class="hljs-built_in">func</span>()&#123;<br>log<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;AfterFuncDemo end:&quot;</span>, <span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Now</span>())<br>&#125;)<br><span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Sleep</span>(<span class="hljs-number">2</span>*<span class="hljs-selector-tag">time</span>.Second) <span class="hljs-comment">// 等待协程退出</span><br>&#125;<br></code></pre></td></tr></table></figure><p>time.AfterFunc()是异步执行的，所以需要在函数最后sleep等待指定的协程推出，否则可能函数结束后协程还没有执行。</p><h2 id="第八章-定时器"><a href="#第八章-定时器" class="headerlink" title="第八章 定时器"></a>第八章 定时器</h2><p>每个Go应用程序都有一个协程专门负责管理所有的Timer。</p><p>Timer的数据结构定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Timer <span class="hljs-keyword">struct</span>&#123;<br>C &lt;- <span class="hljs-keyword">chan</span> Time<br>r runtimeTimer<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的C是面向Timer用户的，Timer.r是面向底层的定时器实现。</p><p>每创建一个Timer意味着创建一个runtimeTimer变量，然后把它交给系统进行监控。我们通过设置runtimeTimer过期后的行为达到定时的目的。</p><p>启动Timer的函数实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTimer</span><span class="hljs-params">(d Duration)</span></span> *Timer&#123;<br>c:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Time, <span class="hljs-number">1</span>) <span class="hljs-comment">// 创建一个管道</span><br>t:=&amp;Timer&#123;<br>when: when(d), <span class="hljs-comment">// 触发事件</span><br>f: sendTime, <span class="hljs-comment">// 触发后执行函数sendTime</span><br>arg: c, <span class="hljs-comment">// 触发后执行函数sendTime时附带的参数</span><br>&#125;<br>  startTimer(&amp;t.r) <span class="hljs-comment">// 此时启动定时器，只是runtimeTimer放到系统协程的堆中，由系统协程维护</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Ticker的数据结构和Timer完全一致：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Ticker <span class="hljs-keyword">struct</span>&#123;<br>C &lt;-<span class="hljs-keyword">chan</span> Time<br>r runtimTimer<br>&#125;<br></code></pre></td></tr></table></figure><p>Ticker对外仅暴露一个channel，指定的时候到来时就往该channel中写入系统时间，也就是一个事件。</p><p>定时器Timer和周期性定时器Ticker，这两种定时器的内部实现机制完全相同。创建定时器的协程并不负责计时，而是把任务交给系统协程，系统协程统一处理所有的定时器。系统协程在首次创建定时器时创建，定时器存储在切片中，系统协程负责计时并维护这个切片。</p><p>创建定时器的运作机制：</p><p>创建Timer或者Ticker实际上分为两步：</p><ol><li>创建一个管道</li><li>创建一个timer并启动（这里是timer而不是Timer，这里的timer时系统所管理的timer）</li></ol><p>每个timer都必须归属到某个timersBucket，第一步就是选择一个timersBucket，选择的算法很简单：将当前协程所属的Processor ID和timersBucket数组长度求模，结果就是timersBucket数组的下标。</p><p>每个timer都必须要加入到timersBucket中，timerBucket中切片保存着timer的指针，新加入的timer并不是按照加入时间顺序存储的，<strong>而是把timer按照触发的时间排序成一个小头堆。</strong>在小头堆里，每个圆圈代表一个timer，圆圈里的数字代表距离触发事件的秒数，圆圈外的我数字代表其在切片中的下标。新加入timer会触发小头堆的排序。</p><p>不管什么情况，创建一个Ticker后，在后面追加defer语句来关闭Ticker是一个好习惯。</p><h2 id="第九章-语法糖"><a href="#第九章-语法糖" class="headerlink" title="第九章 语法糖"></a>第九章 语法糖</h2><p>语法糖（Syntactic sugar）的概念是英国计算机科学家提出的，表示编程语言中某种类型的语法，这类语法不会影响功能，但是使用起来很方便。</p><p>语法糖的其中一个用法就是简短变量声明，比如<code>field, offset := nextField(str, 0)</code>。</p><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">field1, offset := nextField(str, <span class="hljs-number">0</span>)<br>field2, offset := nextField(str, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>:&#x3D; 实现的效果是重新声明，这里的offset被重新声明，重新声明并没有问题，没有引入新变量，只是把变量的值给改掉了。</p><p>在<code>:=</code>左侧没有新变量是不允许的。</p><p>可以理解<code>:=</code>实际上会被拆分成两个部分，即声明和赋值，赋值语句不能出现在函数外部。</p><p>关于可变参函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greeting</span><span class="hljs-params">(prefix <span class="hljs-type">string</span>, who ...<span class="hljs-type">string</span>)</span></span>&#123;<br><span class="hljs-keyword">if</span> who == <span class="hljs-literal">nil</span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;nobody to say hi&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> _,people :=<span class="hljs-keyword">range</span> who&#123;<br>fmt.Prinf(<span class="hljs-string">&quot;%s %s\n&quot;</span>, prefix, people)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的who就是可变参数，可变参数在函数内部是作为切片来解析的。</p><p>切片传入时不会生成新的切片，也就是函数内部使用的切片和传入的切片共享相同的存储空间。也就是函数内部修改了切片的值，可能影响外部调用的函数。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MTU对数据包大小的影响及原因分析</title>
    <link href="/2023/12/07/MTU%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%8C%85%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%BD%B1%E5%93%8D%E5%8F%8A%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    <url>/2023/12/07/MTU%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%8C%85%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%BD%B1%E5%93%8D%E5%8F%8A%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h2><p><strong>最大传输单元</strong>（Maximum Transmission Unit，缩写MTU）指在数据链路层上能传输的最大的数据包大小（以字节为单位）</p><p>如果发送端发送的数据包大小大于了发送端到接收端路上某台设备的MTU，那么会造成报文分段甚至丢弃，加重网络传输的负担。</p><p>不同的厂商，不同厂商的不同型号的设备对MTU的定义也可能不一样。</p><h3 id="为什么需要MTU"><a href="#为什么需要MTU" class="headerlink" title="为什么需要MTU"></a>为什么需要MTU</h3><p>在网络传输中，数据包过大，会导致传输时间变长，传输过程中如果传输失败，对应的传输代价也比较大。数据包较小，则设备需要处理更多的报文，这个比较考验设备的线程转发能力，传输的有用信息占数据包的比例较低，传输效率低。</p><p>设置MTU可以将数据包大小控制在合理范围内，提高传输效率。</p><p>PPPoE网的MTU通常是1492。以太网的MTU通常为1500字节，这个1500是最大的承载IP层及以上层数据的最大长度，故以太网数据帧的最大长度是1518字节（1518是在1500的基础上加上以太网的14字节的帧头和4字节的帧尾CRC校验部分）。</p><p><img src="/../images/image-20231207112949818.png" alt="image-20231207112949818"></p><p>受MTU的影响，数据包可能被分片。分片可以在源主机或者到目的主机路径上的传输路径上任意一台路由器执行，但是重组只能在目的主机执行。</p><blockquote><p>注意，有的时候捕获到的数据包不会有数据链路层的信息：</p><p>在捕获本地回环接口（lo0）的数据包时，通常不会显示数据链路层的信息。这是因为本地回环接口是一个虚拟的网络接口，它主要用于本地主机内部的通信，数据包在传输时并不经过物理网络链路，也就是说不存在真正的数据链路层。</p><p>因此，在捕获本地回环接口的数据包时，Wireshark 只会显示上层协议的信息，如网络层（IPv4、IPv6）、传输层（TCP、UDP）和应用层（HTTP、DNS）等。你可以查看捕获到的数据包的上层协议信息，但不会看到数据链路层的信息。</p></blockquote><h3 id="数据包太大受MTU限制而产生分片的情况"><a href="#数据包太大受MTU限制而产生分片的情况" class="headerlink" title="数据包太大受MTU限制而产生分片的情况"></a>数据包太大受MTU限制而产生分片的情况</h3><p>比如主机发送大小为2000字节的数据包，这个2000是UDP层的数据包长度，包含了UDP头部。假设出接口的MTU是1500，那么2000超过了MTU，则需要分片。</p><p>到了IP层，需要加上长度为20的IP头部，那么此时总长度是2000+20&#x3D;2020，Payload长度是2000。因为<strong>MTU的限制是对IP层的数据包（包括了IP头部）的限制</strong>，则原数据包分为两段，分别是长度20的IP头部加上1480的Payload，还有长度20的IP头部加上剩余的2000-1480&#x3D;520。两个数据包都有IP头部，IP头部的标志位中的MF用来分辨这是不是最后一个分片，片偏移用来分辨这个分片相对原数据报的位置。通过这几个字段，可以准确的完成数据报的重组操作。</p><p><img src="/../images/image-20231207163741299.png" alt="image-20231207163741299"></p><h2 id="wireshark显示的数据包长度说明"><a href="#wireshark显示的数据包长度说明" class="headerlink" title="wireshark显示的数据包长度说明"></a>wireshark显示的数据包长度说明</h2><h3 id="不包括FCS"><a href="#不包括FCS" class="headerlink" title="不包括FCS"></a>不包括FCS</h3><p><strong>wireshark显示的数据帧长度不包括FCS(Frame check sequence)[帧校验序列]</strong></p><p>gopacket抓到的数据包也是不包括FCS的</p><p>这两个抓包相关工具都不关注FCS，这是因为FCS是网络适配器校验使用的，抓包工具关注的是在网络上流动的原始数据。</p><h3 id="wireshark会截断数据包"><a href="#wireshark会截断数据包" class="headerlink" title="wireshark会截断数据包"></a>wireshark会截断数据包</h3><p>有时候wireshark可能会截断数据包，比如在Wireshark里查看抓的包，有时候会显示<code>[Packet size limited during capture: xxxxxx truncated]</code>。这是因为wireshark使用的抓包机制（比如libpcap或者winpcap）是允许设置抓到的包的大小的，通常设置抓包大小是因为抓包者只关注一些协议（比如IP&#x2F;TCP&#x2F;UDP协议）的头信息而不关注payload部分。</p><p>当设置了snaplen选项，那么只能抓到snaplen长度的数据包，数据包超出snaplen的部分会被截断。如果想要抓完整的数据包，可以将snaplen设置为默认值，通常是65535。</p><p>但是wireshark显示的长度仍然是完整的长度，只是显示的数据是部分数据。</p><p>下面是一个例子：</p><p><img src="/../images/image-20231208145325191.png" alt="image-20231208145325191"></p><p>这个数据包的大小是8136字节，但是因为限制了snaplen为1024，所以相当于只存储了包的前1024个字节，右边显示了这个包的原始数据。一共是64行，每行是16个字节，一共是64*16&#x3D;1024个字节。因为大部分时候只关注协议头，不关注具体负载数据，所以设置成2024是足够的，可以看到协议头，同时也可以减少存储空间。</p><p>这里的TCP payload显示的是数据包的payload的长度8070字节，这是真实的传输环境中的数据长度，只是payload部分受snaplen的影响被截断了。</p><h2 id="数据包长度大于MTU的情况"><a href="#数据包长度大于MTU的情况" class="headerlink" title="数据包长度大于MTU的情况"></a>数据包长度大于MTU的情况</h2><p>我连接了VPN，这样就可以访问内网了。然后通过scp往内网的一台服务器上拷贝文件，拷贝的同时用wireshark抓V本机PN的网卡的流量，发现拷贝结束后所有的数据包的大小都没有超过mtu，最大也只有1401。我电脑上连接VPN的网卡是utun5。</p><p>下面去到内网的被拷贝文件过去的目标服务器查看抓到的包，发现有很多包的大小都超过了mtu。比如长度为4101字节的就有一堆。</p><p><img src="/../images/image-20231208112903299.png" alt="image-20231208112903299"></p><h2 id="原因相关概念"><a href="#原因相关概念" class="headerlink" title="原因相关概念"></a>原因相关概念</h2><p>在网络上搜寻了下，网卡有很多支持的功能，有些功能是对发送端有效，有些对接收端有效。这些功能和MTU相关的，会影响数据包大小的，主要有以下几个：</p><h3 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h3><h4 id="TSO和USO"><a href="#TSO和USO" class="headerlink" title="TSO和USO"></a>TSO和USO</h4><p>TSO全程TCP Segment Offload，有很多网卡都支持TSO。有时候也被叫做LSO（Large Segment Offload）。TSO的作用就是把原本由内核做的拆包工作转移到网卡。支持TSO的网卡可以降低CPU的负载，提高网络带宽。TSO是一种硬件卸载技术，旨在将TCP分流的过程从CPU卸载到网卡。</p><p>TSO是针对TCP的，USO是针对UDP的。</p><p>TSO提供了一个缓冲区，然后由网卡将缓存的数据包拆分成小于MTU和MSS的小包。</p><p>在不支持TSO的网卡上，TCP层向IP层发送数据会考虑MSS，使得TCP向下发送的数据可以包含在一个IP分组中。</p><p>网卡支持TSO时，TCP层会慢慢增大MSS，一般都是整数倍增加，添加TCP头传给IP层。网卡接受到IP层的大数据包会将包分成若干个小的IP包。这样网卡就把CPU要做的分组的工作自己承接过来做好了。</p><p><strong>如果TSO开启，那么GSO会自动开启。</strong></p><h4 id="GSO"><a href="#GSO" class="headerlink" title="GSO"></a>GSO</h4><p>GSO(Generic Segmentation Offload)比TSO更通用。基本思想就是尽可能推迟数据分片直至达到网卡前，到达网卡前会检查网卡是否支持分片功能比如TSO，支持则发往网卡给网卡分片，否则将分片的工作推迟到发到网卡的前一刻执行。</p><h3 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h3><h4 id="LRO"><a href="#LRO" class="headerlink" title="LRO"></a>LRO</h4><p>全称large-receive-offload，基本功能就是将接收到的多个TCP数据包聚合成一个更大的数据包，交给网络协议栈处理。作用于网卡。</p><h4 id="GRO"><a href="#GRO" class="headerlink" title="GRO"></a>GRO</h4><p>全称generic-receive-offload。与LRO相似，更通用。在LRO的基础上新增作用于离开网卡加入网络协议栈的时候。是LRO的软实现，合并条件更加灵活。</p><h3 id="分片示意图"><a href="#分片示意图" class="headerlink" title="分片示意图"></a>分片示意图</h3><p>下面是上述的几个功能开启或者关闭时的分片情况，在何处分片等，图源网络。</p><h4 id="发送端-1"><a href="#发送端-1" class="headerlink" title="发送端"></a>发送端</h4><p>TSO关闭，GSO关闭</p><p><img src="/../images/image-20231208174000867.png" alt="image-20231208174000867"></p><p>TSO开启，GSO自动开启</p><p><img src="/../images/image-20231208174034001.png" alt="image-20231208174034001"></p><h3 id="接收端-1"><a href="#接收端-1" class="headerlink" title="接收端"></a>接收端</h3><p>LRO 关闭，GRO 关闭</p><p><img src="/../images/image-20231208174139218.png" alt="image-20231208174139218"></p><p>LRO开启：数据包在网卡被合并</p><p><img src="/../images/image-20231208174203682.png" alt="image-20231208174203682"></p><p>GRO开启</p><p><img src="/../images/image-20231208174306605.png" alt="image-20231208174306605"></p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>发送端即我的本机，使用的网卡是utun5，查看utun5的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig utun5                                                     <br>utun5: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500<br>inet 172.16.48.126 --&gt; 172.16.48.125 netmask 0xffffffff<br></code></pre></td></tr></table></figure><p>可以看到utun5不支持TSO，这是因为utun5是一个虚拟网卡，不是物理网卡。</p><blockquote><p>查看我的物理网卡en0，可以看到物理网卡是支持TSO的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig en0                                                       <br>en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500<br>options=6463&lt;RXCSUM,TXCSUM,TSO4,TSO6,CHANNEL_IO,PARTIAL_CSUM,ZEROINVERT_CSUM&gt;<br>ether 38:f9:d3:7d:03:9c<br>inet 192.168.22.56 netmask 0xffffff00 broadcast 192.168.22.255<br>nd6 options=201&lt;PERFORMNUD,DAD&gt;<br>media: autoselect<br>status: active<br></code></pre></td></tr></table></figure></blockquote><p><strong>Wireshark抓的包是从内核到网卡的，</strong>网卡不支持分片，只能消耗CPU让内核做分片。所以抓到的的从内核到网卡的数据包都是被内核分片好的。此时的流程是：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm">               抓包<br>网卡&lt;-<span class="hljs-comment">----------------------------内核</span><br>不支持<span class="hljs-type">TSO</span>                         做拆包的工作<br></code></pre></td></tr></table></figure><p>目标服务器的工作网卡是ens5f0。查看其是否支持LRO或者GRO。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# ethtool -k ens5f0|grep large-receive-offload<br>large-receive-offload: off [fixed]<br>[root@localhost ~]# ethtool -k ens5f0|grep generic-receive-offload<br>generic-receive-offload: on<br></code></pre></td></tr></table></figure><p>可以看到其支持GRO。GRO会在离开网卡达到协议栈时做聚合。此时Wireshark抓的包是从网卡到内核的，抓到的包时通过GRO聚合完成的，所以聚合前的各个小包小于MTU，聚合完成后的包大小会大于MTU。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">               抓包<br>网卡<span class="hljs-comment">-----------------------------&gt;内核</span><br>支持GRO                          <br></code></pre></td></tr></table></figure><p>参考文章</p><p><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/MTU.html">https://info.support.huawei.com/info-finder/encyclopedia/zh/MTU.html</a></p><p><a href="https://blog.csdn.net/LearnLHC/article/details/115228649">https://blog.csdn.net/LearnLHC/article/details/115228649</a></p><p><a href="https://osqa-ask.wireshark.org/questions/50808/packet-size-limited-during-capture-xxxxxx-truncated/">https://osqa-ask.wireshark.org/questions/50808/packet-size-limited-during-capture-xxxxxx-truncated/</a></p><p><a href="https://www.modb.pro/db/50701">https://www.modb.pro/db/50701</a></p><p><a href="https://luckymrwang.github.io/2022/07/27/SmartNIC-%E2%80%94-TSO%E3%80%81GSO%E3%80%81LRO%E3%80%81GRO-%E6%8A%80%E6%9C%AF/">https://luckymrwang.github.io/2022/07/27/SmartNIC-%E2%80%94-TSO%E3%80%81GSO%E3%80%81LRO%E3%80%81GRO-%E6%8A%80%E6%9C%AF/</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>北极星configMao更新</title>
    <link href="/2023/11/02/%E5%8C%97%E6%9E%81%E6%98%9FconfigMap%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/11/02/%E5%8C%97%E6%9E%81%E6%98%9FconfigMap%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="北极星简介"><a href="#北极星简介" class="headerlink" title="北极星简介"></a>北极星简介</h2><p>参考<a href="https://polarismesh.cn/docs/%E5%8C%97%E6%9E%81%E6%98%9F%E6%98%AF%E4%BB%80%E4%B9%88/%E7%AE%80%E4%BB%8B/">官方文档</a></p><p>北极星是腾讯开源的服务治理平台。</p><p>北极星致力于打造一个支持多语言、多框架的服务治理平台，帮助用户解决分布式服务或者微服务架构中的服务管理、流量管理、配置管理、故障容错和可观测性问题。</p><p>北极星具备服务管理、流量管理、故障容错、配置管理和可观测性五大功能</p><h2 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h2><p>ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。</p><p>ConfigMap 是一种用于存储配置数据的 API 资源。它允许你将配置信息从应用程序中分离出来，使得配置能够在不重新构建镜像或重启 Pod 的情况下进行更新。类似于实现配置的热更新。</p><p>configMap是一个文件，格式参考：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">database-url:</span> <span class="hljs-string">&quot;mysql://username:password@mysql-server:3306/mydatabase&quot;</span><br>  <span class="hljs-attr">api-key:</span> <span class="hljs-string">&quot;abcdef123456&quot;</span><br>  <span class="hljs-attr">max-connections:</span> <span class="hljs-string">&quot;10&quot;</span><br></code></pre></td></tr></table></figure><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>ConfigMap 可以通过卷挂载到 Pod 的容器内，使得容器可以读取其中的配置信息。</p><p>程序可以通过不同的方式访问 ConfigMap 中的配置信息：ConfigMap 的数据可以通过环境变量注入到容器内，ConfigMap 的数据可以通过卷挂载到容器内的文件系统。程序可以直接读取这些文件来获取配置信息。或者程序可以直接从 Kubernetes API 中获取 ConfigMap 的数据。</p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>有几种常见的方式可以更新 ConfigMap 中的配置信息：</p><p><strong>手动更新：</strong> 你可以直接通过编辑 ConfigMap 对象的 YAML 文件或使用命令行工具（如 <code>kubectl edit configmap</code>）手动更新 ConfigMap 的数据。</p><p><strong>通过命令行工具 kubectl replace：</strong> 使用 <code>kubectl replace</code> 命令可以用新的 ConfigMap 替换旧的 ConfigMap。这个命令会将整个 ConfigMap 替换为新的内容。</p><p><strong>通过命令行工具 kubectl apply</strong></p><p><strong>通过 API 更新：</strong> 通过 Kubernetes 的 API，可以使用客户端库或直接发送 HTTP 请求来更新 ConfigMap。</p><p><strong>使用 Helm：</strong> Helm 是 Kubernetes 的一个包管理工具，可以用于部署和管理应用程序。通过 Helm Charts，你可以定义配置文件，并在需要更新时通过 Helm 更新部署。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gopacket的TCP重组</title>
    <link href="/2023/09/01/gopacket%E7%9A%84TCP%E9%87%8D%E7%BB%84/"/>
    <url>/2023/09/01/gopacket%E7%9A%84TCP%E9%87%8D%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当http请求或者响应太大时，请求或者返回的数据会被分成多个网络数据包，<strong>想知道具体的报文内容则需要进行TCP重组。另一个问题是关于http响应时间的计算</strong>，因为请求或者响应可能是又多个网络数据包组成的，每个数据包的时间戳也不相同，所以计算响应时间应该根据哪个数据包的时间戳也是一个需要思考的问题。我查阅了相关资料，总结出应该http响应时间应该用响应的最后一个数据包的时间戳减去请求的最后一个数据包的时间戳（Wireshark也是这样计算的）。下面是一个简单的例子，这个例子的http响应数据较大，被分成了多个数据包：</p><p>请求是一个简单的HTTP GET请求：</p><p><img src="/../images/image-20230421112651028.png" alt="image-20230421112651028"></p><p>由请求的最后一行[Response in frame:53]，查看No.53的数据包</p><p><img src="/../images/image-20230421112846949.png" alt="image-20230421112846949"></p><p>可以看到Wireshark上显示了完整的http报文，http响应中包含了非常多的字符c。也显示了[20 Reassembled TCP Segments(300109 bytes)..]，说明wireshark进行了TCP重组，使用了20个TCP分片重组得到了完整的http响应报文。</p><p>点开[20 Reassembled TCP Segments(300109 bytes)..]，可以看到使用的所有的TCP分片</p><p><img src="/../images/image-20230421113058890.png" alt="image-20230421113058890"></p><p>查看第一个TCP分片即Frame 19</p><p><img src="/../images/image-20230421113442834.png" alt="image-20230421113442834"></p><p>其TCP Payload是http响应报文的格式，但是因为http body太长，这个分片无法负载完整http body，所以剩下的http body被分到其他的TCP分片中。</p><p>再随机点入一个TCP分片比如Frame33：</p><p><img src="/../images/image-20230421113224094.png" alt="image-20230421113224094"></p><p>可以看到其TCP payload都是ccc，<strong>TCP重组就是选出了所有的需要重组的TCP分片，然后将这些TCP分片的TCP Payload组合得到完整的数据。</strong></p><h2 id="测试HTTP请求TCP重组的注意事项"><a href="#测试HTTP请求TCP重组的注意事项" class="headerlink" title="测试HTTP请求TCP重组的注意事项"></a>测试HTTP请求TCP重组的注意事项</h2><h3 id="客户端的随机端口"><a href="#客户端的随机端口" class="headerlink" title="客户端的随机端口"></a>客户端的随机端口</h3><p>客户端发送http请求时，客户端使用的端口是系统随机分配的，当我写了一个脚本，在这个脚本发送了2次http请求时，这2次http请求的端口使用的也是不同的，虽然在同一个脚本。</p><h3 id="tcp包中如何知道应用层协议是什么"><a href="#tcp包中如何知道应用层协议是什么" class="headerlink" title="tcp包中如何知道应用层协议是什么"></a>tcp包中如何知道应用层协议是什么</h3><p>在TCP包中，我们无法直接知道应用层协议是什么，因为TCP只是一种传输层协议，它不关心上层的协议是什么。但是，在TCP包的数据部分，我们可以根据端口号来猜测上层协议的类型。因为在TCP连接建立时，客户端和服务器端会约定使用特定的端口号来传输数据，而这些端口号通常会对应着一种特定的应用层协议。比如，HTTP通常使用80端口，HTTPS通常使用443端口，SMTP通常使用25端口等等。因此，我们可以根据TCP包的目的端口号来猜测上层协议的类型。但是需要注意的是，这种方法并不完全准确，因为端口号并不是一成不变的，而且也有可能使用非标准的端口号。</p><h2 id="gopacket对分片的支持"><a href="#gopacket对分片的支持" class="headerlink" title="gopacket对分片的支持"></a>gopacket对分片的支持</h2><p>关于TCP 重组，可以先看官方给出的一个比较通俗易懂的<a href="https://github.com/google/gopacket/blob/master/examples/httpassembly/main.go">例子</a></p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/google/gopacket&quot;</span><br><span class="hljs-string">&quot;github.com/google/gopacket/examples/util&quot;</span><br><span class="hljs-string">&quot;github.com/google/gopacket/layers&quot;</span><br><span class="hljs-string">&quot;github.com/google/gopacket/pcap&quot;</span><br><span class="hljs-string">&quot;github.com/google/gopacket/tcpassembly&quot;</span><br><span class="hljs-string">&quot;github.com/google/gopacket/tcpassembly/tcpreader&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> iface = flag.String(<span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;eth0&quot;</span>, <span class="hljs-string">&quot;Interface to get packets from&quot;</span>)<br><span class="hljs-keyword">var</span> fname = flag.String(<span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;Filename to read from, overrides -i&quot;</span>)<br><span class="hljs-keyword">var</span> snaplen = flag.Int(<span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-number">1600</span>, <span class="hljs-string">&quot;SnapLen for pcap packet capture&quot;</span>)<br><span class="hljs-keyword">var</span> filter = flag.String(<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-string">&quot;tcp and dst port 80&quot;</span>, <span class="hljs-string">&quot;BPF filter for pcap&quot;</span>)<br><span class="hljs-keyword">var</span> logAllPackets = flag.Bool(<span class="hljs-string">&quot;v&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;Logs every packet in great detail&quot;</span>)<br><br><span class="hljs-comment">// Build a simple HTTP request parser using tcpassembly.StreamFactory and tcpassembly.Stream interfaces</span><br><br><span class="hljs-comment">// httpStreamFactory implements tcpassembly.StreamFactory</span><br><span class="hljs-keyword">type</span> httpStreamFactory <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// httpStream will handle the actual decoding of http requests.</span><br><span class="hljs-keyword">type</span> httpStream <span class="hljs-keyword">struct</span> &#123;<br>net, transport gopacket.Flow<br>r              tcpreader.ReaderStream<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *httpStreamFactory)</span></span> New(net, transport gopacket.Flow) tcpassembly.Stream &#123;<br>hstream := &amp;httpStream&#123;<br>net:       net,<br>transport: transport,<br>r:         tcpreader.NewReaderStream(),<br>&#125;<br><span class="hljs-keyword">go</span> hstream.run() <span class="hljs-comment">// Important... we must guarantee that data from the reader stream is read.</span><br><br><span class="hljs-comment">// ReaderStream implements tcpassembly.Stream, so we can return a pointer to it.</span><br><span class="hljs-keyword">return</span> &amp;hstream.r<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *httpStream)</span></span> run() &#123;<br>buf := bufio.NewReader(&amp;h.r)<br><span class="hljs-keyword">for</span> &#123;<br>req, err := http.ReadRequest(buf)<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-comment">// We must read until we see an EOF... very important!</span><br><span class="hljs-keyword">return</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;Error reading stream&quot;</span>, h.net, h.transport, <span class="hljs-string">&quot;:&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>bodyBytes := tcpreader.DiscardBytesToEOF(req.Body)<br>req.Body.Close()<br>log.Println(<span class="hljs-string">&quot;Received request from stream&quot;</span>, h.net, h.transport, <span class="hljs-string">&quot;:&quot;</span>, req, <span class="hljs-string">&quot;with&quot;</span>, bodyBytes, <span class="hljs-string">&quot;bytes in request body&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> util.Run()()<br><span class="hljs-keyword">var</span> handle *pcap.Handle<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><br><span class="hljs-comment">// Set up pcap packet capture</span><br><span class="hljs-keyword">if</span> *fname != <span class="hljs-string">&quot;&quot;</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;Reading from pcap dump %q&quot;</span>, *fname)<br>handle, err = pcap.OpenOffline(*fname)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;Starting capture on interface %q&quot;</span>, *iface)<br>handle, err = pcap.OpenLive(*iface, <span class="hljs-type">int32</span>(*snaplen), <span class="hljs-literal">true</span>, pcap.BlockForever)<br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-keyword">if</span> err := handle.SetBPFFilter(*filter); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-comment">// Set up assembly</span><br>streamFactory := &amp;httpStreamFactory&#123;&#125;<br>streamPool := tcpassembly.NewStreamPool(streamFactory)<br>assembler := tcpassembly.NewAssembler(streamPool)<br><br>log.Println(<span class="hljs-string">&quot;reading in packets&quot;</span>)<br><span class="hljs-comment">// Read in packets, pass to assembler.</span><br>packetSource := gopacket.NewPacketSource(handle, handle.LinkType())<br>packets := packetSource.Packets()<br>ticker := time.Tick(time.Minute)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> packet := &lt;-packets:<br><span class="hljs-comment">// A nil packet indicates the end of a pcap file.</span><br><span class="hljs-keyword">if</span> packet == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> *logAllPackets &#123;<br>log.Println(packet)<br>&#125;<br><span class="hljs-keyword">if</span> packet.NetworkLayer() == <span class="hljs-literal">nil</span> || packet.TransportLayer() == <span class="hljs-literal">nil</span> || packet.TransportLayer().LayerType() != layers.LayerTypeTCP &#123;<br>log.Println(<span class="hljs-string">&quot;Unusable packet&quot;</span>)<br><span class="hljs-keyword">continue</span><br>&#125;<br>tcp := packet.TransportLayer().(*layers.TCP)<br>assembler.AssembleWithTimestamp(packet.NetworkLayer().NetworkFlow(), tcp, packet.Metadata().Timestamp)<br><br><span class="hljs-keyword">case</span> &lt;-ticker:<br><span class="hljs-comment">// Every minute, flush connections that haven&#x27;t seen activity in the past 2 minutes.</span><br>assembler.FlushOlderThan(time.Now().Add(time.Minute * <span class="hljs-number">-2</span>))<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><h3 id="FlushOlderThan"><a href="#FlushOlderThan" class="headerlink" title="FlushOlderThan"></a>FlushOlderThan</h3><p>源码里，其实这个函数就是调用了FlushWithOptions，下面介绍FlushWithOptions的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// FlushOlderThan calls FlushWithOptions with the CloseAll option set to true.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Assembler)</span></span> FlushOlderThan(t time.Time) (flushed, closed <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">return</span> a.FlushWithOptions(FlushOptions&#123;CloseAll: <span class="hljs-literal">true</span>, T: t&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>FlushWithOptions的定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Assembler)</span></span> FlushWithOptions(opt FlushOptions) (flushed, closed <span class="hljs-type">int</span>) <br></code></pre></td></tr></table></figure><p>FlushWithOptions函数的返回值的含义为刷新的连接数，以及其中因刷新而关闭的连接数。</p><p>FlushWithOptions遍历所有streams，找到比给定时间更老的stream，然后把该stream的数据进行选择再将选择后的数据推送到 Stream 的 Reassembled 函数。也就是告诉这些比给定时间更老的stream停止接受新的数据包<br>每一个Stream都包含了多个按照时间顺序接收到的字节集合，比如某个Stream处理了序号10，这个Stream的多个字节集合可能为[15-20),[20-25),[30,50)这三个字节集合，每一个字节集合都有一个对应的时间戳。</p><p>FlushWithOptions被调用后会查看该Stream的所有字节集合，如果[15-20)比输出的给定时间更老，FlushWithOptions将把[15-20)和所有连续的字节集合推送到 Stream 的 Reassembled 函数，在这个例子里会推送[15-20)和[20-25)因为这两个字节集合是连续的。只有当[30-50)的时间戳比给定时间更老的时候才会推送[30-50)到Stream 的 Reassembled 函数，否则会等到下一个FlushOlderThan调用看看缺失的[25-30)数据是否到来。<br>这里给出的例子其实发送方是发送了完整的字节[15-50)，只是在传输中被分组了，分到了多个字节集合。而这几个字节集合到达接收方的先后顺序是不一定的，在这个例子里，[25-30)这个集合就是最后到达的，这也是为什么一定要推送连续的字节集合到Reassembled函数的原因。</p><p>如果FlushWithOptions推送了所有字节（或者没有字节集合小于给定时间）并且连接自传入时间以来未收到任何字节，则连接将关闭。</p><p>###Reassembly</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reassembly <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-comment">// Bytes为TCP payload，可能需要base64 encode查看具体内容</span><br>Bytes []<span class="hljs-type">byte</span><br>  <span class="hljs-comment">// 如果在这次重组和上一次重组之间跳过了字节，则 Skip 设置为非零。 如果这是连接中的第一个数据包并且我们没有看到开始，我们不知道我们跳过了多少字节，所以我们将它设置为 -1。 否则，它被设置为跳过的字节数。</span><br>  <span class="hljs-comment">// 用于场景应该是分片达到的时间的不一致情况，如果后面的分片比前面的分片先到达了，那么Skip应该就是非0</span><br>Skip <span class="hljs-type">int</span><br>Start <span class="hljs-type">bool</span><br>End <span class="hljs-type">bool</span><br>  <span class="hljs-comment">// 数据包的时间戳</span><br>Seen time.Time<br>&#125;<br></code></pre></td></tr></table></figure><p>被分片的情况下，第一个分片的Start为true，最后一个分片的End为true，其他情况都是false。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于CPU信息的一些介绍</title>
    <link href="/2023/08/30/%E5%85%B3%E4%BA%8ECPU%E4%BF%A1%E6%81%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/08/30/%E5%85%B3%E4%BA%8ECPU%E4%BF%A1%E6%81%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p><strong>物理 CPU 个数</strong>（Socket 数量）：表示物理处理器的数量，即服务器上安装了多少颗物理 CPU 芯片。</p><p><code>lscpu</code> 命令会返回系统中的物理 CPU 的数量。</p><p>这个数量可以在返回结果中的 <code>Socket(s)</code> 参数中找到。</p><p><strong>CPU 核心数</strong>：表示<strong>每颗</strong>物理 CPU 芯片内部的核心数量，也称为逻辑 CPU 核心数。现代的物理 CPU 芯片通常有多个核心，每个核心都可以独立执行指令。</p><p><code>lscpu</code> 命令会返回系统中的 CPU 核心数。可以在返回结果中的 <code>Core(s) per socket</code> 参数中找到。</p><blockquote><p>如果系统中有两颗物理 CPU，每颗 CPU 有 8 个核心，那么总共的 CPU 核心数就是 2 * 8 &#x3D; 16 个。</p><p>物理 CPU 个数决定了系统中有多少颗独立的物理处理器，而每颗物理 CPU 的核心数决定了系统可以并行执行的任务数量。</p></blockquote><p><strong>每个 CPU 核心支持的线程数</strong>：通常是 1（无超线程）或 2（支持超线程）。通常用于表示超线程技术的支持。</p><p><code>lscpu</code> 命令返回的Thread(s) per core: 显示每个 CPU 核心支持的线程数。</p><p><strong>逻辑 CPU 数</strong>是指系统操作系统和应用程序所看到的虚拟 CPU 核心数量。与上面的<code>每个CPU核心支持的线程数</code>是有关系的。<code>lscpu</code> 命令会返回系统的逻辑 CPU 数。</p><p>在<code>lscpu</code> 命令输出中，你可以找到 <code>CPU(s)</code> 这一行，它会显示逻辑 CPU 的总数。这个值反映了系统中虚拟 CPU 核心的数量，包括通过超线程技术支持的虚拟核心。</p><p><strong>物理 CPU 插槽的数量</strong>：每个 CPU 插槽可以容纳一个物理 CPU 芯片。在多 CPU 架构的系统中，可能有多个物理 CPU 插槽，每个插槽中都可以放置一个物理 CPU。每个物理 CPU 芯片上可以有多个 CPU 核心。</p><p><code>lscpu</code> 命令中的 <code>Socket(s)</code> 表示系统中物理 CPU 插槽的数量。</p><blockquote><p>补充：</p><p><code>runtime.NumCPU()</code> 函数返回的是当前系统可用的逻辑 CPU 核心数。这个函数返回的值并不是物理 CPU 的数量，而是操作系统可用的逻辑处理单元（线程）的数量。在多核心的处理器上，每个核心都可以有多个线程，因此 <code>runtime.NumCPU()</code> 返回的是逻辑 CPU 核心数。</p></blockquote><p>下面是一个世纪运行过程中lscpu的输出，可以作为参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">Architecture:          x86_64<br>CPU op-mode(s):        32-bit, 64-bit<br>Byte Order:            Little Endian<br>CPU(s):                16<br>On-line CPU(s) list:   0-15<br>Thread(s) per core:    1<br>Core(s) per socket:    1<br>Socket(s):             16<br>NUMA node(s):          1<br>Vendor ID:             AuthenticAMD<br>CPU family:            23<br>Model:                 1<br>Model name:            AMD EPYC Processor (with IBPB)<br>Stepping:              2<br>CPU MHz:               2894.560<br>BogoMIPS:              5789.12<br>Hypervisor vendor:     KVM<br>Virtualization type:   full<br>L1d cache:             32K<br>L1i cache:             64K<br>L2 cache:              512K<br>L3 cache:              8192K<br>NUMA node0 CPU(s):     0-15<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>libpcap抓包时遇到权限问题</title>
    <link href="/2023/08/23/libpcap%E6%8A%93%E5%8C%85%E6%97%B6%E9%81%87%E5%88%B0%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/23/libpcap%E6%8A%93%E5%8C%85%E6%97%B6%E9%81%87%E5%88%B0%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>我写了个非常简单的抓包程序，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/google/gopacket&quot;</span><br><span class="hljs-string">&quot;github.com/google/gopacket/pcap&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>handle, err := pcap.OpenLive(<span class="hljs-string">&quot;en0&quot;</span>, <span class="hljs-number">1024</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">-1</span>*time.Second)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;.............&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> handle.Close()<br><br>packetSource := gopacket.NewPacketSource(handle, handle.LinkType())<br>packetSource.DecodeOptions = gopacket.DecodeOptions&#123;Lazy: <span class="hljs-literal">true</span>, NoCopy: <span class="hljs-literal">true</span>,<br>DecodeStreamsAsDatagrams: <span class="hljs-literal">true</span>&#125;<br><span class="hljs-keyword">for</span> s := <span class="hljs-keyword">range</span> packetSource.Packets() &#123;<br>fmt.Println(<span class="hljs-string">&quot;....Timestamp.....&quot;</span>, s.Metadata().Timestamp)<br>fmt.Println(<span class="hljs-string">&quot;.....CaptureInfo....&quot;</span>, s.Metadata().CaptureInfo)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是执行的时候报错了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">CGO_ENABLED=1  go run .<br><span class="hljs-meta prompt_"># </span><span class="language-bash">github.com/google/gopacket/aaa</span><br>ld: warning: -no_pie is deprecated when targeting new OS versions<br>ld: warning: non-standard -pagezero_size is deprecated when targeting macOS 13.0 or later<br>............. en0: You don&#x27;t have permission to capture on that device ((cannot open BPF device) /dev/bpf0: Permission denied)<br></code></pre></td></tr></table></figure><p>显然是权限不够的问题，下面执行命令加上权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chmod o+r /dev/bpf*<br></code></pre></td></tr></table></figure><p>这个命令就是给&#x2F;dev&#x2F;bpf*文件加上其他用户的读权限，o表示其他用户，r标识读权限。</p><p>执行完毕后再次执行<code>CGO_ENABLED=1  go run .</code>就可以执行成功了。之前在wireshark没有加权限时wireshark也不能抓包提示权限不够，但是执行后wireshark就可以正常抓到包了。</p><p>因为我是在macOS上运行的，在 macOS 上，BPF 设备文件位于 <code>/dev/bpf*</code>，这些文件默认情况下只允许 root 用户和某些特权组的用户访问。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>daemon介绍与对应Go包</title>
    <link href="/2023/08/15/daemon%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AF%B9%E5%BA%94Go%E5%8C%85/"/>
    <url>/2023/08/15/daemon%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AF%B9%E5%BA%94Go%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>##daemon介绍</p><p>守护进程（daemon）是一种作为后台进程连续运行并唤醒以处理定期服务请求（通常来自远程进程）的程序。 守护程序收到操作系统 (OS) 的请求警报，并且它本身响应该请求或将请求转发到适当的另一个程序或进程。</p><p>常见的守护进程包括打印后台处理程序、电子邮件处理程序和其他管理管理任务的程序。 许多 Unix 或 Linux 实用程序作为守护进程运行。 例如，在 Linux 上，网络时间协议 (NTP) 守护程序用于测量运行它的计算机上的时钟与网络上所有其他计算机的时钟之间的时间差。 每台主机上都运行一个时间守护程序，其中一台被指定为主计算机，所有其他计算机被指定为辅助计算机。 辅助守护程序首先向主时间守护程序发送请求以找出正确的网络时间，从而重置其主机上的网络时间。</p><p>守护进程是在后台运行的长期运行进程，通常不与终端交互，而是在系统启动时自动启动，并在系统关闭时自动关闭。这种方式通常用于服务器程序、监控程序等。</p><h2 id="go的daemon包"><a href="#go的daemon包" class="headerlink" title="go的daemon包"></a>go的daemon包</h2><p>常用的daemon包是 <a href="https://github.com/sevlyar/go-daemon">https://github.com/sevlyar/go-daemon</a></p><p><code>go-daemon</code> 库允许你以守护进程方式运行 Go 程序，提供以下特性：</p><ol><li><strong>Forking 子进程：</strong> <code>go-daemon</code> 可以 fork 出子进程，然后让子进程继续运行后续的代码，而父进程则退出。这样可以确保程序在后台持续运行。</li><li><strong>文件描述符重定向：</strong> 在 fork 过程中，<code>go-daemon</code> 可以重定向标准输入、输出和错误流，以及其他文件描述符。这有助于将输出和日志记录到文件，同时释放终端控制。</li><li><strong>进程信号处理：</strong> <code>go-daemon</code> 提供了对各种进程信号的处理，如重启、停止等。</li><li><strong>进程 PID 文件：</strong> <code>go-daemon</code> 支持创建 PID 文件，用于标识守护进程的进程 ID。</li><li><strong>独立的守护进程环境：</strong> <code>go-daemon</code> 会创建一个独立的守护进程环境，以确保程序可以在后台运行。</li><li><strong>进程退出时清理：</strong> 守护进程退出时，<code>go-daemon</code> 可以进行一些清理工作，如删除 PID 文件等。</li></ol><p>下面是示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;html&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/sevlyar/go-daemon&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>cntxt := &amp;daemon.Context&#123;<br>PidFileName: <span class="hljs-string">&quot;daemon-example.pid&quot;</span>,<br>PidFilePerm: <span class="hljs-number">0644</span>,<br>LogFileName: <span class="hljs-string">&quot;daemon.log&quot;</span>,<br>LogFilePerm: <span class="hljs-number">0640</span>,<br>WorkDir:     <span class="hljs-string">&quot;./&quot;</span>,<br>Umask:       <span class="hljs-number">027</span>,<br>Args:        []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;[daemon-example]&quot;</span>&#125;,<br>&#125;<br><br>d, err := cntxt.Reborn()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Unable to run: &quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> d != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> cntxt.Release()<br><br>fmt.Println(<span class="hljs-string">&quot;- - - - - - - - - - - - - - -&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;daemon started&quot;</span>)<br><br><span class="hljs-comment">// 模拟长时间运行</span><br><span class="hljs-comment">// time.Sleep(10 * time.Second)</span><br><br>serveHTTP()<br>fmt.Println(<span class="hljs-string">&quot;daemon terminated&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serveHTTP</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, httpHandler)<br>http.ListenAndServe(<span class="hljs-string">&quot;127.0.0.1:8089&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">httpHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>log.Printf(<span class="hljs-string">&quot;request from %s: %s %q&quot;</span>, r.RemoteAddr, r.Method, r.URL)<br>fmt.Fprintf(w, <span class="hljs-string">&quot;go-daemon........: %q&quot;</span>, html.EscapeString(r.URL.Path))<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后会在当前目录下新建两个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">daemon-example.pid daemon.log<br></code></pre></td></tr></table></figure><p>daemon-example.pid里存储了当前的进程ID，</p><p>运行go run .后终端没有打印，但是程序其实已经在后台运行了，调用如下命令可以看到有结果输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl 127.0.0.1:8089                        <br>go-daemon........: &quot;/&quot;%                                                               <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>telegraf Kafka插件开发与kafka exporter源码阅读</title>
    <link href="/2023/08/12/kafka%20exporter%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2023/08/12/kafka%20exporter%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因为最近需要开发一个新的exporter，这个exporter就是在每台服务器上运行，exporter读取机器的一些信息然后将信息传输到远程，比如调用某个HTTP POST接口将信息传送给远程的服务器，或者存储到远程的数据库。</p><p>目前决定不从零开发exporter，而是在telegraf的基础上二次开发。因为telegraf支持的input插件不包括kafka，所以需要自行开发kafka input插件。</p><p>之前公司用的kafka exporter是<a href="https://github.com/danielqsj/kafka_exporter%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%BC%9A%E7%94%A8%E8%BF%99%E4%B8%AAexporter%E8%AF%BB%E5%8F%96kafka%E6%8C%87%E6%A0%87%E7%84%B6%E5%90%8E%E6%9A%B4%E9%9C%B2metrics">https://github.com/danielqsj/kafka_exporter，现在公司会用这个exporter读取kafka指标然后暴露metrics</a> API给Prometheus。</p><p>现在可以考虑先阅读下<a href="https://github.com/danielqsj/kafka_exporter%E7%9A%84%E6%BA%90%E7%A0%81%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%BA%90%E7%A0%81%E5%8C%85%E6%8B%AC%E4%B8%A4%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9A%E5%88%86%E5%88%AB%E6%98%AF%E8%AF%BB%E5%8F%96kafka%E7%9A%84%E6%8C%87%E6%A0%87%EF%BC%8C%E6%9A%B4%E9%9C%B2metrics%E6%8E%A5%E5%8F%A3%E7%BB%99Prometheus%E4%BB%A5%E7%94%A8%E4%BA%8EPrometheus%E8%B0%83%E7%94%A8metrics%E8%AF%BB%E5%8F%96%E5%88%B0kafka%E7%9A%84%E6%8C%87%E6%A0%87%E3%80%82%E6%98%BE%E7%84%B6%E9%98%85%E8%AF%BB%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%AA%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E8%AF%BB%E5%8F%96kafka%E7%9A%84%E6%8C%87%E6%A0%87%E8%BF%99%E4%B8%80%E9%83%A8%E5%88%86%E5%8D%B3%E5%8F%AF%EF%BC%8C%E5%9B%A0%E4%B8%BA%E7%AC%94%E8%80%85%E5%AF%B9kafka%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8D%E7%86%9F%E6%82%89%E4%B8%8D%E7%9F%A5%E9%81%93%E8%A6%81%E8%AF%BB%E5%8F%96%E5%93%AA%E4%BA%9B%E6%8C%87%E6%A0%87%E5%92%8C%E8%BF%99%E4%BA%9B%E6%8C%87%E6%A0%87%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E3%80%82">https://github.com/danielqsj/kafka_exporter的源码，因为源码包括两个部分：分别是读取kafka的指标，暴露metrics接口给Prometheus以用于Prometheus调用metrics读取到kafka的指标。显然阅读的时候只需要关注读取kafka的指标这一部分即可，因为笔者对kafka的架构不熟悉不知道要读取哪些指标和这些指标应该如何获取。</a></p><p>在了解了<a href="https://github.com/danielqsj/kafka_exporter%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96kafka%E6%8C%87%E6%A0%87%E5%90%8E%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E5%85%B6%E8%AF%BB%E5%8F%96%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B0%86%E8%AF%BB%E5%8F%96%E6%96%B9%E6%B3%95%E2%80%9C%E5%A4%8D%E5%88%B6%E2%80%9D%E5%88%B0telegraf%E7%9A%84kafka">https://github.com/danielqsj/kafka_exporter如何读取kafka指标后，可以参考其读取的方法，将读取方法“复制”到telegraf的kafka</a> input插件中。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><p>kafka 是由 Apache 软件基金会开发的一个高吞吐量的分布式<strong>消息队列系统</strong>。它主要用于处理大规模的实时数据流，例如日志、事件、指标等。Kafka 设计用来解决传统消息中间件面临的问题，如低吞吐量、高延迟和可靠性不足等。</p><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p>这里主要关注kafka与zookeeper的关系，因为<a href="https://github.com/danielqsj/kafka_exporter%E6%B6%89%E5%8F%8A%E5%88%B0%E4%BA%86zookeeper%E3%80%82">https://github.com/danielqsj/kafka_exporter涉及到了zookeeper。</a></p><p>kafka会用到zookeeper，有以下几个原因：</p><p>（1）Kafka集群通过Zookeeper来管理kafka的配置，选举leader；</p><p>（2）在Consumer Group发生变化时进行rebalance</p><p>（3）所有的topic与broker的对应关系都由zk维护</p><p>2.kafka的哪些组件需要注册到zookeeper</p><p>（1）Broker注册到zk</p><p>（2）Topic注册到zk</p><p>（3）Consumer注册到zk</p><p>producer（生产者）不注册到zookeeper是因为生产者的状态是瞬间状态，发送完消息就可以宕机了。<br> 3.kafka和zookeeper的理解</p><p><strong>kafka使用zookeeper来实现动态的集群扩展，不需要更改客户端（producer和consumer）的配置。</strong>broker会在zookeeper注册并保持相关的元数据（topic，partition信息等）更新。</p><p>但是发送给Topic本身的数据是不会发到Zk上的。</p><h3 id="telegraf"><a href="#telegraf" class="headerlink" title="telegraf"></a>telegraf</h3><p>Telegraf 是一个开源的、插件驱动的服务器代理程序，用于收集、处理和传输指标数据。它是 InfluxData 公司开发的一个组件，主要用于监控和数据收集。Telegraf 的设计目标是轻量级、高效和易于扩展，它可以用于从各种数据源采集指标数据，然后将这些数据传输到不同的目标存储或可视化工具中。</p><p>源代码地址为：<a href="https://github.com/influxdata/telegraf%E3%80%82">https://github.com/influxdata/telegraf。</a></p><p>Telegraf最大的特点是支持插件式的二次开发，Telegraf有输入插件、输出插件、处理（processors）插件等多种插件。</p><p>Telegraf还可以<strong>设置采集数据的周期</strong>，以固定的时间间隔定期从数据源获取指标数据。</p><p>telegraf默认情况下已经实现了对很多对象的指标采集，比如Clickhouse，CPU，Docker等，具体可看：<a href="https://docs.influxdata.com/telegraf/v1.14/plugins/plugin-list/">https://docs.influxdata.com/telegraf/v1.14/plugins/plugin-list/</a> 的Input plugins部分：</p><p><img src="/../images/image-20230815204351715.png" alt="image-20230815204351715"></p><h2 id="kafka-exporter源码阅读"><a href="#kafka-exporter源码阅读" class="headerlink" title="kafka exporter源码阅读"></a>kafka exporter源码阅读</h2><p>因为这个项目使用到了go vendor这种比较老的管理第三方依赖库的机制，所以笔者先删掉了vendor模块该用go mod模块管理系统作为第三方依赖库的管理工具。</p><p>这个项目主要使用的三方库有：</p><p><a href="https://github.com/prometheus/client_golang%EF%BC%9A%E8%BF%99%E6%98%AF%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E7%9A%84%E5%AE%98%E6%96%B9Go%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%82">https://github.com/prometheus/client_golang：这是普罗米修斯的官方Go客户端。</a></p><p><a href="https://github.com/IBM/sarama%EF%BC%9A%E8%BF%99%E4%B8%AA%E6%98%AFApache">https://github.com/IBM/sarama：这个是Apache</a> Kafka的官方Go客户端。</p><p><a href="https://github.com/krallistic/kazoo-go%EF%BC%9AKazoo">https://github.com/krallistic/kazoo-go：Kazoo</a> 是一个与 Zookeeper 中的 Kafka 元数据交互的库。 它提供集群代理、主题元数据和消费者组的发现。</p><p>这个项目的目录结构比较简单，主要逻辑就是在<code>kafka_exporter.go</code>文件里。下面依次介绍一些比较关键的代码段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">exporter, err := NewExporter(opts, topicFilter, topicExclude, groupFilter, groupExclude)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>klog.Fatalln(err)<br>&#125;<br><span class="hljs-keyword">defer</span> exporter.client.Close()<br><span class="hljs-comment">// 注册prometheus收集器，需要实现下面的接口</span><br><span class="hljs-comment">// Describe(chan&lt;- *Desc)</span><br><span class="hljs-comment">// Collect(chan&lt;- Metric)</span><br>prometheus.MustRegister(exporter)<br></code></pre></td></tr></table></figure><p>prometheus.MustRegister接收的是一个interface，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Collector <span class="hljs-keyword">interface</span> &#123;<br>Describe(<span class="hljs-keyword">chan</span>&lt;- *Desc)<br>Collect(<span class="hljs-keyword">chan</span>&lt;- Metric)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先查看NewExporter返回的Exporter struct是如何实现Collect方法的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Exporter)</span></span> Collect(ch <span class="hljs-keyword">chan</span>&lt;- prometheus.Metric) &#123;<br><span class="hljs-keyword">if</span> e.allowConcurrent &#123;<br>e.collect(ch)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// allowConcurrent 默认为 false</span><br><span class="hljs-comment">// Locking to avoid race add</span><br>e.sgMutex.Lock()<br><span class="hljs-comment">// 把输入的参数 ch 追加到了 sgChans，后面应该会对 sgChans 更改吧</span><br>e.sgChans = <span class="hljs-built_in">append</span>(e.sgChans, ch)<br><span class="hljs-comment">// Safe to compare length since we own the Lock</span><br>fmt.Println(<span class="hljs-string">&quot;.....len(e.sgChans).......&quot;</span>, <span class="hljs-built_in">len</span>(e.sgChans))<br><span class="hljs-comment">//  len(e.sgChans) 如果请求在同时进行的话就不是 1，如果只有 1 个请求的话就是 1</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(e.sgChans) == <span class="hljs-number">1</span> &#123;<br>e.sgWaitCh = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> e.collectChans(e.sgWaitCh)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>klog.V(TRACE).Info(<span class="hljs-string">&quot;concurrent calls detected, waiting for first to finish&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Put in another variable to ensure not overwriting it in another Collect once we wait</span><br>waiter := e.sgWaitCh<br>e.sgMutex.Unlock()<br><span class="hljs-comment">// Released lock, we have insurance that our chan will be part of the collectChan slice</span><br>&lt;-waiter<br><span class="hljs-comment">// collectChan finished</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关注collect方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Exporter)</span></span> collect(ch <span class="hljs-keyword">chan</span>&lt;- prometheus.Metric) &#123;<br><span class="hljs-comment">// 这部分应该比较关注 ch &lt;-  的操作，也就是往返回数据写入了什么数据</span><br><span class="hljs-comment">// 好像每请求一次 metrics 接口就会调用一次这个 collect 函数</span><br>fmt.Println(<span class="hljs-string">&quot;......... collect(ch chan&lt;- prometheus.Metric) &#123;...&quot;</span>)<br><span class="hljs-keyword">var</span> wg = sync.WaitGroup&#123;&#125;<br>ch &lt;- prometheus.MustNewConstMetric(<br><span class="hljs-comment">// client 就是  sarama.NewClient 获取的，sarama 是一个 Apacha Kafka的Go client，通过它可以获取 kafka 的一些信息</span><br>clusterBrokers, prometheus.GaugeValue, <span class="hljs-type">float64</span>(<span class="hljs-built_in">len</span>(e.client.Brokers())),<br>)<br><span class="hljs-keyword">for</span> _, b := <span class="hljs-keyword">range</span> e.client.Brokers() &#123;<br>ch &lt;- prometheus.MustNewConstMetric(<br>clusterBrokerInfo, prometheus.GaugeValue, <span class="hljs-number">1</span>, strconv.Itoa(<span class="hljs-type">int</span>(b.ID())), b.Addr(),<br>)<br>&#125;<br>...<br>  <span class="hljs-comment">// client是kafka的client，调用client即kafka客户端库，获取kafka的topic之后对于每个topic，获取其详情组成指标，传入ch</span><br>  topics, err := e.client.Topics()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>klog.Errorf(<span class="hljs-string">&quot;Cannot get topics: %v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>  ...<br>getTopicMetrics := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(topic <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><br><span class="hljs-keyword">if</span> !e.topicFilter.MatchString(topic) || e.topicExclude.MatchString(topic) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// topic 的分区</span><br>partitions, err := e.client.Partitions(topic)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>klog.Errorf(<span class="hljs-string">&quot;Cannot get partitions of topic %s: %v&quot;</span>, topic, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>ch &lt;- prometheus.MustNewConstMetric(<br><span class="hljs-comment">// topic 分区指标</span><br>topicPartitions, prometheus.GaugeValue, <span class="hljs-type">float64</span>(<span class="hljs-built_in">len</span>(partitions)), topic,<br>)<br>  ...<br></code></pre></td></tr></table></figure><p>collect的逻辑就是不断往ch里写不同类型的普罗米修斯指标，在allowConcurrent的情况下，这个ch实际上就是<code>func (e *Exporter) Collect(ch chan&lt;- prometheus.Metric) </code>的参数ch。</p><blockquote><p>总的逻辑还是挺简单的，代码的主要实现逻辑就是通过Kafka的Go客户端连接到Kafka集群后，获取到kafka信息，再将信息通过类似<code>prometheus.MustNewConstMetric</code>这样的新建普罗米修斯指标的信息来将信息补充到指标中。kafka信息包括有多少个Topic，Broker，分区等等。</p></blockquote><h2 id="开发telegraf-kafka的input插件"><a href="#开发telegraf-kafka的input插件" class="headerlink" title="开发telegraf kafka的input插件"></a>开发telegraf kafka的input插件</h2><p>要实现telegraf的input插件，需要实现Gather接口，可以参考<a href="https://github.com/influxdata/telegraf/blob/master/docs/INPUTS.md">官方文档</a>：</p><p>在custom-telegraf&#x2F;plugins&#x2F;inputs新建目录，如simple；</p><p>在simple目录中新建simple.go文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:generate ../../../tools/readme_config_includer/generator</span><br><span class="hljs-keyword">package</span> a_simple<br><br><span class="hljs-keyword">import</span> (<br>_ <span class="hljs-string">&quot;embed&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/influxdata/telegraf&quot;</span><br><span class="hljs-string">&quot;github.com/influxdata/telegraf/plugins/inputs&quot;</span><br>)<br><br><span class="hljs-comment">//go:embed sample.conf</span><br><span class="hljs-keyword">var</span> sampleConfig <span class="hljs-type">string</span><br><br><span class="hljs-keyword">type</span> Simple <span class="hljs-keyword">struct</span> &#123;<br>Ok  <span class="hljs-type">bool</span>            <span class="hljs-string">`toml:&quot;ok&quot;`</span><br>Log telegraf.Logger <span class="hljs-string">`toml:&quot;-&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*Simple)</span></span> SampleConfig() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> sampleConfig<br>&#125;<br><br><br><span class="hljs-comment">// Init is for setup, and validating config.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Simple)</span></span> Init() <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Simple)</span></span> Gather(acc telegraf.Accumulator) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> s.Ok &#123;<br>acc.AddCounter(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;value0&quot;</span>: <span class="hljs-number">12</span>&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;&#125;)<br>acc.AddCounter(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-number">2</span>&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;&#125;, time.Now())<br>acc.AddCounter(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;value1&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;value2&quot;</span>: <span class="hljs-number">2</span>&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;&#125;, time.Now())<br>acc.AddCounter(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;value3&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;value4&quot;</span>: <span class="hljs-number">2</span>&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;filed&quot;</span>: <span class="hljs-string">&quot;value&quot;</span>&#125;, time.Now())<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>acc.AddFields(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;not great&quot;</span>&#125;, <span class="hljs-literal">nil</span>)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>inputs.Add(<span class="hljs-string">&quot;simple&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> telegraf.Input &#123; <span class="hljs-keyword">return</span> &amp;Simple&#123;&#125; &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>toml:&quot;ok&quot;</code>后缀表示需要名为ok的配置字段名。</p><p>在simple目录中新建对应的配置文件sample.conf：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">[[inputs.simple]]<br>  ok = true<br></code></pre></td></tr></table></figure><p>在simple目录中新建README.md，这个文件可以为空。</p><p>新建custom-telegraf&#x2F;plugins&#x2F;inputs&#x2F;all&#x2F;simple.go文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:build !custom || inputs || inputs.simple</span><br><br><span class="hljs-keyword">package</span> all<br><br><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;github.com/influxdata/telegraf/plugins/inputs/a_simple&quot;</span> <span class="hljs-comment">// register plugin</span><br></code></pre></td></tr></table></figure><p>至此修改完毕，下面在运行时使用的配置文件config.conf新增如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">[[inputs.simple]]<br>  ok = true<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">cd <span class="hljs-keyword">cmd</span><span class="language-bash">/telegraf</span><br>go <span class="hljs-keyword">run</span><span class="language-bash"> . --config ../../config.conf --<span class="hljs-built_in">test</span> --input-filter simple</span><br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">go run . --config ../../z_tele.conf --test --input-filter simple<br>2023-08-16T10:09:41Z I! Loading config: ../../config.conf<br>2023-08-16T10:09:41Z I! Starting Telegraf unknown<br>2023-08-16T10:09:41Z I! Available plugins: 242 inputs, 9 aggregators, 28 processors, 23 parsers, 59 outputs, 4 secret-stores<br>2023-08-16T10:09:41Z I! Loaded inputs: simple (2x)<br>2023-08-16T10:09:41Z I! Loaded aggregators:<br>2023-08-16T10:09:41Z I! Loaded processors:<br>2023-08-16T10:09:41Z I! Loaded secretstores:<br>2023-08-16T10:09:41Z W! Outputs are not used in testing mode!<br>2023-08-16T10:09:41Z I! Tags enabled: host=Rhetts-MacBook-Pro.local<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">state,host=Rhetts-MacBook-Pro.<span class="hljs-built_in">local</span> value0=12i 1692180582000000000</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">state,host=Rhetts-MacBook-Pro.<span class="hljs-built_in">local</span> value0=12i 1692180582000000000</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">state,host=Rhetts-MacBook-Pro.<span class="hljs-built_in">local</span> value=2i 1692180582000000000</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">state,host=Rhetts-MacBook-Pro.<span class="hljs-built_in">local</span> value=2i 1692180582000000000</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">state,host=Rhetts-MacBook-Pro.<span class="hljs-built_in">local</span> value1=2i,value2=2i 1692180582000000000</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">state,host=Rhetts-MacBook-Pro.<span class="hljs-built_in">local</span> value1=2i,value2=2i 1692180582000000000</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">state,filed=value,host=Rhetts-MacBook-Pro.<span class="hljs-built_in">local</span> value3=3i,value4=2i 1692180582000000000</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">state,filed=value,host=Rhetts-MacBook-Pro.<span class="hljs-built_in">local</span> value3=3i,value4=2i 1692180582000000000</span><br></code></pre></td></tr></table></figure><p>这样打印出来了新增的一些指标。</p><p>主要就是参考<code>func (e *Exporter) collect(ch chan&lt;- prometheus.Metric)</code>函数的实现，使用的实现指标的方法为 <code>acc.AddCounter(matches[1], tm.Fields(), tags, tm.Time())</code>。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>skywalking的应用程序监视功能</title>
    <link href="/2023/07/20/skywalking%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9B%91%E8%A7%86%E5%8A%9F%E8%83%BD/"/>
    <url>/2023/07/20/skywalking%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9B%91%E8%A7%86%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Skywalking是分布式系统的应用程序性能监视工具，即APM(application performance monitor)工具</p><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/../images/image-20230719153235057.png" alt="image-20230719153235057"></p><p>skywalking总体可以分为四部分：</p><ol><li><p>Skywalking Agent：使用Javaagent做字节码植入，无侵入式的收集，并通过HTTP或者gRPC方式发送数据到Skywalking Collector。</p></li><li><p>Skywalking Collector ：链路数据收集器，对agent传过来的数据进行整合分析处理并落入相关的数据存储中。</p></li><li><p>Storage：Skywalking的存储，时间更迭，sw已经开发迭代到了6.x版本，在6.x版本中支持以ElasticSearch、Mysql、TiDB、H2、作为存储介质进行数据存储。</p></li><li><p>UI ：Web可视化平台，用来展示落地的数据。</p></li></ol><p>skywalking通过agent方式，做到高性能、低损耗、无侵入性。</p><p>默认情况下skywalking使用H2来存储数据。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="SkyWalking"><a href="#SkyWalking" class="headerlink" title="SkyWalking"></a>SkyWalking</h3><p>因为根据官方的启动方法，需要使用JDK11。满足条件后，从<a href="https://skywalking.apache.org/downloads/%E4%B8%8B%E8%BD%BDSkyWalking">https://skywalking.apache.org/downloads/下载SkyWalking</a> APM后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd apache-skywalking-apm-bin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 OAP 后端</span><br>bin/oapService.sh<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 UI</span><br>bin/webappService.sh<br></code></pre></td></tr></table></figure><p>查看 <a href="http://localhost:8080/general">http://localhost:8080/general</a> </p><h3 id="通过Go-Agent上报数据"><a href="#通过Go-Agent上报数据" class="headerlink" title="通过Go Agent上报数据"></a>通过Go Agent上报数据</h3><p>上一步的SkyWalking 部署完毕后，还没有数据，因为没有Agent向Skywalking上报数据。下面部署Agent往Skywalking写数据。</p><p>参考 <a href="https://skywalking.apache.org/zh/2023-06-01-quick-start-with-skywalking-go-agent/">https://skywalking.apache.org/zh/2023-06-01-quick-start-with-skywalking-go-agent/</a></p><p>设置一个被监控的程序，我在本地调试的是<code>~/Downloads/apache-skywalking-apm-bin/aa_golang_program</code>目录下的文件，编译之后是test文件。</p><p>编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go build -toolexec=&quot;~/Downloads/apache-skywalking-go-0.1.0-bin/bin/skywalking-go-agent-0.1.0-darwin-amd64&quot; -a -o test .<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export SW_AGENT_NAME=demo                                                           <br>./test<br></code></pre></td></tr></table></figure><p>请求 <a href="http://localhost:8000/hello%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8">http://localhost:8000/hello，然后在</a> <a href="http://localhost:8080/dashboard/GENERAL/Service/ZGVtbw==.1/General-Service">http://localhost:8080/dashboard/GENERAL/Service/ZGVtbw==.1/General-Service</a> 可以查看请求记录。</p><h3 id="实现Dubbo-Go监控"><a href="#实现Dubbo-Go监控" class="headerlink" title="实现Dubbo Go监控"></a>实现Dubbo Go监控</h3><p>参考<a href="https://skywalking.apache.org/zh/2023-06-05-quick-start-using-skywalking-go-monitoring-dubbo-go/">文档</a>，安装dubbogo-cli，执行以下命令：</p><p>笔者运行后报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">../../../.gvm/pkgsets/go1.19/global/pkg/mod/github.com/shirou/gopsutil@v3.20.11+incompatible/cpu/cpu_darwin_cgo.go:13:5: warning: &#x27;TARGET_OS_MAC&#x27; is not defined, evaluates to 0 [-Wundef-prefix=TARGET_OS_]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">github.com/dubbogo/dubbogo-cli</span><br>ld: warning: -no_pie is deprecated when targeting new OS versions<br>ld: warning: non-standard -pagezero_size is deprecated when targeting macOS 13.0 or later<br></code></pre></td></tr></table></figure><p>根据<a href="https://github.com/shirou/gopsutil/issues/976">issue</a>提示，需要禁用CGO：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">go env -w CGO_ENABLED=&quot;0&quot;  <br>go install github.com/dubbogo/dubbogo-cli@latest  <br></code></pre></td></tr></table></figure><p>安装完dubbogo-cli后，需要使用 SkyWalking GO 编译 Dubbo Go 程序，注意使用的go版本是1.20，好像是笔者执行时的最新版本。使用的dubbo.apache.org&#x2F;dubbo-go&#x2F;v3也是当时的最新版本v3.0.5。我在执行go build的时候报错了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">go: finding module for package dubbo.apache.org/dubbo-go/v3/common/logger<br>helloworld/go-client/cmd imports<br>        dubbo.apache.org/dubbo-go/v3/common/logger: module dubbo.apache.org/dubbo-go/v3@latest found (v3.0.5), but does not contain package dubbo.apache.org/dubbo-go/v3/common/logger<br></code></pre></td></tr></table></figure><p>发现是因为项目里使用了dubbo.apache.org&#x2F;dubbo-go&#x2F;v3&#x2F;common&#x2F;logger进行日志打印，但是最新版本的dubbo-go又没有这个logger包，于是把项目里引用这个包的地方都注释掉了，打印日志的地方换成了fm.Print进行打印。然后重新执行go build成功了。</p><h2 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h2><p>Skywalking我暂时用到的就是应用程序监视的功能，就是查看服务之间的调用情况。也就是所谓的全链路追踪。下面介绍的内容也是和全链路追踪相关的。</p><p><img src="/../images/image-20230719154944088.png" alt="image-20230719154944088"></p><p>可以在Skywalking的UI界面上查看服务之间的调用情况。我构建的后端服务是datascreeen，datascreen对外提供API供客户端调用。datascreeen内部在实现API的过程中会对dat-openapi-easyops和uat-thanos-query这样的三方服务发送HTTP请求，可以看到Skywalking将这两个也视为Service显示在页面上。</p><p>图上的request就是一个前端服务，向后端服务datascreen发送请求。</p><p><img src="/../images/image-20230719155015001.png" alt="image-20230719155015001"></p><p>发送请求后，可以在Trace里看到请求内容。对于单个请求，可以看到请求的哪些部分和耗时，包括请求三方服务API的耗时（这部分被视为database）。</p><p>因为是全链路追踪，所以可以看到如果出错了，是哪个部分，比如下面这个图，是在三方服务挂了的情况时，request服务发送请求报错，可以在这个报错请求的详细内容里看到哪里出错了。</p><p><img src="/../images/image-20230719155035871.png" alt="image-20230719155035871"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>telegraf接入夜莺与telegraf的二次开发</title>
    <link href="/2023/07/19/telegraf%E6%8E%A5%E5%85%A5%E5%A4%9C%E8%8E%BA%E4%B8%8Etelegraf%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"/>
    <url>/2023/07/19/telegraf%E6%8E%A5%E5%85%A5%E5%A4%9C%E8%8E%BA%E4%B8%8Etelegraf%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>之前的夜莺监控系统一文中，提到了telegraf可以作为agent向夜莺传送数据，夜莺再将数据转存到数据源如Prometheus。夜莺监控系统一文中的部署部分没有涉及到agent的部署，只部署了夜莺和数据源部分，本文将把telegraf作为agent部署，完成agent-&gt;夜莺-&gt;数据源的全链路部署。</p><p>此外， telegrapf自身提供了对插件的二次开发的良好支持，包括input插件，output插件等等。本文将介绍二次开发可能比较多的input插件的二次开发规范与步骤的等。</p><h2 id="telegraf简介"><a href="#telegraf简介" class="headerlink" title="telegraf简介"></a>telegraf简介</h2><p>telegraf是一个用Go实现的指标数据收集、处理、聚合和写入的采集工具。是夜莺官方比较推荐的agent。github地址为<a href="https://github.com/influxdata/telegraf">https://github.com/influxdata/telegraf</a></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>笔者clone <a href="https://github.com/influxdata/telegraf%E9%A1%B9%E7%9B%AE%E5%90%8E%EF%BC%8C%E6%89%A7%E8%A1%8Cbuild%E6%9E%84%E5%BB%BA%E7%A8%8B%E5%BA%8F%E3%80%82">https://github.com/influxdata/telegraf项目后，执行build构建程序。</a></p><p>然后参考github上面的步骤，安装telegraf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">influxdata-archive_compat.key GPG fingerprint:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    9D53 9D90 D332 8DC7 D6C8 D3B9 D8FF 8E1F 7DF8 B07E</span><br>wget -q https://repos.influxdata.com/influxdata-archive_compat.key<br>echo &#x27;393e8779c89ac8d958f81f942f9ad7fb82a25e133faddaf92e15b16e6ac9ce4c influxdata-archive_compat.key&#x27; | sha256sum -c &amp;&amp; cat influxdata-archive_compat.key | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/influxdata-archive_compat.gpg &gt; /dev/null<br>echo &#x27;deb [signed-by=/etc/apt/trusted.gpg.d/influxdata-archive_compat.gpg] https://repos.influxdata.com/debian stable main&#x27; | sudo tee /etc/apt/sources.list.d/influxdata.list<br>sudo apt-get update &amp;&amp; sudo apt-get install telegraf<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">telegraf config &gt; telegraf.conf<br></code></pre></td></tr></table></figure><p>生成一个telegraf配置文件。</p><p>修改生成的telegraf.conf的outputs.opentsdb这块，<a href="https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v6/agent/telegraf/">参考</a>，改成：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml">[[<span class="hljs-string">outputs.opentsdb</span>]]<br>  <span class="hljs-string">host</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;http://127.0.0.1&quot;</span><br>  <span class="hljs-string">port</span> <span class="hljs-string">=</span> <span class="hljs-number">17000</span> <span class="hljs-comment"># 夜莺默认监听的端口是 17000</span><br>  <span class="hljs-string">http_batch_size</span> <span class="hljs-string">=</span> <span class="hljs-number">50</span><br>  <span class="hljs-string">http_path</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;/opentsdb/put&quot;</span><br>  <span class="hljs-string">debug</span> <span class="hljs-string">=</span> <span class="hljs-literal">true</span><br>  <span class="hljs-string">separator</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;_&quot;</span><br></code></pre></td></tr></table></figure><p>其实就是将输出改成夜莺的n9e-server服务的地址，这样telegraf可以将数据指标输出给夜莺。</p><p>然后对于夜莺，因为之前配置的是夜莺读取Prometheus的数据，没有实现夜莺将数据写入Prometheus中，下面修改夜莺的配置文件，实现让夜莺的数据写入Prometheus。修改夜莺的etc&#x2F;config.yml文件，将Pushgw.Writers部分改成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[[Pushgw.Writers]]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Url = <span class="hljs-string">&quot;http://127.0.0.1:8480/insert/0/prometheus/api/v1/write&quot;</span></span><br>Url = &quot;http://127.0.0.1:9090/api/v1/write&quot;<br></code></pre></td></tr></table></figure><p>这个是Prometheus对外暴露的API，夜莺指定该Url可以将数据输出到Prometheus中。</p><h2 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h2><p>telegraf包括以下四种插件：</p><p>Input插件：收集指标<br>Processor插件：转换与过滤指标数据<br>Aggregator插件：创建聚合指标，如创建平均值、最小值、最大值等聚合指标<br>Output插件：将指标写入各个输出目的地</p><p>指标数据的数据流和上面四个插件的顺序一致，指标数据依次经过收集、转换与过滤、聚合、输出这四个部分。本节将介绍Input插件的开发，其他三个插件的开发同理，可参考官网。</p><p>参考<a href="https://github.com/influxdata/telegraf/blob/master/docs/INPUTS.md">官方文档</a></p><p>在<code>plugins/inputs</code>下新建simple目录，该目录下存放3个文件：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">README.md<br><span class="hljs-keyword">sample</span>.<span class="hljs-keyword">conf</span><br>simple.go<br></code></pre></td></tr></table></figure><p>simple.go的内容为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:generate ../../../tools/readme_config_includer/generator</span><br><span class="hljs-keyword">package</span> simple<br><br><span class="hljs-keyword">import</span> (<br>_ <span class="hljs-string">&quot;embed&quot;</span><br><br><span class="hljs-string">&quot;github.com/influxdata/telegraf&quot;</span><br><span class="hljs-string">&quot;github.com/influxdata/telegraf/plugins/inputs&quot;</span><br>)<br><br><span class="hljs-comment">//go:embed sample.conf</span><br><span class="hljs-keyword">var</span> sampleConfig <span class="hljs-type">string</span><br><br><span class="hljs-keyword">type</span> Simple <span class="hljs-keyword">struct</span> &#123;<br>Ok  <span class="hljs-type">bool</span>            <span class="hljs-string">`toml:&quot;ok&quot;`</span><br>Log telegraf.Logger <span class="hljs-string">`toml:&quot;-&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*Simple)</span></span> SampleConfig() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> sampleConfig<br>&#125;<br><br><span class="hljs-comment">// Init is for setup, and validating config.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Simple)</span></span> Init() <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Simple)</span></span> Gather(acc telegraf.Accumulator) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> s.Ok &#123;<br>acc.AddFields(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;pretty good&quot;</span>&#125;, <span class="hljs-literal">nil</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>acc.AddFields(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;not great&quot;</span>&#125;, <span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>inputs.Add(<span class="hljs-string">&quot;simple&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> telegraf.Input &#123; <span class="hljs-keyword">return</span> &amp;Simple&#123;&#125; &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>sample.conf的内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">[[inputs.simple]]<br>  ok = true<br></code></pre></td></tr></table></figure><p>README.md内容为空。</p><p>在telegraf.conf文件追加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[[inputs.simple]]<br>  ok = true<br></code></pre></td></tr></table></figure><p>即表示开启了自定义的输出插件。</p><p>开发完毕后，如果需要测试结果，可以指定使用某个input插件，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./telegraf --config telegraf.conf --input-filter simple # simple这是是自定义的输入插件名，可以换成自己开发的插件名<br></code></pre></td></tr></table></figure><p>查看结果是否为自定的输出。</p><p>结果正常，如果想查看telegraf是否真的把数据上报给了夜莺，可修改telegraf.conf的outputs.opentsdb部分，将debug改成true，再启动telegraf可以在终端查看是否向夜莺发送了http请求了，请求结果如何。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[[outputs.opentsdb]]<br>  host = &quot;http://127.0.0.1&quot;<br>  port = 17000<br>  http_batch_size = 50<br>  http_path = &quot;/opentsdb/put&quot;<br>  debug = true # 注意<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>夜莺监控系统</title>
    <link href="/2023/07/18/%E5%A4%9C%E8%8E%BA%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/07/18/%E5%A4%9C%E8%8E%BA%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>夜莺是一个服务端组件，类似 Grafana。agent采集数据上报给夜莺，夜莺将数据转存到后端数据源。夜莺的角色只是一个 Pushgateway 的角色。数据存储到数据源后，夜莺再读取数据源，对数据源的数据进行类似Grafana的可视化分析。</p><p>具体可以看<a href="https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v6/introduction/">官网</a>，最好看最新的V6版本。</p><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/../images/image-20230719104251629.png" alt="image-20230719104251629"></p><p>从架构图上可以看出，<strong>agent 采集了数据推给夜莺</strong>（agent 包括图上的Telegraf、Categraf、还有Grafana-agent、Datadog-agent、Prometheus 生态的各类 Exporter 等等），夜莺适配了这些 agent 的数据传输协议，所以可以接收这些 agent 上报的监控数据，<strong>然后夜莺将采集的数据转存到后端对接的数据源</strong>。对于后端对接的数据源，夜莺可以接入不同的数据源，比如 Prometheus、VictoriaMetrics、Thanos 等等，<strong>只要数据进到这些库里了，夜莺就可以对数据源的数据进行分析、告警、可视化，以及后续的事件处理、告警自愈</strong>。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>下面的部署方式是笔者自己测试成功的两种。</p><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://gitlink.org.cn/ccfos/nightingale.git<br>cd nightingale/docker/experience_pg_vm<br>rm -rf initsql # 执行该命令，启动的时候 DB 就不会重新初始化了<br>docker compose up -d<br>docker compose ps<br></code></pre></td></tr></table></figure><p>访问<a href="http://localhost:17000即可查看，用户名为root，密码为root.2020">http://localhost:17000即可查看，用户名为root，密码为root.2020</a></p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>参考<a href="https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v6/install/prometheus/">Prometheus 部署方案</a>部署好了Prometheus，然后参考<a href="https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v6/install/intro/">安装部署详解</a>的安装前置依赖部分及之后，依次安装mysql和redis，然后安装夜莺，安装完毕后登陆<a href="http://localhost:17000添加之前部署的Prometheus数据源，配置完毕后去夜莺的查询面板，就可以在夜莺的UI页面成功的读取到Prometheus的数据了。">http://localhost:17000添加之前部署的Prometheus数据源，配置完毕后去夜莺的查询面板，就可以在夜莺的UI页面成功的读取到Prometheus的数据了。</a></p><p>夜莺除了将数据写入了Prometheus之外，也可以写入其他数据库，比如VictoriaMetrics。VictoriaMetrics（也称为VM）是一个开源的高性能时间序列数据库和监控系统。它被设计用于处理大规模的时间序列数据，并提供快速、可靠的查询和存储功能。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go的死锁简介与预防</title>
    <link href="/2023/07/17/go%E7%9A%84%E6%AD%BB%E9%94%81/"/>
    <url>/2023/07/17/go%E7%9A%84%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>死锁是一个计算机名词，顾名思义，就是当两个或者多个进程，互相都在等待对方停止执行然后自己以获得一些资源，但是没有一方提前停止时，那么就会死锁。类比到生活中的一个例子，在小路后两个人迎面撞上，但是两个人都不给对方让路呆在原地想等对方先让路，那么这个时候就产生了死锁。</p><p>go中的死锁很大概率都是在涉及到goroutine、编写了goroutine代码的时候发生的，但是即使不涉及goroutine，也可能会发生死锁。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面是一个简单的golang中会发生死锁的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>a &lt;- <span class="hljs-string">&quot;string&quot;</span><br>a &lt;- <span class="hljs-string">&quot;ccc&quot;</span><br><span class="hljs-comment">// close(a)</span><br>&#125;()<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> a &#123;<br>fmt.Println(v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行这段代码得到的结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">string<br>ccc<br>fatal error: all goroutines are asleep - deadlock!<br><br>goroutine 1 [chan receive]:<br>main.main()<br>        /Users/rhettnina/MyLocalFile/Work/code/flora-gopacket-service/a_my_tester/aaa/main.go:15 +0xce<br>exit status 2<br></code></pre></td></tr></table></figure><p>报错结果的15行就是<code>for v := range a &#123;</code>这一行。</p><blockquote><p>代码里的a是大小为10的channel，大小为10意味着在被接收前该channel最多可存储10个元素。如果代码里的a是无缓冲的channel即这样定义：<code>a := make(chan string)</code>，运行后也还说会报相同的错误。</p></blockquote><h3 id="发生原因"><a href="#发生原因" class="headerlink" title="发生原因"></a>发生原因</h3><p>那么这段代码为什么会发生死锁呢？</p><p>因为<code>for v := range a &#123;</code>会遍历channel a，获取到channel中的元素。往a中传入了string和ccc这两个值后都可以在15行成功获取到这两个值并打印出来，但是该程序的子goroutine往a中传入这两个值之后就退出了，之后channel a不会再被传入任何值了。而15行却不知道channel a不会再被传入任何值了，会一直等待，这种情况就是死锁了。因为golang语言自带判断死锁的机制，所以运行时如果判断出发生了死锁就会报错，所以就输出了<code>fatal error: all goroutines are asleep - deadlock!</code>这一行。</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>解决方法也很简单，只要不让主goroutine里的<code>for v := range a &#123;</code>这一行一直在等待即可，这一行代码一直在等待是因为主goroutine不知道channel a已经不会再有元素写入了，所以只需要告知主goroutine这一点。</p><p>解决方法是关闭掉channel，即取消注释<code>// close(a)</code>这一行。channel的关闭操作只能由channel的发送数据方操作，关闭后，读取channel数据方就会知晓channel已经被关闭了，那么接收方读取完channel的最后一个数据后就不会再陷入等待而是不再继续读取了。</p><p>总结下来，close channel的作用就是告诉接收方：这个channel已经被关闭了，不可能再有数据被写入了，你不用一直等待了。所以channel关闭后不可写但可读。</p><h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><p>其实死锁这个问题大概率是写代码的时候不会意识到，只有在程序运行后报错了才知道原来发生死锁了。报错后可用通过pprof来协助排查和定位死锁问题。所以pprof是出现问题后的检测工具，那么有没有在开发的时候就能帮助排查程序是否可能出现死锁问题的工具呢？答案就是<a href="https://github.com/uber-go/goleak">goleak</a>。</p><h2 id="设计最佳实践"><a href="#设计最佳实践" class="headerlink" title="设计最佳实践"></a>设计最佳实践</h2><p>下面是一些编码时的规范，遵循这些规范可在很大层面上避免死锁的发生。</p><ul><li>如果想减少goroutine相互等待的可能性，可以用无缓冲的channel</li><li>为了避免一些goroutine的无限制等待，可以使用context来在goroutine之间发送和传递取消信号</li><li>使用select语句来实现超时效果，在select中通过time.After指定超时时间</li><li>无缓冲的管道应该先接收再发送</li><li>channel尽可能进行关闭操作，这个只能发送端来做</li><li>channel接收端应该尽可能增加对channel是否关闭了的判断</li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GraphQL入门</title>
    <link href="/2023/06/11/GraphQL%E5%85%A5%E9%97%A8/"/>
    <url>/2023/06/11/GraphQL%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="GraphQL入门"><a href="#GraphQL入门" class="headerlink" title="GraphQL入门"></a>GraphQL入门</h1><p>GraphQL 是一个用于 API 的查询语言</p><p>GraphQL 是一种针对 Graph（图状数据）进行查询特别有优势的 Query Language（查询语言），所以叫做 GraphQL。</p><p>GraphQL 跟用作存储的 NoSQL 等没有必然联系，<strong>GraphQL 背后的实际存储可以选择 NoSQL 型或是 SQL 类型的数据库，甚至任意其它存储方式（例如文本文件、存内存里等等）</strong>。虽然GraphQL是查询语言，但它与数据库没有直接关系</p><p>一旦一个 <strong>GraphQL 服务运行起来（</strong>通常在 web 服务的一个 URL 上），它就能接收 GraphQL 查询，并验证和执行。</p><p>GraphQL 是 Facebook 发明的</p><p>并不是所有场景都适用于 GraphQL 的，有些很简单的事情就应该用 RESTful API 来实现</p><p>GraphQL 尽管查询的数据是图状数据结构，但实际获得的数据视图是树状数据结构。每一个 GraphQL 查询或更新都有自己的根节点，然后所有的数据都是从根结点展开出去的。</p><p>GraphQL 对你的 API 中的数据提供一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p><p>其他乱七八糟的整理</p><hr><p><strong>brew update和brew upgrade有什么区别</strong></p><p><code>brew update</code> 和 <code>brew upgrade</code> 是两个常用于管理 macOS 上 Homebrew 软件包管理器的命令，它们的区别如下：</p><ol><li><code>brew update</code>：用于更新 Homebrew 自身以及其软件包清单。执行 <code>brew update</code> 会从 Homebrew 的 Git 仓库中拉取最新的版本信息，包括软件包清单、Formula（软件包的构建脚本）等，并更新本地的 Homebrew 安装。这样可以确保使用最新的软件包清单来安装和更新软件包。</li><li><code>brew upgrade</code>：用于升级已安装的软件包到最新版本。执行 <code>brew upgrade</code> 会检查已安装的软件包，如果有新版本可用，则会升级到最新版本。需要注意的是，<code>brew upgrade</code> 只会升级已安装的软件包，不会安装新的软件包。</li></ol><p>简而言之，<code>brew update</code> 是更新 Homebrew 本身和软件包清单，而 <code>brew upgrade</code> 是升级已安装的软件包到最新版本。通常情况下，先执行 <code>brew update</code> 更新软件包清单，然后再执行 <code>brew upgrade</code> 来升级已安装的软件包。</p><p>下面是一个简单的使用 <code>brew update</code> 和 <code>brew upgrade</code> 的例子：</p><ol><li>执行 <code>brew update</code> 更新 Homebrew 自身和软件包清单：</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">rubyCopy</span> <span class="hljs-meta">code</span><br>$ brew update<br></code></pre></td></tr></table></figure><p>这会从 Homebrew 的 Git 仓库中拉取最新的版本信息，并更新本地的 Homebrew 安装。</p><ol><li>执行 <code>brew upgrade</code> 升级已安装的软件包到最新版本：</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">rubyCopy</span> <span class="hljs-meta">code</span><br>$ brew upgrade<br></code></pre></td></tr></table></figure><p>这会检查已安装的软件包，如果有新版本可用，则会升级到最新版本。</p><p>需要注意的是，<code>brew update</code> 和 <code>brew upgrade</code> 只会更新和升级 Homebrew 管理的软件包，不会影响系统自带的软件包或其他方式安装的软件包。在执行 <code>brew update</code> 和 <code>brew upgrade</code> 时，可以根据需要选择性更新和升级特定的软件包，如：</p><ul><li><code>brew update &lt;formula&gt;</code>：更新指定的软件包。</li><li><code>brew upgrade &lt;formula&gt;</code>：升级指定的软件包。</li></ul><p>以上是使用 <code>brew update</code> 和 <code>brew upgrade</code> 的简单示例，具体的使用方法和参数可以参考 Homebrew 的官方文档或命令行帮助。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搬运：Wireshark使用详解</title>
    <link href="/2023/04/14/Wireshark%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/04/14/Wireshark%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>本篇内容是从参考中总结的。</p><p>当我们的UDP包中的数据多于MTU(1472)时，发送方的IP层需要分片fragmentation进行传输，而在接收方IP层则需要进行数据报重组，由于UDP是不可靠的传输协议，如果分片丢失导致重组失败，将导致UDP数据包被丢弃</p><p>TCP分段是在传输层完成，并在传输层进行重组. IP分片由网络层完成，也在网络层进行重组。所以使用TCP协议进行数据传输，是不会造成IP分片的，因为TCP会自己分段，<strong>TCP分段</strong>的大小是不会产生<strong>IP分片</strong>的。（注意这两个名次）</p><p> 而对于没有大小限制的UDP协议（这是传输层的协议），则则需要下一层网络层（IP协议）来分片。</p><p>我们常提到的IP分片是由于UDP传输协议造成的，因为UDP传输协议并未限定传输数据报的大小</p><p>第一层显示的是FrameXXX，这一级别没有对应某层具体的协议，而是对本条消息的一个概括性总结，描述了一些有用的概括性信息</p><p><strong>Note:</strong><br><strong>a) 数据在 IP 层称为 Datagram ，分片称为 Fragment</strong><br><strong>b) 数据在 TCP 层称为 Stream，分段称为 Segment</strong><br><strong>c) 数据在 UDP层称为 Message</strong></p><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>MAC地址用来表示互联网上每一个站点的标识符，采用十六进制数表示，共六个字节（48位）</p><p><strong>以太网的解析，Wireshark没有显示全部的内容</strong>，只显示了6个字节的目的MAC地址，6个字节的源MAC地址，2个字节的类型域这三项，其实Wireshark只解析了前三个字节，如GemtekTe、Tp-LinkT，后三个字节原封不动的保留在了解析结果里。</p><p>以太网头部一共有这么多信息，但是Wireshark只展示了部分有用的</p><p><img src="/../images/image-20230414154032357.png" alt="image-20230414154032357"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>IP头与数据包中数据的长度 (256 – 14），这里的14是以太网的头部长度，总的数据包大小减去以太网头部就是IP层整个包的大小</p><p>IP包中有一个 **Identification字段，同一数据流的分片身份序列相同)**，这是用来识别一个数据包或被分片数据包的次序，一个唯一的标识数字。</p><p><img src="/../images/image-20230414153635211.png" alt="image-20230414153635211"></p><p>IP还有一个用于标记是否当前IP包是否被分片了的标记Flag，比如下面的这个是被分片了的，对于Flags，三位的含义依次是</p><ul><li>0… …. &#x3D; Reserved bit: Not set —— 无保留位，没有设置</li><li>1.. …. &#x3D; Don’t fragment: Set —— IP不分片</li><li>..0. …. &#x3D; More fragments: Not set —— 其余分段没有设置</li></ul><p><img src="/../images/image-20230414154528192.png" alt="image-20230414154528192"></p><p>根据Identification字段，找到剩余的一个分片：</p><p><img src="/../images/image-20230414154659146.png" alt="image-20230414154659146"></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>TCP的Stream index是根据src.ip src.port dst.ip dst.port生成的一个索引号</p><p><img src="/../images/image-20230414155847145.png" alt="image-20230414155847145"></p><p><strong>TCP Segment Len: 202 ( Next sequence – Sequence ) number</strong>，表示TCP 携带数据的长度</p><p>不同头部大小：实际抓包中 SYN和SYN ACK包的TCP头部是32字节，有的时候是28字节，多了12或8字节的选项和填充字段。而ACK和FIN ACK包的TCP头部都是20字节。</p><p>比如下面这个包含SYN的包，多了Options字段</p><p><img src="/../images/image-20230414163138676.png" alt="image-20230414163138676"></p><p>每个TCP Option，Kind值表示TCP的选项，TCP有两种类型的选项：单字节和多字节。每一个选项有同样的结构：Kind + Length + Data，其中Lenght表示Kind、Lenght、Data三者的总长度，单字节的选项只有Kind</p><p>关于这些选项，就+有如下规则：</p><p>KIND（8bit）+LENGTH（8bit，NOP没有LENGTH部分）+内容（如果有的话）</p><p>Kind&#x3D;0表示选项结束——1字节</p><p>Kind&#x3D;1表示无操作，主要是用来占位从而达到字节对齐的目的——-1字节</p><p>Kind&#x3D;2表示MSS选项——4字节</p><p>Kind&#x3D;3表示窗口大小（窗口扩大因子）——3字节</p><p>Kind&#x3D;4表示SACK-Permitted——-2字节</p><p>Kind&#x3D;5表示一个SACK包—–可变长度</p><p>Kind&#x3D;8表示时间戳—–10字节</p><p>TCP断开：TCP连接的建立是通过三次握手完成的，而TCP正常释放连接是通过四次挥手来完成，但是有些情况下，TCP在交互的过程中会出现一些意想不到的情况，导致TCP无法按照正常的四次挥手来释放连接，如果此时不通过其他的方式来释放TCP连接的话，这个TCP连接将会一直存在，占用系统的部分资源。在这种情况下，我们就需要有一种能够释放TCP连接的机制，这种机制就是TCP的reset报文。</p><h2 id="wireshark的着色规则"><a href="#wireshark的着色规则" class="headerlink" title="wireshark的着色规则"></a>wireshark的着色规则</h2><p>查看Wireshark着色规则</p><p><img src="/../images/image-20230414145436325.png" alt="image-20230414145436325"></p><p>我的wireshark中看到的是这些</p><p><img src="/../images/image-20230414145737418.png" alt="image-20230414145737418"></p><p>参考</p><p><a href="https://blog.csdn.net/u011414200/article/details/47945661">原文1:Wireshark 数据分析（二）</a></p><p><a href="https://blog.csdn.net/u011414200/article/details/47948401">Wireshark 数据分析（三）</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pprof使用</title>
    <link href="/2023/04/13/pprof%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/04/13/pprof%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>pprof可以用来分析程序的性能，pprof可以指定不同的监控指标，所有指标如下：</p><ul><li>profile：查看CPU占用率的，这是最常使用的一种类型。用于找出哪些函数或代码片段消耗了大量的 CPU 时间。</li><li>heap：也常使用。用于分析程序的内存使用情况；</li><li>allocs：总体的内存使用情况，包括正在使用的内存和已经回收了的内存。</li><li>goroutine：查看goroutine数量，运行情况等。</li><li>mutex：锁竞争情况</li><li>block：协程阻塞情况</li></ul><p>如果在程序里启动pprof http端口，比如端口为8080，那么通过 <a href="http://localhost:8080/debug/pprof/">http://localhost:8080/debug/pprof/</a> 可以查看内存占用率，最后一个参数代表监控指标，把最后的pprof换成alloc就可以查看总体的内存使用情况。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>引用pprof包</p><p>单独启动一个pprof的HTTP服务，如果之前没有启动http服务，可以启动一个pprof的单独goroutine，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>http.ListenAndServe(<span class="hljs-string">&quot;localhost:6060&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;()<br></code></pre></td></tr></table></figure><p>比如下面之前没有启动http服务，下面的代码没有启动单独的goroutine而是只启动了一个可以pprof的服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// Start the HTTP server on port 8080</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果之前已经启动了http服务，那么在http服务的&#x2F;debug&#x2F;pprof路由可以查看pprof的结果，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>fmt.Fprint(w, <span class="hljs-string">&quot;Hello, World!&quot;</span>) <span class="hljs-comment">// Send &quot;Hello, World!&quot; as the response</span><br>&#125;)<br>http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// Start the HTTP server on port 8080</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>程序启动后，查看 <a href="http://localhost:8080/debug/pprof%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0">http://localhost:8080/debug/pprof，可以看到</a></p><p>![image-20230413103046287](&#x2F;Users&#x2F;rhettnina&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230413103046287.png)</p><p>查看 <a href="http://localhost:8080/debug/pprof/goroutine?debug=1%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AAgoroutine">http://localhost:8080/debug/pprof/goroutine?debug=1，可以看到程序中有多少个goroutine</a></p><blockquote><p>比如查看<a href="http://localhost:8080/debug/pprof/goroutine?debug=1%E6%98%BE%E7%A4%BA%E7%9A%84%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8080/debug/pprof/goroutine?debug=1显示的结果如下：</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs shell">goroutine profile: total 16<br>1 @ 0x4007e9c 0x456c52c 0x456f2f0 0x456f259 0x4569e92 0x4569cde 0x44f1c2b 0x44f1e4a 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x456c52bgithub.com/google/gopacket/pcap._Cfunc_pcap_next_ex_escaping+0x4b_cgo_gotypes.go:568</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x456f2efgithub.com/google/gopacket/pcap.(*Handle).pcapNextPacketEx.func1+0x6f/Users/ahah/.gvm/pkgsets/go1.19/global/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap_unix.go:398</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x456f258github.com/google/gopacket/pcap.(*Handle).pcapNextPacketEx+0x18/Users/ahah/.gvm/pkgsets/go1.19/global/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap_unix.go:398</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x4569e91github.com/google/gopacket/pcap.(*Handle).getNextBufPtrLocked+0x71/Users/ahah/.gvm/pkgsets/go1.19/global/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap.go:312</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x4569cddgithub.com/google/gopacket/pcap.(*Handle).ReadPacketData+0x7d/Users/ahah/.gvm/pkgsets/go1.19/global/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap.go:252</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x44f1c2agithub.com/google/gopacket.(*PacketSource).NextPacket+0x6a/Users/ahah/.gvm/pkgsets/go1.19/global/pkg/mod/github.com/google/gopacket@v1.1.19/packet.go:801</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x44f1e49github.com/google/gopacket.(*PacketSource).packetsToChannel+0x69/Users/ahah/.gvm/pkgsets/go1.19/global/pkg/mod/github.com/google/gopacket@v1.1.19/packet.go:818</span><br><br>1 @ 0x4034e96 0x406c2c5 0x486a9b5 0x486a7cd 0x486774b 0x49da2e5 0x49dae7e 0x43ab62f 0x43ad349 0x43aef0c 0x43aa107 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x406c2c4runtime/pprof.runtime_goroutineProfileWithLabels+0x24/Users/ahah/.gvm/gos/go1.19/src/runtime/mprof.go:846</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x486a9b4runtime/pprof.writeRuntimeProfile+0xb4/Users/ahah/.gvm/gos/go1.19/src/runtime/pprof/pprof.go:723</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x486a7ccruntime/pprof.writeGoroutine+0x4c/Users/ahah/.gvm/gos/go1.19/src/runtime/pprof/pprof.go:683</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x486774aruntime/pprof.(*Profile).WriteTo+0x14a/Users/ahah/.gvm/gos/go1.19/src/runtime/pprof/pprof.go:330</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x49da2e4net/http/pprof.handler.ServeHTTP+0x4a4/Users/ahah/.gvm/gos/go1.19/src/net/http/pprof/pprof.go:253</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x49dae7dnet/http/pprof.Index+0x13d/Users/ahah/.gvm/gos/go1.19/src/net/http/pprof/pprof.go:371</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x43ab62enet/http.HandlerFunc.ServeHTTP+0x2e/Users/ahah/.gvm/gos/go1.19/src/net/http/server.go:2109</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x43ad348net/http.(*ServeMux).ServeHTTP+0x148/Users/ahah/.gvm/gos/go1.19/src/net/http/server.go:2487</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x43aef0bnet/http.serverHandler.ServeHTTP+0x30b/Users/ahah/.gvm/gos/go1.19/src/net/http/server.go:2947</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x43aa106net/http.(*conn).serve+0x606/Users/ahah/.gvm/gos/go1.19/src/net/http/server.go:1991</span><br><br>1 @ 0x4039fde 0x406ee88 0x49dc999 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x406ee87os/signal.signal_recv+0x27/Users/ahah/.gvm/gos/go1.19/src/runtime/sigqueue.go:149</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x49dc998os/signal.loop+0x18/Users/ahah/.gvm/gos/go1.19/src/os/signal/signal_unix.go:23</span><br><br>1 @ 0x4040176 0x400ae9b 0x400a998 0x49b9dc6 0x49dd32e 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x49b9dc5sincerecloud.com/flora-gopacket-service/input.(*InputBox).Beat+0x65/Users/ahah/MyLocalFile/aWork/code/flora-gopacket-service/input/input_box.go:26</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x49dd32dmain.Inputs.start.func1+0x6d/Users/ahah/MyLocalFile/aWork/code/flora-gopacket-service/inputs.go:47</span><br><br>1 @ 0x4040176 0x400ae9b 0x400a998 0x49dd874 0x403fdb2 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x49dd873main.main+0x333/Users/ahah/MyLocalFile/aWork/code/flora-gopacket-service/main.go:80</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x403fdb1runtime.main+0x211/Users/ahah/.gvm/gos/go1.19/src/runtime/proc.go:250</span><br><br>1 @ 0x4040176 0x400ae9b 0x400a998 0x49ddd94 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x49ddd93main.listenSignal+0xb3/Users/ahah/MyLocalFile/aWork/code/flora-gopacket-service/main.go:89</span><br><br>1 @ 0x4040176 0x400ae9b 0x400a9d8 0x44e7825 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x44e7824gopkg.in/natefinch/lumberjack%2ev2.(*Logger).millRun+0x44/Users/ahah/.gvm/pkgsets/go1.19/global/pkg/mod/gopkg.in/natefinch/lumberjack.v2@v2.0.0/lumberjack.go:379</span><br><br>1 @ 0x4040176 0x400ae9b 0x400a9d8 0x49dda25 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x49dda24main.main.func2+0x64/Users/ahah/MyLocalFile/aWork/code/flora-gopacket-service/main.go:61</span><br><br>1 @ 0x4040176 0x4038e17 0x406c6c9 0x40e67b2 0x40ebbb4 0x40ebba1 0x415f895 0x41790e8 0x417817d 0x43af545 0x43af09d 0x49dd4c5 0x49dd499 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x406c6c8internal/poll.runtime_pollWait+0x88/Users/ahah/.gvm/gos/go1.19/src/runtime/netpoll.go:305</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x40e67b1internal/poll.(*pollDesc).<span class="hljs-built_in">wait</span>+0x31/Users/ahah/.gvm/gos/go1.19/src/internal/poll/fd_poll_runtime.go:84</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x40ebbb3internal/poll.(*pollDesc).waitRead+0x233/Users/ahah/.gvm/gos/go1.19/src/internal/poll/fd_poll_runtime.go:89</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x40ebba0internal/poll.(*FD).Accept+0x220/Users/ahah/.gvm/gos/go1.19/src/internal/poll/fd_unix.go:614</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x415f894net.(*netFD).accept+0x34/Users/ahah/.gvm/gos/go1.19/src/net/fd_unix.go:172</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x41790e7net.(*TCPListener).accept+0x27/Users/ahah/.gvm/gos/go1.19/src/net/tcpsock_posix.go:142</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x417817cnet.(*TCPListener).Accept+0x3c/Users/ahah/.gvm/gos/go1.19/src/net/tcpsock.go:288</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x43af544net/http.(*Server).Serve+0x384/Users/ahah/.gvm/gos/go1.19/src/net/http/server.go:3070</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x43af09cnet/http.(*Server).ListenAndServe+0x7c/Users/ahah/.gvm/gos/go1.19/src/net/http/server.go:2999</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x49dd4c4net/http.ListenAndServe+0x44/Users/ahah/.gvm/gos/go1.19/src/net/http/server.go:3255</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x49dd498main.main.func1+0x18/Users/ahah/MyLocalFile/aWork/code/flora-gopacket-service/main.go:32</span><br><br>1 @ 0x4040176 0x405039c 0x4494b65 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x4494b64github.com/spf13/viper.(*Viper).WatchConfig.func1.1+0x104/Users/ahah/.gvm/pkgsets/go1.19/global/pkg/mod/github.com/spf13/viper@v1.15.0/viper.go:461</span><br><br>1 @ 0x4040176 0x405039c 0x49b8cf8 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x49b8cf7sincerecloud.com/flora-gopacket-service/input.(*packetCapturer).captureByDevice+0x437/Users/ahah/MyLocalFile/aWork/code/flora-gopacket-service/input/capturer.go:125</span><br><br>1 @ 0x4040176 0x405161e 0x40515f5 0x406e725 0x408d9f2 0x4494a05 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x406e724sync.runtime_Semacquire+0x24/Users/ahah/.gvm/gos/go1.19/src/runtime/sema.go:62</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x408d9f1<span class="hljs-built_in">sync</span>.(*WaitGroup).Wait+0x51/Users/ahah/.gvm/gos/go1.19/src/sync/waitgroup.go:139</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x4494a04github.com/spf13/viper.(*Viper).WatchConfig.func1+0x304/Users/ahah/.gvm/pkgsets/go1.19/global/pkg/mod/github.com/spf13/viper@v1.15.0/viper.go:498</span><br><br>1 @ 0x4040176 0x405161e 0x40515f5 0x406e725 0x408d9f2 0x49dd214 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x406e724sync.runtime_Semacquire+0x24/Users/ahah/.gvm/gos/go1.19/src/runtime/sema.go:62</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x408d9f1<span class="hljs-built_in">sync</span>.(*WaitGroup).Wait+0x51/Users/ahah/.gvm/gos/go1.19/src/sync/waitgroup.go:139</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x49dd213main.Inputs.start+0x133/Users/ahah/MyLocalFile/aWork/code/flora-gopacket-service/inputs.go:50</span><br><br>1 @ 0x406f799 0x4118952 0x41187dc 0x411c1a5 0x411ae4d 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x406f798syscall.syscall6+0x98/Users/ahah/.gvm/gos/go1.19/src/runtime/sys_darwin.go:44</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x4118951golang.org/x/sys/unix.kevent+0x51/Users/ahah/.gvm/pkgsets/go1.19/global/pkg/mod/golang.org/x/sys@v0.3.0/unix/zsyscall_darwin_amd64.go:276</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x41187dbgolang.org/x/sys/unix.Kevent+0x3b/Users/ahah/.gvm/pkgsets/go1.19/global/pkg/mod/golang.org/x/sys@v0.3.0/unix/syscall_bsd.go:399</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x411c1a4github.com/fsnotify/fsnotify.(*Watcher).<span class="hljs-built_in">read</span>+0x44/Users/ahah/.gvm/pkgsets/go1.19/global/pkg/mod/github.com/fsnotify/fsnotify@v1.6.0/backend_kqueue.go:702</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x411ae4cgithub.com/fsnotify/fsnotify.(*Watcher).readEvents+0xcc/Users/ahah/.gvm/pkgsets/go1.19/global/pkg/mod/github.com/fsnotify/fsnotify@v1.6.0/backend_kqueue.go:487</span><br><br>1 @ 0x4072f41<br><br>1 @ 0x49bb1a5 0x49b9eb4 0x4072f41<br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x49bb1a4sincerecloud.com/flora-gopacket-service/input.(*packetInput).ReadOneEvent+0x84/Users/ahah/MyLocalFile/aWork/code/flora-gopacket-service/input/packet_input.go:99</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">0x49b9eb3sincerecloud.com/flora-gopacket-service/input.(*InputBox).beat+0x53/Users/ahah/MyLocalFile/aWork/code/flora-gopacket-service/input/input_box.go:35</span><br></code></pre></td></tr></table></figure><p>那么表示该程序共有16个goroutine，每个goroutine都是以<code>1 @ </code>开头的。</p></blockquote><h3 id="CPU-profiling（CPU分析）"><a href="#CPU-profiling（CPU分析）" class="headerlink" title="CPU profiling（CPU分析）"></a>CPU profiling（CPU分析）</h3><p><code>pprof</code> 的 CPU profiling 结果包括以下信息：</p><ol><li>函数耗时：可以看到每个函数在 CPU 上的运行耗时，包括累计 CPU 时间和 CPU 时间百分比。</li><li>函数调用关系：可以查看函数之间的调用关系，了解函数之间的调用深度和调用频率。</li><li>内联函数：可以看到哪些函数在编译时被内联展开，以及内联展开后的耗时。</li><li>热点函数：可以查看耗时最高的函数，帮助你找到可能的性能瓶颈。</li><li>执行栈信息：可以查看每个函数在被调用时的执行栈信息，帮助你定位耗时较高的代码路径。</li><li>源代码位置：可以查看每个函数在源代码中的位置，帮助你定位到具体的代码行。</li></ol><p>CPU profiling 结果可能会受到多种因素的影响，例如采样频率、运行环境等，因此在分析 profiling 结果时要结合实际情况进行综合判断。</p><p>pprof会分析pprof.StartCPUProfile()到pprof.StopCPUProfile()之间的所有代码，所以可以在StartCPUProfile执行defer StopCPUProfile，可以分析出StartCPUProfile后执行的所有代码。</p><p>StartCPUProfile接收一个io.Writer类型的参数，pprof会将分析的结果写到这个参数里。</p><p><strong>比如生产环境出问题了，经常会在用pprof诊断的时候把pprof的分析结果存储到文件里，然后再对文件进行分析。</strong></p><h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;runtime/pprof&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">busyLoop</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++ &#123;<br>rand.Intn(<span class="hljs-number">100</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slowFunction</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建一个文件用于保存 profiling 数据</span><br>f, err := os.Create(<span class="hljs-string">&quot;profile.prof&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;无法创建文件:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> f.Close()<br><br><span class="hljs-comment">// 开始 CPU profiling</span><br>err = pprof.StartCPUProfile(f)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;无法开始 CPU profiling:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> pprof.StopCPUProfile()<br><br><span class="hljs-comment">// 模拟一个耗时的函数</span><br>slowFunction()<br><br><span class="hljs-comment">// 模拟一个消耗 CPU 的循环</span><br>busyLoop()<br><br><span class="hljs-comment">// 生成一些 profiling 数据</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>busyLoop()<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;pprof 结果保存在 profile.prof 文件中。&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查看与分析"><a href="#查看与分析" class="headerlink" title="查看与分析"></a>查看与分析</h4><p>程序执行完毕后，会生成一个profile.prof文件，可以分析这个文件来知晓刚刚执行的情况。</p><p>执行 <code>go tool pprof profile.prof</code>，会出现一个命令交互界面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">go tool pprof profile.prof<br>Type: cpu<br>Time: Apr 13, 2023 at 11:08am (CST)<br>Duration: 3.43s, Total samples = 2.01s (58.68%)<br>Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)<br>(pprof) <br></code></pre></td></tr></table></figure><p>可以输出一些命令，如输入top查看耗时最高的10个函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">go tool pprof profile.prof<br>Type: cpu<br>Time: Apr 13, 2023 at 11:08am (CST)<br>Duration: 3.43s, Total samples = 2.01s (58.68%)<br>Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)<br>(pprof) top<br>Showing nodes accounting for 2010ms, 100% of 2010ms total<br>Showing top 10 nodes out of 12<br>      flat  flat%   sum%        cum   cum%<br>     760ms 37.81% 37.81%     1340ms 66.67%  math/rand.(*lockedSource).Int63<br>     450ms 22.39% 60.20%     1790ms 89.05%  math/rand.(*Rand).Int31n<br>     450ms 22.39% 82.59%      450ms 22.39%  sync.(*Mutex).Unlock (inline)<br>     190ms  9.45% 92.04%     1980ms 98.51%  math/rand.(*Rand).Intn<br>      90ms  4.48% 96.52%       90ms  4.48%  math/rand.(*rngSource).Uint64 (inline)<br>      40ms  1.99% 98.51%      130ms  6.47%  math/rand.(*rngSource).Int63 (inline)<br>      30ms  1.49%   100%     2010ms   100%  main.busyLoop (inline)<br>         0     0%   100%     2010ms   100%  main.main<br>         0     0%   100%     1340ms 66.67%  math/rand.(*Rand).Int31 (inline)<br>         0     0%   100%     1340ms 66.67%  math/rand.(*Rand).Int63 (inline)<br></code></pre></td></tr></table></figure><p>默认显示耗时最高的10个函数，也可以执行top1 top3这样的topN获取耗时最高的N个函数。</p><p>执行<code>list xx</code>查看函数某个函数的各个模块调用耗时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">(pprof) list main.busyLoop<br>Total: 2.22s<br>ROUTINE ======================== main.busyLoop in /Users/rhettnina/Downloads/test-git/a.go<br>      50ms      2.22s (flat, cum)   100% of Total<br>         .          .     11:func busyLoop() &#123;<br>      50ms       50ms     12:   for i := 0; i &lt; 10000000; i++ &#123;<br>         .      2.17s     13:           rand.Intn(100)<br>         .          .     14:   &#125;<br>         .          .     15:&#125;<br>         .          .     16:<br>         .          .     17:func slowFunction() &#123;<br>         .          .     18:   time.Sleep(time.Second)<br></code></pre></td></tr></table></figure><p>PS：有的时候执行top显示为空，是因为因为启用 CPU profiling 之后，运行时每隔 10ms 会中断一次，记录每个 goroutine 当前执行的堆栈，以此来分析耗时。如果程序在10ms内执行完毕了，可能就不会记录到任何信息，所以top命令显示为空。</p><h3 id="Memory-profiling（内存分析）"><a href="#Memory-profiling（内存分析）" class="headerlink" title="Memory profiling（内存分析）"></a>Memory profiling（内存分析）</h3><p><code>pprof</code> 的 Memory profiling 结果包括以下信息：</p><ol><li>内存分配：可以查看每个函数或代码片段在内存中分配的对象数量、大小、内存分配的累计字节数等信息，帮助你了解每个函数的内存分配情况。</li><li>内存使用：可以查看每个函数或代码片段在内存中使用的对象数量、大小、内存使用的累计字节数等信息，帮助你了解每个函数的内存使用情况。</li><li>内存释放：可以查看每个函数或代码片段在内存中释放的对象数量、大小、内存释放的累计字节数等信息，帮助你了解每个函数的内存释放情况。</li><li>内存分配堆栈：可以查看每个函数在内存分配时的堆栈信息，帮助你定位到内存分配较高的代码路径。</li><li>内存使用堆栈：可以查看每个函数在内存使用时的堆栈信息，帮助你定位到内存使用较高的代码路径。</li></ol><h4 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h4><p>下面是两个比较常用的函数。</p><p><code>pprof.Lookup(&quot;heap&quot;)</code>这是一个 pprof 提供的用于获取<strong>堆内存分析数据的函数</strong>。通过这个函数，我们可以获得用于 heap（堆）的 Memory profiling 数据。</p><p><code>WriteTo(f, 0)</code>：这是将堆内存分析数据写入到文件（f）中的操作。<code>f</code> 是一个已经创建好的文件对象，<code>0</code> 是指导写入的标志位，其中 0 表示默认标志位，用于输出完整的内存分析数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;runtime/pprof&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建一个文件用于存储 pprof 输出</span><br>f, err := os.Create(<span class="hljs-string">&quot;mem.prof&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Failed to create profile file:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> f.Close()<br><br><span class="hljs-comment">// 开始 Memory profiling</span><br><span class="hljs-comment">// WriteHeapProfile是Lookup(&quot;heap&quot;).WriteTo(w, 0)的缩写</span><br><span class="hljs-keyword">if</span> err := pprof.WriteHeapProfile(f); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Failed to start memory profiling:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 模拟一个占用内存的操作</span><br><span class="hljs-keyword">var</span> s []<span class="hljs-type">byte</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-type">byte</span>(i))<br>&#125;<br><span class="hljs-comment">// 结束 Memory profiling</span><br>pprof.StopCPUProfile()<br>fmt.Println(<span class="hljs-string">&quot;Memory profiling completed. Output saved to mem.prof&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查看与分析-1"><a href="#查看与分析-1" class="headerlink" title="查看与分析"></a>查看与分析</h4><p>与上面的CPU profiling进行的运行时间分析不同，这里分析的是内存占用大小，所以数据统计维度是内存的占用大小。比如执行top会列出占用内存最多的函数，list 函数名会列出这个函数的各个部分占用了多少内存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs shell">o tool pprof mem.prof  <br>Type: inuse_space<br>Time: Apr 13, 2023 at 2:36pm (CST)<br>Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)<br>(pprof) top<br>Showing nodes accounting for 1536.81kB, 100% of 1536.81kB total<br>Showing top 10 nodes out of 14<br>      flat  flat%   sum%        cum   cum%<br>  512.56kB 33.35% 33.35%   512.56kB 33.35%  runtime.allocm<br>  512.20kB 33.33% 66.68%   512.20kB 33.33%  runtime.malg<br>  512.05kB 33.32%   100%   512.05kB 33.32%  runtime.main<br>         0     0%   100%   512.56kB 33.35%  runtime.mstart<br>         0     0%   100%   512.56kB 33.35%  runtime.mstart0<br>         0     0%   100%   512.56kB 33.35%  runtime.mstart1<br>         0     0%   100%   512.56kB 33.35%  runtime.newm<br>         0     0%   100%   512.20kB 33.33%  runtime.newproc.func1<br>         0     0%   100%   512.20kB 33.33%  runtime.newproc1<br>         0     0%   100%   512.56kB 33.35%  runtime.resetspinning<br>(pprof) list runtime.allocm<br>Total: 1.50MB<br>ROUTINE ======================== runtime.allocm in /usr/local/Cellar/go@1.17/1.17.12/libexec/src/runtime/proc.go<br>  512.56kB   512.56kB (flat, cum) 33.35% of Total<br>         .          .   1870:           &#125;<br>         .          .   1871:           sched.freem = newList<br>         .          .   1872:           unlock(&amp;sched.lock)<br>         .          .   1873:   &#125;<br>         .          .   1874:<br>  512.56kB   512.56kB   1875:   mp := new(m)<br>         .          .   1876:   mp.mstartfn = fn<br>         .          .   1877:   mcommoninit(mp, id)<br>         .          .   1878:<br>         .          .   1879:   // In case of cgo or Solaris or illumos or Darwin, pthread_create will make us a stack.<br>         .          .   1880:   // Windows and Plan 9 will layout sched stack on OS stack.<br>(pprof) list runtime.main<br>Total: 1.50MB<br>ROUTINE ======================== runtime.main in /usr/local/Cellar/go@1.17/1.17.12/libexec/src/runtime/proc.go<br>  512.05kB   512.05kB (flat, cum) 33.32% of Total<br>         .          .    211:           &#125;<br>         .          .    212:   &#125;()<br>         .          .    213:<br>         .          .    214:   gcenable()<br>         .          .    215:<br>  512.05kB   512.05kB    216:   main_init_done = make(chan bool)<br>         .          .    217:   if iscgo &#123;<br>         .          .    218:           if _cgo_thread_start == nil &#123;<br>         .          .    219:                   throw(&quot;_cgo_thread_start missing&quot;)<br>         .          .    220:           &#125;<br>         .          .    221:           if GOOS != &quot;windows&quot; &#123;<br></code></pre></td></tr></table></figure><h2 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>火焰图可以清楚看到上述的CPU profiling和Memory profiling二者的效果</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>对于上述生成的分析文件，执行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> tool pprof -http :<span class="hljs-number">8080</span> cpu.<span class="hljs-keyword">profile</span><br></code></pre></td></tr></table></figure><p>执行<code>brew install graphviz</code>，在 <a href="http://localhost:8080/ui/">http://localhost:8080/ui/</a> 查看</p><p><img src="/../images/image-20230413153052155.png" alt="image-20230413153052155"></p><p>可点击最上面的菜单View查看其他维度的分析。查看火焰图。</p><p><img src="/../images/image-20230413153457756.png" alt="image-20230413153457756"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于CPU profiling和Memory profiling的三方包推荐 <a href="https://github.com/pkg/profile">https://github.com/pkg/profile</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ipmi带外管理</title>
    <link href="/2023/04/11/ipmi%E5%B8%A6%E5%A4%96%E7%AE%A1%E7%90%86/"/>
    <url>/2023/04/11/ipmi%E5%B8%A6%E5%A4%96%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>IPMI（Intelligent Platform Management Interface）是一种由Intel开发的远程管理技术，通常用于管理和监视计算机系统。可以通过IPMI监控服务器的物理特征，如温度，电压等。只要机器接通电源即可，即使没有启动操作系统，就可以进行监控。目前最新版本是IPMI2.0。</p><p>IPMI可以让管理员通过网络连接访问计算机系统，以便在操作系统不可用或发生故障的情况下进行管理和维护。比如服务器宕机的时候，无法通过SSH连接的话可以通过IPMI来重启。</p><p>在计算机领域，带外管理（Out-of-band management）是指使用独立管理通道进行设备维护。它允许系统管理员远程监控和管理服务器、路由器、网络交换机和其他网络设备。带外管理通过部署与数据通道物理隔离的管理通道来解决这个限制。带外网管是指通过专门的网管通道实现对网络的管理，<strong>将网管数据与业务数据分开</strong>，为网管数据建立独立通道。</p><p>常见的设备管理方式有SNMP、RMON、Web、TELNET，这些管理方式属于带内管理。</p><p>相对的，带内管理是指使用常规数据通道（例如以太网、互联网）来管理设备。带内管理的明显限制是这种管理容易受到被管理设备受攻击或损害的影响。带内管理使得网络中的网管数据和业务数据在相同的链路中传输，当管理数据（包括SNMP，Netflow，Radius，计费等）较多时，将会影响到整个网络的性能；管理数据的流量较少，对整个网络的性能影响不明显，可采用带内管理。带内网管，网管系统必须通过网络来管理设备。如果无法通过网络访问被管理对象，带内网管系统就失效了，这时候带外网管系统就排上用场了。</p><p>尽管 IPMI 和 HTTP 没有直接的关系，但是<strong>有些服务器供应商提供了基于 HTTP 协议的 IPMI 远程管理界面</strong>，这意味着管理员可以使用 Web 浏览器来访问服务器的 IPMI 远程管理功能。在这种情况下，HTTP 协议被用于提供 IPMI 远程管理功能的 Web 接口，以便管理员可以通过 Web 界面来管理服务器硬件。</p><p>wireshark中可以抓到IPMI的数据</p><h2 id="确认是否支持IPMI"><a href="#确认是否支持IPMI" class="headerlink" title="确认是否支持IPMI"></a>确认是否支持IPMI</h2><p>大部分厂商的服务器如戴尔，NEC的都支持IPMI2.0，<strong>第一步就是应该先查看产品手册或者在BIOS查看服务器是否支持IPMI。</strong></p><p>大多数现代的Linux操作系统都支持IPMI技术。mac不支持IPMI协议。</p><p>Linux机器执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dmidecode -t 38<br></code></pre></td></tr></table></figure><p>如果命令返回IPMI版本和其他相关信息，则说明系统具有IPMI硬件，即支持IPMI技术。</p><blockquote><p>这里我的Linux机器（Red Hat版本）上执行了这个命令返回了如下结果。</p><p><img src="/../images/image-20230320151138038.png" alt="image-20230320151138038"></p></blockquote><p>下面的操作基于我的机器</p><p>安装ipmitool和OpenIPMI工具包，这两个都是支持IPMI管理的必备工具包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install ipmitool OpenIPMI<br></code></pre></td></tr></table></figure><p>加载IPMI驱动程序：使用以下命令加载IPMI驱动程序：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo modprobe ipmi_devintf</span><br></code></pre></td></tr></table></figure><p>启动IPMI服务：使用以下命令启动IPMI服务：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo systemctl <span class="hljs-literal">start</span> ipmi.service<br></code></pre></td></tr></table></figure><p>设置IPMI用户：使用以下命令设置IPMI用户：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo ipmitool <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> <span class="hljs-number">1</span> <span class="hljs-keyword">admin</span><br></code></pre></td></tr></table></figure><p>执行这个报错了。。。。。。。。。。。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Could not open device at <span class="hljs-regexp">/dev/i</span>pmi0 or <span class="hljs-regexp">/dev/i</span>pmi<span class="hljs-regexp">/0 or /</span>dev<span class="hljs-regexp">/ipmidev/</span><span class="hljs-number">0</span>: No such <span class="hljs-keyword">file</span> or directory<br></code></pre></td></tr></table></figure><p>之前启动IPMI服务时，需要内核加载命令，命令报错了</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo modprobe ipmi_si</span><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">modprobe: ERROR: could <span class="hljs-keyword">not</span> <span class="hljs-keyword">insert</span> <span class="hljs-string">&#x27;ipmi_si&#x27;</span>: <span class="hljs-keyword">No</span> such device<br></code></pre></td></tr></table></figure><blockquote><p>如果出现 “no such device” 错误消息，则表示系统中没有找到名为 ipmi_si 的内核模块。这可能是因为系统中没有安装这个模块，或者是因为这个模块并不适用于当前系统的内核版本。</p><p>如果您希望使用 ipmi_si 模块，可以尝试检查当前系统是否安装了这个模块，或者尝试在系统中安装这个模块。您还可以尝试检查内核版本，看看这个模块是否与当前内核版本兼容。</p><p><a href="https://juejin.cn/s/modprobe%20ipmi_si%20no%20such%20device">参考</a></p></blockquote><p>ipmi_si 仅适用于真实硬件，不可以在虚拟机上。 你可以使用类似 virt-manager 的东西来查看 VM 控制台</p><blockquote><p>如何判断机器是物理机还是虚拟机</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemd-detect-virt</span><br></code></pre></td></tr></table></figure><p>如果输出none表示为物理机，否则为虚拟机</p><p>我的机器上执行的结果是，因为我的机器是虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemd-detect-virt<br>kvm<br></code></pre></td></tr></table></figure></blockquote><h2 id="IPMI管理工具"><a href="#IPMI管理工具" class="headerlink" title="IPMI管理工具"></a>IPMI管理工具</h2><p>这里使用的IPMI管理工具为ipmitool，在mac上的安装方法为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install ipmitool<br></code></pre></td></tr></table></figure><p>确定IPMI的地址：查看BIOS设置或IPMI配置实用程序</p><p>服务器需要本身支持IPMI，还需要额外安装ipmi驱动和工具，</p><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">ipmitool -H (BMC管理的IP地址) -U (BMC的登录用户名) -P (BMC的登录用户密码)  COMMAND<br><br>command有以下项：<br>* raw：发送一个原始的IPMI请求，并且打印回复信息。<br>* Lan：配置网络（lan）信道(channel)<br>* chassis ：查看底盘的状态和设置电源<br>* event：向BMC发送一个已经定义的事件（event），可用于测试配置的SNMP是否成功<br>* mc：查看MC（Management Contollor）状态和各种允许的项<br>* sdr：打印传感器仓库中的所有监控项和从传感器读取到的值。<br>* Sensor：打印详细的传感器信息。<br>* Fru：打印内建的Field Replaceable Unit (FRU)信息<br>* Sel：打印 System Event Log (SEL)<br>* Pef：设置 Platform Event Filtering (PEF)，事件过滤平台用于在监控系统发现有event时候，用PEF中的策略进行事件过滤，然后看是否需要报警。<br>* Sol/isol：用于配置通过串口的Lan进行监控<br>* User：设置BMC中用户的信息 。<br>* Channel：设置Management Controller信道。<br><br>也可以加上 -I 指定使用哪个interface<br>通常，如果你想通过网络连接到IPMI，可以使用“lan”接口（例如：-I lan）。如果你使用串口连接到IPMI，可以使用“serial-over-lan”接口（例如：-I lanplus）。<br></code></pre></td></tr></table></figure><p>在<code>ipmitool</code>中，<code>lan</code>和<code>lanplus</code>是指通过IPMI LAN接口与远程服务器进行通信时使用的两种不同的协议</p><ol><li><code>lan</code>协议是IPMI v1.5的标准协议，<code>lanplus</code>协议是IPMI v2.0的标准协议。</li><li><code>lan</code>协议只支持IPv4地址，而<code>lanplus</code>协议同时支持IPv4和IPv6地址。</li><li><code>lan</code>协议需要配置RMCP或RMCP+的网络参数，而<code>lanplus</code>协议可以自动发现目标设备。</li><li><code>lanplus</code>协议支持更高级别的加密和认证机制，例如Kerberos和TLS。</li><li><code>lanplus</code>协议支持更多的IPMI命令，包括Firmware Firewall和Serial Over LAN（SOL）。</li></ol><p>总的来说，如果目标设备支持IPMI v2.0及以上版本，建议使用<code>lanplus</code>协议，否则使用<code>lan</code>协议。</p><p>大多数现代服务器都支持IPMI 2.0规范，并支持使用IPMI LAN接口进行远程管理。对于不同的服务器厂商和型号，支持的IPMI LAN接口版本可能会有所不同。但是，<strong>一般来说，现代服务器都至少支持IPMI LAN和LANplus两种接口之一，</strong>以提供远程管理功能。是服务器厂商会在其硬件上实现IPMI功能，提供相应的接口和工具。</p><p>关于加密：</p><p>IPMI 2.0定义了 Cipher Suite，用于协商加密方式，用来支持通过 SSL&#x2F;TLS 进行加密通信。</p><p>IPMI 1.5 中未定义 Cipher Suite，但仍可以使用 SSL&#x2F;TLS 进行加密通信。SSL&#x2F;TLS 协议还可以对通信双方进行身份认证，防止中间人攻击等安全问题。</p><p><strong>如果启用了IPMI的加密功能，使用ipmitool需要注意以下几点：</strong></p><ol><li><strong>IPMI LAN 密码必须提供，可以使用 <code>-E</code> 参数指定。</strong></li><li>要使用支持 IPMI 加密的 LANPLUS 接口。可以使用 <code>-I lanplus</code> 参数指定。</li><li>如果启用了双向认证，还需要提供本地私钥和远程服务器证书。可以使用 <code>-E</code> 和 <code>-K</code> 参数指定。</li></ol><p><strong>如果没有启用IPMI的加密功能</strong>，则可以使用IPMI的标准LAN接口，使用<code>-I lan</code>参数指定即可，无<strong>需提供密码和证书等加密相关信息。</strong></p><hr><p>dev是设备(device)的英文缩写。&#x2F;dev这个目录对所有的用户都十分重要。因为在这个目录中包含了所有Linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序，这一点和**<a href="http://www.ltesting.net/html/75/category-catid-375.html">windows</a>**,dos操作系统不一样。它实际上是一个访问这些外部设备的端口。</p><p><strong>关于IPMI的端口</strong></p><p>默认情况下，IPMI协议使用以下端口：</p><ul><li>IPMI over LAN: 端口号是623（UDP&#x2F;TCP）</li><li>Serial-over-LAN: 端口号是6666（TCP）</li></ul><p>请注意，一些厂商可能使用不同的端口号，因此在连接到IPMI主机之前，请务必检查文档或联系厂商获取准确的端口号信息。</p><hr><p>ESXi是什么</p><p>ESXi是VMware公司开发的一种虚拟化操作系统，它是VMware vSphere虚拟化平台的核心组件之一。它的主要功能是允许在一台物理服务器上同时运行多个虚拟机，从而实现资源的共享和优化，提高服务器资源的利用率。ESXi是一种精简版的操作系统，其核心组件包括VMkernel、管理代理和设备驱动程序等，专门为虚拟化而设计。</p><p>ESX是什么意思</p><p>ESX是VMware公司推出的一种虚拟化操作系统，是VMware vSphere虚拟化平台的早期版本。它和ESXi一样，是一种精简版的操作系统，专门为虚拟化而设计，可以在标准x86服务器上安装，实现资源的共享和优化，提高服务器资源的利用率。</p><p><a href="https://blog.csdn.net/qq_34160841/article/details/121728364">参考</a></p><p>IPMI核心是一个使用专用芯片&#x2F;控制器(一般称为服务器处理器或基板管理控制器(Baseboard Management Controller，<strong>BMC</strong>))，该控制器不依赖于服务器的处理器、BIOS或操作系统来工作，<strong>而是有常电供电并独立运行的，具有一个单独的子系统，在该系统中有ipmi的守护进程来处理主机或者远程管理的命令。</strong>一般BMC通常是一个贴片或者外挂在服务器主板上的独立的板卡，目前，部分服务器主板也提供对IPMI支持的。只要有BMC与IPMI固件其便可开始工作。</p><p><img src="/../images/image-20230329104945232.png" alt="image-20230329104945232"></p><p>而在命令传输的安全性方面，用户也无需担心，IPMI增强的认证(基于安全哈希算法1和基于密钥哈希消息认证)和加密(高级加密标准和Arcfour)功能有助于实现安全的远程操作。</p><p>ipmi协议只有三个版本：ipmi1.0、ipmi1.5、ipmi2.0。</p><p><strong>IPMI只是一个通信协议，它的实现依赖于单独的硬件平台，即基板管理控制器（BMC）。</strong></p><p>ipmi有一个web管理页面，web页面的用户名和密码和使用impitool访问的用户名和密码是一样的吗？</p><p>IPMI的Web管理页面和使用IPMITool访问的用户名和密码不一定相同，因为它们是两个不同的认证方式。通常来说，IPMI的Web管理页面会使用服务器厂商提供的默认用户名和密码进行认证，而使用IPMITool访问则需要在命令行中指定用户名和密码。不过具体的情况可能会因厂商而异，需要查看服务器厂商的文档或者手册来确定。</p><p>参考</p><p><a href="https://blog.csdn.net/pytanght/article/details/19756253">https://blog.csdn.net/pytanght/article/details/19756253</a></p><p><a href="https://www.jianshu.com/p/f0366f577e95">https://www.jianshu.com/p/f0366f577e95</a></p><p><a href="https://www.cnblogs.com/machangwei-8/p/10350824.html">https://www.cnblogs.com/machangwei-8/p/10350824.html</a></p><p><a href="https://blog.csdn.net/adsjlnmj66029/article/details/101567983">https://blog.csdn.net/adsjlnmj66029/article/details/101567983</a></p><p> <a href="https://github.com/bougou/go-ipmi">https://github.com/bougou/go-ipmi</a></p><p><a href="https://www.servethehome.com/download-supermicro-ipmiview-latest-version/">https://www.servethehome.com/download-supermicro-ipmiview-latest-version/</a></p><p><a href="https://www.cnblogs.com/bakari/archive/2012/08/05/2623780.html">https://www.cnblogs.com/bakari/archive/2012/08/05/2623780.html</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iperf3使用</title>
    <link href="/2023/04/10/iperf3%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/04/10/iperf3%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>iperf3是一个网络性能测试工具，可以用来模拟大流量的传输。可以用来TCP和UDP带宽的性能，可以用来测试最大UDP带宽。</p><p>iperf3对于每次测试，都会报告带宽，损耗和其他数据。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="测试发送端和接收端的最大带宽"><a href="#测试发送端和接收端的最大带宽" class="headerlink" title="测试发送端和接收端的最大带宽"></a>测试发送端和接收端的最大带宽</h3><p>有时候需要知晓发送端和接收端的最大带宽，使用iperf3可以测量出两端之间的最大带宽，因为iperf3会输出使用传输的速率，可以指定iperf3传输一个比较高的无法达到的速率，再查看iperf3显示的实际传输速率。</p><h3 id="模拟大流量"><a href="#模拟大流量" class="headerlink" title="模拟大流量"></a>模拟大流量</h3><p>有时候需要测试程序在大流量的场景下能否正确运行与处理 ，首先在程序所在机器运行iperf3接收服务，在其他机器想iperf3所在机器传输流量，传输流量时可以自定义传输速率，然后查看传输速率。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>macOS下安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install iperf3<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>启动服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">iperf3 -s<br></code></pre></td></tr></table></figure><p>启动客户端：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">iperf3</span> -c localhost -b <span class="hljs-number">500</span>M -t <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><blockquote><p><code>-c</code> 参数用于指定客户端要连接的服务器的地址，这里使用的是localhost，如果不是向本机打流则需要换成iperf3服务所在机器的IP</p><p><code>-b 500M</code> 表示设置客户端发送的带宽限制为500Mbps</p><p>-t 表示打流的持续时间为3秒</p><p>这个命令的意思是把最大速率500Mbps的流量传输到服务端，打流的最大速率为500Mbps。数据传输持续3秒，3秒后自动停止传输。</p></blockquote><p>因为这里的客户端和服务端都在同一台机器上，所以走的网卡是lo0。</p><p>运行结果查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">iperf3 -s                                              <br>-----------------------------------------------------------<br>Server listening on 5201 (test #1)<br>-----------------------------------------------------------<br>Accepted connection from ::1, port 64123<br>[  5] local ::1 port 5201 connected to ::1 port 64124<br>[ ID] Interval           Transfer     Bitrate<br>[  5]   0.00-1.00   sec  59.8 MBytes   500 Mbits/sec<br>[  5]   1.00-2.00   sec  59.8 MBytes   500 Mbits/sec<br>[  5]   2.00-3.00   sec  59.2 MBytes   499 Mbits/sec<br>[  5]   3.00-3.00   sec   128 KBytes  1.19 Gbits/sec<br>- - - - - - - - - - - - - - - - - - - - - - - - -<br>[ ID] Interval           Transfer     Bitrate<br>[  5]   0.00-3.00   sec   179 MBytes   500 Mbits/sec                  receiver<br>-----------------------------------------------------------<br>Server listening on 5201 (test #2)<br>-----------------------------------------------------------<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">iperf3 -c localhost -b 500M -t 3          <br>Connecting to host localhost, port 5201<br>[  7] local ::1 port 64124 connected to ::1 port 5201<br>[ ID] Interval           Transfer     Bitrate<br>[  7]   0.00-1.00   sec  59.6 MBytes   500 Mbits/sec<br>[  7]   1.00-2.00   sec  59.6 MBytes   500 Mbits/sec<br>[  7]   2.00-3.00   sec  59.6 MBytes   500 Mbits/sec<br>- - - - - - - - - - - - - - - - - - - - - - - - -<br>[ ID] Interval           Transfer     Bitrate<br>[  7]   0.00-3.00   sec   179 MBytes   500 Mbits/sec                  sender<br>[  7]   0.00-3.00   sec   179 MBytes   500 Mbits/sec                  receiver<br><br>iperf Done.<br></code></pre></td></tr></table></figure><p>可以看到打流持续了3秒，客户端的Bitrate列输出了3行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ ID] Interval           Transfer     Bitrate<br>[  7]   0.00-1.00   sec  59.6 MBytes   500 Mbits/sec<br>[  7]   1.00-2.00   sec  59.6 MBytes   500 Mbits/sec<br>[  7]   2.00-3.00   sec  59.6 MBytes   500 Mbits/sec<br></code></pre></td></tr></table></figure><p>下面是对数据结果的一些解析：</p><p>Bitrate（比特率）是500 Mbits&#x2F;sec 即500Mbps，这表示当前网络是千兆网络。</p><blockquote><p>iperf3默认发送的是TCP包，如果想发送UDP包，可以在客户端命令添加<code>-u</code>参数，则会发送UDP包。同一个网络，发送TCP和UDP的最大带宽可能是不同的。</p></blockquote><p>除了上述功能外，还有一个重要功能，就是<strong>对于发送UDP的包，可以指定发送的数据包的payload的大小</strong>，可以通过<code>-l</code>参数实现，<code>-l</code>的值的单位为字节。比如如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">iperf3 -c localhost -l 100 -u<br></code></pre></td></tr></table></figure><p>其含义是指定发送的数据包的payload大小是100，运行iperf3的同时抓包，抓到的内容是：</p><p><img src="/../images/image-20240424105616301.png" alt="image-20240424105616301"></p><p>可以看到传输的payload是100个字节，如绿色方框内所示。实际传输的整个数据包的大小是大于100个字节的，是100个字节加上各层的Header的长度，这里的总的数据包大小是152个字节。</p><h2 id="不同速率的网络接口"><a href="#不同速率的网络接口" class="headerlink" title="不同速率的网络接口"></a>不同速率的网络接口</h2><p>iperf3运行的传输速率受到网络接口速率的影响，网络接口有不同的等级，比如10G的网络接口和1G的网络接口，那么二者有什么区别呢？</p><p><strong>传输速率</strong>：10G 网络接口的传输速率为 10 千兆比特每秒（Gbps），而 1G 网络接口的传输速率为 1 千兆比特每秒（Gbps）。因此，10G 网络接口的传输速率比 1G 网络接口快 10 倍。</p><p><strong>带宽</strong>：10G 网络接口具有更大的带宽，能够传输更多的数据。这使得它更适合于大型数据中心、高性能计算和要求高带宽的应用场景。</p><p><strong>成本</strong>：由于硬件和技术上的差异，10G 网络接口通常比 1G 网络接口更昂贵。这包括网卡、交换机和光纤等设备的成本。</p><p><strong>距离</strong>：10G 网络接口通常可以支持更远的传输距离，例如，使用单模光纤可以达到数十公里的传输距离，而 1G 网络接口则通常在数百米范围内。</p><p><strong>功耗</strong>：10G 网络接口通常消耗更多的功耗，因为它需要更多的处理能力来处理更高的传输速率和带宽。这可能会增加服务器和网络设备的能耗。</p><p>总的来说，10G 网络接口适用于需要更高带宽和更快传输速率的场景，而 1G 网络接口则更适用于一般的办公环境和普通数据中心应用。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>clickhous分布式操作与错误复盘</title>
    <link href="/2023/03/17/clickhouse%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97/"/>
    <url>/2023/03/17/clickhouse%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我所实验的环境是一个集群，集群中，一共有N台机器，每台机器上有2个表，分别是分布式表和本地表。</p><p>分布式表和本地表的建表语句分别为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table1<br>(<br>    `id` UInt64,<br>    `device` Nested(<br>        type String,<br>        info String <br>     ),<br>    `create_time` DateTime<br>)<br>ENGINE <span class="hljs-operator">=</span> Distributed(<span class="hljs-string">&#x27;clusterxx&#x27;</span>, <span class="hljs-string">&#x27;flora&#x27;</span>, <span class="hljs-string">&#x27;table1_replica&#x27;</span>, rand())<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table1_replica<br>(<br>    `id` UInt64,<br>    `device` Nested(<br>        type String,<br>        info String <br>     ),<br>    `create_time` DateTime<br>)<br>ENGINE <span class="hljs-operator">=</span> ReplicatedMergeTree(<span class="hljs-string">&#x27;/clickhouse/tables/&#123;layer&#125;-&#123;shard&#125;/database1/table1_replica&#x27;</span>, <span class="hljs-string">&#x27;&#123;replica&#125;&#x27;</span>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMM(create_time)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> create_time<br>TTL create_time <span class="hljs-operator">+</span> toIntervalDay(<span class="hljs-number">10</span>)<br>SETTINGS index_granularity <span class="hljs-operator">=</span> <span class="hljs-number">8192</span><br></code></pre></td></tr></table></figure><h2 id="alter"><a href="#alter" class="headerlink" title="alter"></a>alter</h2><p>在实际操作中，对于alter操作，可以指定ON CLUSTER，比如新增字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table1 <span class="hljs-keyword">ON</span> CLUSTER clusterxx <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> cc<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table1_replica <span class="hljs-keyword">ON</span> CLUSTER clusterxx <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> cc<br></code></pre></td></tr></table></figure><p>那么实际执行的时候，会将任务分发到各个节点（会分发到N个节点，对应了N台机器），这样每台机器上的表（table1或者table1_replica）都新增了字段。不过默认情况下分布式任务不是同步的，实际上只是将任务分发到各个节点，至于各个节点什么时候执行看各自节点的情况，不会等所有节点都执行完毕才返回数据。</p><h2 id="insert操作"><a href="#insert操作" class="headerlink" title="insert操作"></a>insert操作</h2><p>insert写入的过程中分为同步写和异步写，通过<code>insert_sync</code>来控制，该参数的值是由<code>insert_distributed_sync</code>配置的，默认为<code>false</code>。</p><blockquote><p>一批数据写入分布式表会被拆分成多份小批量的数据写入<code>Clickhouse</code>集群，大量的小<code>part</code>文件会增加集群后台<code>merge</code>线程池的压力，当<code>merge</code>的处理能力小于写入能力时，<code>Clickhouse</code>会禁止写入，所以写入<code>Clickhouse</code>期望是<strong>频率低批次大</strong>。</p></blockquote><p>insert操作也可以直接写到分布式表上，分布式表会将insert任务分派到各个节点，各个节点默认会异步写。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shells">insert into table1 values(1, [&#x27;A&#x27;,&#x27;A&#x27;],[&#x27;1.1.1.1&#x27;, &#x27;2.2.2.2&#x27;], 2021-08-19 14:21:30&#x27;);  <br>insert into table1 values(2, [&#x27;A&#x27;,&#x27;A&#x27;],[&#x27;1.1.1.1&#x27;, &#x27;2.2.2.2&#x27;], 2021-08-20 14:21:30&#x27;);  <br></code></pre></td></tr></table></figure><p>那么clickhouse会将操作分布到几个节点后返回，然后在几个节点上分别写。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>下面是一个我碰到的insert操作过程中和分布式任务相关的问题：</p><p>操作步骤</p><ol><li><p>往分布式表插入一些数据，是比较多条的数据。类似于<code>insert into table1 values(1, [&#39;A&#39;,&#39;A&#39;],[&#39;1.1.1.1&#39;, &#39;2.2.2.2&#39;], 2021-08-19 14:21:30&#39;);  </code>1000条这样。</p></li><li><p>删除table1的device字段，先在每个节点上都执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table1 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> device.type;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table1 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> device.info;<br></code></pre></td></tr></table></figure><p>然后在每个节点执行：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table1 drop_replica <span class="hljs-keyword">column</span> device.type;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table1 drop_replica <span class="hljs-keyword">column</span> device.info;<br></code></pre></td></tr></table></figure></li><li><p>新增device字段，不过是String类型的：</p><p>先在每个节点上都执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table1 <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> device String;<br></code></pre></td></tr></table></figure><p>然后在每个节点上执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table1_replica <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> device String;<br></code></pre></td></tr></table></figure></li><li><p>发现问题：</p><p>查询system.errors表，发现其中两台机器不断报错</p><p>执行<code>select * from system.errors order by  last_error_time desc limit 10</code></p><p>返回结果为：</p><p><img src="/../images/image-20230317203948210.png" alt="image-20230317203948210"></p><p>完整信息为</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">No</span> such <span class="hljs-keyword">column</span> device.<span class="hljs-keyword">type</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">table</span> database1.table1_replica (xxxxxxxxxx-bf3c<span class="hljs-number">-414</span>d<span class="hljs-number">-82</span>f5-e184fe0304c6)<br></code></pre></td></tr></table></figure><p>更为关键的是，每个两三分钟再次查询，这个NO_SUCH_COLUMN_IN_TABLE错误一直在更新，表现为value值增加，last_error_time更新为离当前时间更近的时间，而last_error还是No such column device.type的内容，这说明错误一直在发生。</p></li><li><p>查询 system.query_log确认 ，发现最近几分钟报错的都是上面的错误，大概每隔30秒会触发一次，看起来是insert失败后clickhouse一直在重试。</p><blockquote><p>ps:图片上的时间仅作为参考，因为是事后记录，资料部分丢失，所以时间不会严格按照时间发生的记录，理解意思即可。</p></blockquote></li></ol><p><img src="/../images/image-20230317204706151.png" alt="image-20230317204706151"></p><p>发现这些报错的initial_query_id都是相同的，initial_query_id表示这个操作是由哪个分布式任务触发的，且每一条报错的query_id和initial_query_id不一样，这表明这台机器的insert操作是其他机器派发下来的。</p><p><img src="/../images/image-20230317205139122.png" alt="image-20230317205139122"></p><ol start="6"><li><p>确定这个initial_query_id是哪台机器上的，我在每台机器上都执行了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>() <span class="hljs-keyword">from</span> system.query_log <span class="hljs-keyword">where</span> query_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> xx 就是上图标出来的initial_query_id<br></code></pre></td></tr></table></figure><p>发现只有第一台返回了非0数据，表明这个操作是第一台派发下来的。但是第一台查询<code>select * from system.query_log where query_id = &#39;xxx&#39;</code>的两条数据的结果的Type分别为QueryStart和QueryFinish<img src="/../images/image-20230317205450785.png" alt="image-20230317205450785"></p><ol start="7"><li><p>原因确认：这是因为第一步的insert是非同步式分布任务，集群随机派发，把这个任务派发到了第一台节点上，第一台的分布式表table1把任务派发到N台节点的本地表table1_replica执行，因为分布式任务是非同步的，此时第一台立刻返回结果，剩下的几台准备执行被派发到的insert任务。结果此时我在每台挨个执行了删除字段的操作，出了出问题的那台，其他几台都是insert执行完毕了才delete字段，只有出问题的那台delete后执行了insert操作，此时必然会报错。然后clickhouse就不断重试。</p></li><li><p>尝试解决：相关的资料clickhouse讲得很少，我估计是有个不断重试insert的线程不断在重试。于是重启了出问题的那台机器，但是发现重启后这个问题依然存在 。那么这个重试程序应该是被持久化到硬盘上的。</p></li><li><p>因为定位不断重试insert的线程很麻烦，且考虑不精通clickhouse，手动停止重试任务会影响clickhouse的数据等，于是决定使用最简单的回滚方法，删除新增的string类型的 device字段，然后新增nested类型的device字段，此时重试任务重试成功了，报错 停止了。然后再删除Nested类型的device，把string类型的device加回来 。</p><p>注意：首先先要执行<code>delete column device on cluster clusterxx drop column device</code> 操作所有机器的分布式表，然后上面所说的先删除device，添加Nested类型的device等一系列只要在出问题的机器的本地表执行就可以了。最后再在所有机器的分布式表添加string类型 的 device字段。</p></li></ol></li></ol><blockquote><p>ps：上面的问题导致的另一个后果是 表堆积</p><p>下面2种情况会造成分布式表堆积：</p><p>当DistributedSchedulePool的处理能力小于写入能力时，就会造成分布式表堆积，这时用户是查不到堆积的数据的，当堆积到一定的程度，集群是比较难恢复的，需要清除分布式表堆积的数据，用户是会丢失数据的，出现这种问题的原因其中一个原因是用户在StreamSql任务中配置的并发太高间隔太短，写入太猛造成的。</p><p>用户在修改表结构的时候未停写，就可能会出现分布式表中还堆积着修改表结构之前的数据，当分发的时候，由于远端的表结构已经修改，就会分发失败，<code>Clickhouse</code>就会无限次重试，导致后续的数据也无法处理，从而堆积。</p></blockquote><p>参考</p><p><a href="https://blog.csdn.net/qq_43115606/article/details/125612593">Clickhouse 分布式表的写入原理</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SNMP协议简介</title>
    <link href="/2023/03/17/SNMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/03/17/SNMP%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h2><p>简单网络管理协议SNMP（Simple Network Management Protocol）是广泛应用于TCP&#x2F;IP网络的网络管理标准协议。是应用层协议。</p><p>目前有SNMPv1，SNMPv2c，SNMPv3三个版本，在SNMP报文中，对应的整数分别为0，1，2.</p><p>SNMP系统由以下四个部分组成：</p><p><img src="/../images/image-20230313145118798.png" alt="image-20230313145118798"></p><center>SNMP管理模型</center><h3 id="MIB"><a href="#MIB" class="headerlink" title="MIB"></a>MIB</h3><p>MIB定义了被管理对象的很多属性：包括对象的名称，对象的状态，对象的访问权限，对象的数据类型。<br>MIB是管理信息数据库，采用和DNS相似的树形结构。根在最上面，根没有名字。<br>如下图所示的是管理信息库的一部分，它又称为<strong>对象命名树</strong>。每个<strong>OID（object identifier，对象标识符）</strong>对应于树中的一个管理对象，如system的OID为1.3.6.1.2.1.1，interfaces的OID为1.3.6.1.2.1.2。</p><p><img src="/../images/image-20230313145826810.png" alt="image-20230313145826810"></p><center>OID数结构</center><p>当用户在配置Agent时，可以通过<strong>MIB视图</strong>来限制NMS能够访问的MIB对象。MIB视图实际上是MIB的子集合。</p><h2 id="抓包详解"><a href="#抓包详解" class="headerlink" title="抓包详解"></a>抓包详解</h2><p>###SNMPv1和SNMPv2c</p><p>两个版本的报文结构都是</p><p><img src="/../images/image-20230313153111504.png" alt="image-20230313153111504"></p><p>我用wireshark抓到的v1的数据如下，可以和上面的报文结构对应着看看：</p><p><img src="/../images/image-20230313154835336.png" alt="image-20230313154835336"></p><p>团体名：有可读和可写两种情况。</p><p>PDU：包含PDU类型、请求标识符、变量绑定列表等信息</p><p>v1和v2c都有的基本操作类型如下（中间的是PDU类型）：</p><p><img src="/../images/image-20230313153603033.png" alt="image-20230313153603033"></p><blockquote><p>Trap信息是Agent主动向NMS发出的信息，告知管理进程设备端出现的情况。 </p><p>Trap不需要NMS回复（与v2c的InformRequest相比）。Trap不属于NMS对被管理设备的基本操作，它是被管理设备的自发行为。当被管理设备达到告警的触发条件时，会通过Agent向NMS发送Trap消息，告知设备侧出现的异常情况，便于网络管理人员及时处理。</p></blockquote><p>SNMPv2c版本新增支持了<strong>GetBulk</strong>和<strong>Inform</strong>操作，如下：</p><p><img src="/../images/image-20230313154015787.png" alt="image-20230313154015787"></p><p>GetBulk操作实现了NMS对被管理设备的信息群查询。<strong>基于GetNext实现，相当于连续执行多次GetNext操作。</strong>在NMS上可以设置被管理设备在一次GetBulk报文交互时，执行GetNext操作的次数。</p><p>InformRequest也是被管理设备向NMS主动发送告警。与Trap告警不同的是，被管理设备发送Inform告警后，需要NMS回复InformResponse来进行确认。使用Inform告警会占用较多的系统资源。</p><h3 id="SNMPv3"><a href="#SNMPv3" class="headerlink" title="SNMPv3"></a>SNMPv3</h3><p><strong>主要改进就是安全性方面</strong></p><p>数据认证：防止SNMP消息在传输过程中被篡改，或SNMP消息来自伪造的SNMP实体</p><p>数据加密：防止SNMP消息在传输过程中被窃听</p><p>报文结构如下：<br><img src="/../images/image-20230313154437832.png" alt="image-20230313154437832"></p><p>和前两个版本相比，去掉了团体名，新增了报头数据到Context Name这四个字段。</p><p>SNMPv3的PDU和v2c的好像一样，包括GetRequest PDU、GetNextRequest PDU、SetRequest PDU、Response PDU、Trap PDU、GetBulkRequest PDU和InformRequest PDU。</p><p><img src="/../images/image-20230313160230831.png" alt="image-20230313160230831"></p><center>以Get为例的SNMPv3的工作过程</center><p>通过抓包，可以看到一次SNMP请求的4个步骤，和上图的一致，实际的传输的数据是被加密的：</p><blockquote><p>Ps:用gosnmp SDK发送SNMP请求得到的是解密后的结果，因为SDK已经对返回的被加密了的数据进行了解密。</p></blockquote><p><img src="/../images/image-20230317172734642.png" alt="image-20230317172734642"></p><p><img src="/../images/image-20230317172754912.png" alt="image-20230317172754912"></p><p><img src="/../images/image-20230317172814269.png" alt="image-20230317172814269"></p><p><img src="/../images/image-20230317172832099.png" alt="image-20230317172832099"></p><h2 id="客户端工具"><a href="#客户端工具" class="headerlink" title="客户端工具"></a>客户端工具</h2><h3 id="net-snmp"><a href="#net-snmp" class="headerlink" title="net-snmp"></a>net-snmp</h3><blockquote><p>mac上或者linux机器上可能默认可能无法访问本机的SNMP服务，需要进行如下配置：</p><p>修改<code> /etc/snmp/snmpd.conf</code>文件为以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">com2sec mynetwork &lt;NETWORK/CIDR&gt; public<br>rocommunity public default .1<br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">com2sec mynetwork 192.168.1.6/24 public<br>rocommunity public default .1<br></code></pre></td></tr></table></figure><p>再重启SNMP服务：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo launchctl unload <span class="hljs-regexp">/System/</span>Library<span class="hljs-regexp">/LaunchDaemons/</span>org.net-snmp.snmpd.plist <span class="hljs-comment"># 关闭SNMP服务</span><br>sudo launchctl load -w <span class="hljs-regexp">/System/</span>Library<span class="hljs-regexp">/LaunchDaemons/</span>org.net-snmp.snmpd.plist <span class="hljs-comment"># 重启SNMP服务</span><br></code></pre></td></tr></table></figure></blockquote><p>mac安装SNMP客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install net-snmp<br></code></pre></td></tr></table></figure><p>可以使用snmpget命令来获取指定OID的值。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">snmpget -v2c -c public localhost 1.3.6.1.2.1.11.4.0<br></code></pre></td></tr></table></figure><p>-v2c表示使用SNMP版本2c协议，-c表示指定SNMP社区字符串，这里是获取本机上的OID为1.3.6.1.2.1.11.4.0的信息。</p><p>或者请求多个OID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">snmpget -v1 -c public localhost 1.3.6.1.2.1.11.4.0 1.3.6.1.2.1.11.15.0<br></code></pre></td></tr></table></figure><h3 id="MIB-Browser"><a href="#MIB-Browser" class="headerlink" title="MIB Browser"></a>MIB Browser</h3><p>这是一个GUI客户端。界面如下：</p><p><img src="/../images/image-20230317164823325.png" alt="image-20230317164823325"></p><p>我在Mac上下载了MIB Browser，可以通过这个查看本地MIB的信息。在查看的过程中，通过wireshark抓本地网络接口如lo0的包，可以抓到对应的SNMP的包。</p><h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><p>使用<a href="github.com/gosnmp/gosnmp">gosnmp</a>，可以发送SNMP数据，获取一些OID信息。实际使用中我用这个比较多，因为参数很明确。</p><p>参考官方文档，基本用法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><br>g <span class="hljs-string">&quot;github.com/gosnmp/gosnmp&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">v1</span><span class="hljs-params">()</span></span> &#123;<br>g.Default.Target = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>err := g.Default.Connect()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Connect() err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> g.Default.Conn.Close()<br>oids := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1.3.6.1.2.1.11.4.0&quot;</span>, <span class="hljs-string">&quot;1.3.6.1.2.1.11.15.0&quot;</span>&#125;<br>result, err2 := g.Default.Get(oids)<br><span class="hljs-keyword">if</span> err2 != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Get() err: %v&quot;</span>, err2)<br>&#125;<br><span class="hljs-keyword">for</span> i, variable := <span class="hljs-keyword">range</span> result.Variables &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d: oid: %s &quot;</span>, i, variable.Name)<br><span class="hljs-keyword">switch</span> variable.Type &#123;<br><span class="hljs-keyword">case</span> g.OctetString:<br>fmt.Printf(<span class="hljs-string">&quot;string: %s\n&quot;</span>, <span class="hljs-type">string</span>(variable.Value.([]<span class="hljs-type">byte</span>)))<br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;number: %d\n&quot;</span>, g.ToBigInt(variable.Value))<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">v3</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// build our own GoSNMP struct, rather than using g.Default</span><br>params := &amp;g.GoSNMP&#123;<br>Target:        <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>Port:          <span class="hljs-number">161</span>,<br>Version:       g.Version3,<br>SecurityModel: g.UserSecurityModel,<br>MsgFlags:      g.AuthPriv,<br>Timeout:       time.Duration(<span class="hljs-number">10</span>) * time.Second,<br>SecurityParameters: &amp;g.UsmSecurityParameters&#123;UserName: <span class="hljs-string">&quot;v3test&quot;</span>,<br>AuthenticationProtocol:   g.SHA,<br>AuthenticationPassphrase: <span class="hljs-string">&quot;v3testtest&quot;</span>,<br>PrivacyProtocol:          g.AES,<br>PrivacyPassphrase:        <span class="hljs-string">&quot;v3testtest&quot;</span>,<br>&#125;,<br>&#125;<br>err := params.Connect()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Connect() err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> params.Conn.Close()<br><br>oids := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1.3.6.1.2.1.11.4.0&quot;</span>, <span class="hljs-string">&quot;1.3.6.1.2.1.11.15.0&quot;</span>&#125;<br>result, err2 := params.Get(oids) <span class="hljs-comment">// Get() accepts up to g.MAX_OIDS</span><br><span class="hljs-keyword">if</span> err2 != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Get() err: %v&quot;</span>, err2)<br>&#125;<br><br><span class="hljs-keyword">for</span> i, variable := <span class="hljs-keyword">range</span> result.Variables &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d: oid: %s &quot;</span>, i, variable.Name)<br><br><span class="hljs-comment">// the Value of each variable returned by Get() implements</span><br><span class="hljs-comment">// interface&#123;&#125;. You could do a type switch...</span><br><span class="hljs-keyword">switch</span> variable.Type &#123;<br><span class="hljs-keyword">case</span> g.OctetString:<br>fmt.Printf(<span class="hljs-string">&quot;string: %s\n&quot;</span>, <span class="hljs-type">string</span>(variable.Value.([]<span class="hljs-type">byte</span>)))<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// ... or often you&#x27;re just interested in numeric values.</span><br><span class="hljs-comment">// ToBigInt() will return the Value as a BigInt, for plugging</span><br><span class="hljs-comment">// into your calculations.</span><br>fmt.Printf(<span class="hljs-string">&quot;number: %d\n&quot;</span>, g.ToBigInt(variable.Value))<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用gopacket对包内容解析"><a href="#使用gopacket对包内容解析" class="headerlink" title="使用gopacket对包内容解析"></a>使用gopacket对包内容解析</h2><p>因为网上这类项目真的很少，我只找到了一个很久之前的，然后根据这个项目进行了改编，具体的内容可以看 </p><p><a href="https://github.com/nrbackback/code-in-blog/tree/main/snmp">code-in-blog&#x2F;snmp</a></p><p>这个项目可以解析出大部分的SNMP数据，解析出来的所有 Pdu.PduType 包括<br>GetRequest<br>GetResponse<br>Report<br>SNMPTrapV2<br>GetBulkRequest</p><p>trap v1 无法解析<br>snmp v3 被解析成了GetRequest</p><ul><li>参考资料</li></ul><p><a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100138435/5ee8dfb">华为云的SNMP配置</a></p><p><a href="https://www.heelpbook.net/2016/enable-icmp-protocol-on-macos/">Enable ICMP protocol on MacOS</a></p><p><a href="https://blog.csdn.net/jijian_jinan/article/details/43054879">SNMPv3的基本概念</a></p><p><a href="https://support.auvik.com/hc/en-us/articles/360000536163-How-to-enable-SNMP-on-Mac-OSX">How to enable SNMP on Mac OSX</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DNS报文详解</title>
    <link href="/2023/03/11/DNS%E6%8A%A5%E6%96%87%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/03/11/DNS%E6%8A%A5%E6%96%87%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p><img src="/../images/image-20230303134146545.png" alt="image-20230303134146545"></p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><blockquote><p>PS：开启混杂模式的网卡可以捕获所有流过该网卡的帧，不开启则只能捕获广播帧以及发给该网卡的帧。一般都要开混杂模式。</p></blockquote><h3 id="DNS报文之后的数据"><a href="#DNS报文之后的数据" class="headerlink" title="DNS报文之后的数据"></a>DNS报文之后的数据</h3><p>我抓包的时候发现了这样的包：</p><p><img src="/../images/image-20230302163519309.png" alt="image-20230302163519309"></p><p>数据包在DNS之后还有2段数据，查阅资料后得知，这2段数据分别是以太网的Trailer和以太网帧校验序列（FCS）。</p><h3 id="抓包概览"><a href="#抓包概览" class="headerlink" title="抓包概览"></a>抓包概览</h3><p>Authority RRs  权威名称服务器计数：权威名称服务器的数目。<br>Additional RRs  附加资源记录数：额外的记录数目（权威名称服务器对应 IP 地址的数目）。</p><p><img src="/../images/image-20230303102132074.png" alt="image-20230303102132074"></p><h2 id="报文字段分析"><a href="#报文字段分析" class="headerlink" title="报文字段分析"></a>报文字段分析</h2><h3 id="Answers"><a href="#Answers" class="headerlink" title="Answers"></a>Answers</h3><blockquote><p>Answers 部分的响应数据是根据查询所请求的 DNS 记录类型和查询类型（递归查询或迭代查询）而返回的。如果没有找到匹配的记录，则响应的 Answers 部分将为空。</p></blockquote><p>Answers在有的Response里可能为空</p><h4 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h4><p>Answers里可能的Type的值我抓包时看到了以下几种（通过gopacket分析的）：</p><p>NS、A、CNAME、PTR、AAAA、SOA、Unknown</p><p><img src="/../images/image-20230306150548748.png" alt="image-20230306150548748"></p><p><img src="/../images/image-20230306162407622.png" alt="image-20230306162407622"></p><p>SOA对应的请求为</p><p><img src="/../images/image-20230306162511347.png" alt="image-20230306162511347"></p><p>还有抓包抓到了一些gopacket里没有定义的类型，比如RRSIG，其对应的值为46</p><blockquote><p>DNS RRSIG (Resource Record Signature) 是一种 DNS 记录类型，用于提供 DNSSEC (DNS Security Extensions) 安全扩展的数字签名。RRSIG 记录对指定的 DNS 记录进行数字签名，并在签名中包含有关签名算法、签名有效期和其他信息。</p></blockquote><p><img src="/../images/image-20230306154851361.png" alt="image-20230306154851361"></p><p>还有DS类型的，其对应的值为43</p><p><img src="/../images/image-20230306155602060.png" alt="image-20230306155602060"></p><p>此外还有值为48的DNSKEY类型</p><p><img src="/../images/image-20230306162741839.png" alt="image-20230306162741839"></p><p>其对应的请求为：</p><p><img src="/../images/image-20230306162810925.png" alt="image-20230306162810925"></p><p><strong>我总结了下</strong>：每台DNS服务器可以理解为一个表，表存储了一行行信息，每行信息可能是 域名- DNS类型- IP，或者是域名- DNS类型-域名。</p><p>这个类型在DNS请求和响应中都会出现：</p><p>常见的有以下这些，还有部分未统计：</p><ul><li>NS记录：NS记录是一个指针记录，它指向一组该域名授权的域名服务器的名称。当客户端要查询该域名下的某个主机的IP地址时，需要先向授权域名服务器查询，因此NS记录在DNS解析过程中非常重要。</li><li>A记录：A记录是最基本的DNS记录类型，是Address Record的缩写，它将域名解析为IPv4地址。例如，将<a href="http://www.example.com解析为192.0.2.1./">www.example.com解析为192.0.2.1。</a></li><li>AAAA记录：和A记录类似，但是它将域名解析为IPv6地址</li><li>CNAME：将一个别名解析为实际的主机名。</li><li>MX记录（Mail Exchange Record）：指定邮件交换服务器的地址。</li><li>PTR记录（Pointer Record）：反向解析记录，将IP地址解析为域名。</li><li>SOA记录（Start of Authority Record）：区域文件的授权记录，指定了负责该域的DNS服务器。</li><li>SRV记录（Service Record）：指定提供特定服务的服务器的地址。</li><li>TXT记录（Text Record）：包含任意文本信息的记录。</li></ul><p>在DNS报文中，NS记录和A记录都可以作为Answer Section的一部分返回给客户端。</p><p><strong>CNAME类型</strong></p><p>应当读作：</p><p>CNAME记录用于将一个<a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D">域名</a>（同名）映射到另一个域名（真实名称），<a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1%E5%99%A8">域名解析服务器</a>遇到CNAME记录会以映射到的目标重新开始查询。</p><p>比如某个CNAME记录为</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">bar<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span>.        CNAME  foo<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span>.<br></code></pre></td></tr></table></figure><p>这里<em>bar.example.com</em>的“CNAME”是<em>foo.example.com</em>，因为CNAME的意思是真实名称，而右侧才是真实名称，才是CNAME。</p><p>应当读作：</p><p><em>bar.example.com</em>的真实名称是<em>foo.example.com</em>。请求访问<em>bar.example.com</em>的客户端会得到<em>foo.example.com</em>返回的结果。</p><p>这是一个方便理解的例子：若要同时运行<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">文件传输</a>服务和<a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1">Web服务</a>，则可以把<em>ftp.example.com</em>和<em><a href="http://www.example.com/">www.example.com</a></em>都指向DNS记录<em>example.com</em>，而后者则有一个指向IP地址的A记录。如此一来，若服务器IP地址改变，则只需修改<em>example.com</em>的A记录即可。那么当发起ftp.example.com的DNS解析时，DNS响应中会包含CNAME记录，请求方会重启查询，查询example.com的对应记录</p><p>查询名：一般为要查询的域名，有时也会是 IP 地址，用于反向查询。</p><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>有以下这些可能值</p><p>IN（Internet类）</p><p>CS（CSNET类）、CH（CHAOS类）、HS（Hesiod）很少使用</p><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><p>包含了以下这些字段：</p><p><img src="/../images/image-20230303134338135.png" alt="image-20230303134338135"></p><p><strong>QR</strong>：查询请求时，值为 0；响应时，值为 1。</p><p><strong>Opcode</strong>：操作码。其中，0 表示标准查询；1 表示反向查询；2 表示服务器状态请求。</p><p><strong>AA</strong>（Authoritative）：授权应答，该字段在响应报文中有效。值为 1 时，表示名称服务器是权威服务器；值为 0 时，表示不是<strong>权威服务器</strong>。我执行了一个<code>dig +trace baidu.com</code>请求，只有最后一个响应中的这个AA为1，如下。其他的都是0，为1表示这是一个权威服务器，这个服务器返回了baidu.com的IP。</p><blockquote><p>什么叫权威服务器？？？</p><p>在DNS中，权威服务器（Authoritative Server）是指能够对某个域名或主机名提供官方答案的DNS服务器。权威服务器通常是负责管理域名解析信息的DNS服务器，<strong>它们保存有该域名下所有主机的IP地址等DNS记录，可以直接回答该域名下主机的DNS查询请求。</strong>而非权威服务器则是指没有权威性的DNS服务器，它们通常只是缓存了其他服务器的DNS查询结果，以提高DNS查询效率。</p></blockquote><p><img src="/../images/image-20230303102208256.png" alt="image-20230303102208256"></p><p>这个响应返回的baidu.com的IP在Answers里，展开如下：</p><p><img src="/../images/image-20230303102548260.png" alt="image-20230303102548260"></p><p>这里解析出来的2个IP和我执行 nslookup解析出来的结果是一样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">nslookup baidu.com                <br>Server:10.50.4.107<br>Address:10.50.4.107#53<br><br>Non-authoritative answer:<br>Name:baidu.com<br>Address: 39.156.66.10<br>Name:baidu.com<br>Address: 110.242.68.66<br></code></pre></td></tr></table></figure><p><strong>TC</strong></p><p><strong>RD</strong>（Recursion Desired）：是否期望递归，值为1和为0分别表示递归查询和迭代查询。</p><p>值为1的情况</p><p><img src="/../images/image-20230303135525275.png" alt="image-20230303135525275"></p><p>对应的响应为</p><p><img src="/../images/image-20230303135651498.png" alt="image-20230303135651498"></p><p>值为0的情况</p><p>这里执行<code>dig +trace baidu.com</code>，4个请求的RD都是0，请求方192.168.1.5进行了迭代查询。</p><p><img src="/../images/image-20230303135925682.png" alt="image-20230303135925682"></p><blockquote><p><strong>递归查询和迭代查询</strong></p><p><strong>递归查询是默认方式</strong>，迭代查询是以DNS客户端，也就是客户机器为中心查询。其实DNS客户端和本地名称服务器是递归，而本地名称服务器和其他名称服务器之间是迭代。</p><p>递归查询：当客户端向本地DNS服务器（可以通过系统设置查看或者 scutil –dns命令查看，比如我电脑的是8.8.8.8）发出查询请求时，如果本地DNS服务器发现没有命中自己的缓存，就会代替客户端查询，直到从权威服务器处得到了正确的解析结果，然后本地DNS服务器就告诉DNS客户端查询的结果。整个过程客户端只需要发出一次请求，也就是向本地DNS服务器发出的那次请求。本地DNS就像一个中介一样。</p><p>迭代查询：<strong>客户端</strong>向<strong>本地DNS服务器</strong>发出查询请求时，如果本地DNS服务器发现没有命中自己的缓存，本地DNS就会向<strong>根域名服务器</strong>发出请求，根域名服务器把请求中的DNS域名中的顶级域名对应的<strong>顶级域名服务器</strong>信息返回，本地DNS服务器会将返回的结果返回给客户端。客户端再向本地DNS服务器发出向顶级域名服务器的查询请求，顶级名称服务器在收到DNS查询请求后，也是先查询自己的缓存，如果有所请求的DNS域名的记录项，则相接把对应的记录项返回给本地域名服务器，然后再由本地域名服务器返回给DNS客户端，否则向本地名称服务器返回所请求的DNS域名中的二级域名所对应的二级名称服务器地址。以此类推，直到访问到<strong>权威域名服务器</strong>，权威域名服务器返回请求的域名对应的IP地址。整个过程本地DNS服务器就只是一个单纯的传输和转发作用，不会像递归查询一样主动查询最终结果，真正的驱动还是客户端。</p></blockquote><p><strong>RA</strong>：只有响应报文可能设置该字段。值为1时表示服务器支持递归查询。</p><p><strong>Z</strong>：保留字段，值必须为0</p><p><strong>rcode</strong>：响应的差错状态，0表示没有错误，非0表示出错了</p><h3 id="附加资源Additional-records"><a href="#附加资源Additional-records" class="headerlink" title="附加资源Additional records"></a>附加资源Additional records</h3><p>DNS报文中的附加信息Additional records字段包含了一些额外的记录，这些记录与查询结果相关但不是直接回答查询问题的。它们提供了关于所查询域名的更多信息，例如权威域名服务器的IP地址、域名服务器的版本信息、以及与所查询域名相关的其他域名。</p><p>在DNS查询中，附加记录可以帮助客户端更快地获取所需的信息，而不必进行额外的DNS查询。例如，当客户端需要连接某个Web服务器时，Web服务器通常会在DNS响应中返回其IP地址以及网站运行的操作系统版本等信息，客户端可以将这些信息缓存下来，以便更快地建立连接。</p><p>参考资料</p><p><a href="http://c.biancheng.net/view/6457.html">资料1</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dig trace命令及抓包</title>
    <link href="/2023/03/11/dig%20trace%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%8A%93%E5%8C%85/"/>
    <url>/2023/03/11/dig%20trace%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%8A%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="dig-trace命令"><a href="#dig-trace命令" class="headerlink" title="dig trace命令"></a>dig trace命令</h2><blockquote><p>dig（域信息搜索器）是一个在Linux和Unix系统中常用的网络工具，用于查询DNS域名解析相关信息，比如查询域名对应的IP地址、查询DNS服务器的相关信息、查询DNS记录等等。</p><p>它可以通过指定参数和选项进行各种类型的DNS查询，包括常用的A记录、MX记录、CNAME记录等等，还可以设置查询的DNS服务器，以及查询的超时时间等等。同时，dig也可以用于诊断DNS相关的问题，比如检查DNS服务器是否正常工作、解析是否正确等等。</p></blockquote><p>执行nslookup xxx.com时，确认本地DNS服务器是否已经缓存了查询结果。如果本地DNS服务器已经缓存了查询结果，就不会再向上级DNS服务器发出请求了。</p><p>为了避免缓存影响，下面加上+trace参数。</p><blockquote><p>使用 <code>dig +trace</code> 命令会追踪域名解析过程并输出每个步骤的详细信息。<strong>它不会使用DNS缓存，它会从根域名服务器开始，</strong>递归地查询每个级别的 DNS 服务器，直到找到目标域名的 IP 地址或遇到错误。该命令对于诊断 DNS 解析问题非常有用，可以帮助确定哪个服务器出现了问题或哪个环节出现了延迟。</p></blockquote><p>这是执行 <code> dig +trace qwewq.com</code>抓到的包，首先访问了192.5.5.241</p><blockquote><p>IP地址 192.5.5.241 是由美国国家科学基金会（NSF）资助的互联网核心枢纽机构 VeriSign 公司拥有的一个地址，<strong>是一个根域名服务器</strong>，主要用于管理和运营域名系统（DNS）服务器，其中包括 .com 和 .net 域名的顶级域名服务器。</p></blockquote><p><img src="/../images/image-20230302180706556.png" alt="image-20230302180706556"></p><p>如果不特意指定+trace只是正常访问，抓到的包结果如下，首先访问了8.8.8.8</p><p><img src="/../images/image-20230302181137764.png" alt="image-20230302181137764"></p><p>这是因为我在电脑的系统设置中配置的DNS地址是8.8.8.8</p><p><img src="/../images/image-20230302181257209.png" alt="image-20230302181257209"></p><blockquote><p>8.8.8.8是Google提供的公共DNS服务器的IP地址。<strong>它不是根域名服务器，而是一个提供DNS解析服务的服务器。</strong></p></blockquote><h2 id="重传的情况"><a href="#重传的情况" class="headerlink" title="重传的情况"></a>重传的情况</h2><p>下面的4499和4501都是响应重传包，都是在响应包4497这个响应包发送后重传的</p><blockquote><p>为什么wireshark中有的DNS响应显示retransmitted response</p><p>Wireshark中显示”retransmitted response”通常表示DNS响应是一个重传的包，即发送方发送了一个DNS响应包，但由于某些原因，接收方没有接收到该包，或者收到的包存在错误或丢失，导致发送方需要重新发送该包。Wireshark通过检查包的序列号和确认号来判断响应是否被重传。当一个响应被重传时，它通常会有一个新的时间戳和序列号，而重传标志位也会被设置。</p></blockquote><p>但是wireshark显示的响应时间还是用第一个返回的响应包计算的，而不是后两个响应包计算的</p><p><img src="/../images/image-20230303100707363.png" alt="image-20230303100707363"></p><h2 id="抓包详解"><a href="#抓包详解" class="headerlink" title="抓包详解"></a>抓包详解</h2><p>我执行了<code>dig +trace baidu.com</code>，抓到的包为：</p><p><img src="/../images/image-20230303170324725.png" alt="image-20230303170324725"></p><p>我想知道第一个访问的IP 202.12.27.33 是什么，发现这是一台根域名服务器，目前世界上有13台根域名服务器，这是其中的一台。13台根域名服务器的域名分别是A.ROOT-SERVERS.NET到M.ROOT-SERVERS.NET</p><p>可见第一次是随机找了一个根域名服务器访问的。</p><p><img src="/../images/image-20230303170408258.png" alt="image-20230303170408258"></p><p>看看这台根域名服务器返回了什么</p><p><img src="/../images/image-20230303171542534.png" alt="image-20230303171542534"></p><p>可以看到返回了13个.net结尾的域名，分别是a.gtld-servers.net到m.gtld-servers.net，这负责管理 “.com” 顶级域名的13台根域名服务器（也叫一级域名服务器）之一，这里的type是NS，表示请求a.gtld-servers.net这些域名服务器可以获得baidu.com的相关信息。在Additional records还说明了这些顶级域名服务器的IP地址是什么，注意这里的Type是A，表示这些域名对应的IP分别是什么，如m.gtld-servers.net对应的IP是192.55.83.30.</p><p>接着随机选了一台g.gtld-servers.net，如数据包202所示，发出请求后获取的响应如下：</p><p><img src="/../images/image-20230303171717446.png" alt="image-20230303171717446"></p><p>ns2.baidu.com这些是存储baidu.com的二级域名服务器，type为NS表示可以访问ns2.baidu.com来获取baidu.com的IP。</p><p>接着选择了一台ns3.baidu.com，其IP为36.152.45.193，如数据包208所示，发出请求后获取的响应如下：</p><p><img src="/../images/image-20230303172646394.png" alt="image-20230303172646394"></p><p>可以看到本次终于获取到了Answers。</p><p>我发现这几次DNS请求中都有指定OPT，于是了解了一下这个OPT的含义：DNS查询中的OPT是指“Options”（选项）字段，它允许在DNS查询或响应中添加额外的信息，如DNSSEC（DNS安全扩展）相关的信息，以及用于DNS性能、优化和其他目的的标志。</p><p><img src="/../images/image-20230303175025840.png" alt="image-20230303175025840"></p><p>Ps:发现有时在上面的访问根服务器（上面的是 202.12.27.33）的第一步前，会给我本地配置的NDS服务器8.8.8.8发送请求：</p><p><img src="/../images/image-20230306111608645.png" alt="image-20230306111608645"></p><p>可以看出，这是请求根域名服务器的信息的，返回为：</p><blockquote><p>补充：返回的flag为0x80a0，因为截图截不到这个信息，所以在这里单独补充</p></blockquote><p><img src="/../images/image-20230306111849411.png" alt="image-20230306111849411"></p><p>还有Additional Records：</p><p><img src="/../images/image-20230306111917003.png" alt="image-20230306111917003"></p><p>注意这里的Additional Records并没有像我预期的那样给出上面的13个根域名服务器的IP地址，因为其实13个根域名服务器的IP地址通常是固定的，所以没有必要再次返回了。这是DNS协议的规定，也是为了减少网络流量和提高DNS解析效率。这里在13个根域名服务器选择一个，然后DNS客户端本地应该存储了13个根域名服务器对应的IP地址，再找到选择出来的那个根域名服务器对应的IP地址（比如上面的是202.12.27.33），再给这个IP地址发送请求。</p><h2 id="DNS截断例子"><a href="#DNS截断例子" class="headerlink" title="DNS截断例子"></a>DNS截断例子</h2><p><img src="/../images/image-20230307153037170.png" alt="image-20230307153037170"></p><p>这里抓到了一个DNS截断包，使用gopacket获取layers得到的结果是</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">Ethernet</span> IPv4 UDP DecodeFailure<br></code></pre></td></tr></table></figure><p>具体pcap文件在images&#x2F;dns-only-5.pcap</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse的TTL</title>
    <link href="/2023/03/10/clickhouse%E7%9A%84TTL/"/>
    <url>/2023/03/10/clickhouse%E7%9A%84TTL/</url>
    
    <content type="html"><![CDATA[<p>redis有TTL功能，可以实现指定时间段后自动删除key，clickhouse也有类似的功能，可以指定在某个时间段后自动删除数据，但是删除不是即使的，clickhouse会间隔某个周期（一般是4小时）查看数据库是否有要删除的数据，再对要删除的数据进行删除操作。具体可以参考<a href="https://clickhouse.com/docs/en/guides/developer/ttl/">官方文档</a></p><p>新增或者删除TTL都可以用modify语句</p><p><code>ALTER TABLE example1 MODIFY TTL timestamp + INTERVAL 1 HOUR;</code></p><p>这个表里每一行数据的过期时间为timestamp加上一个小时，过了这个时间一般这行数据就会被自动删除。如果没有自动删除，可以执行<code>OPTIMIZE TABLE example1 FINAL</code>手动触发clickhouse的删除数据操作，验证结果。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse的嵌套类型与Tuple</title>
    <link href="/2023/03/10/clickhouse%E7%9A%84%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B%E4%B8%8ETuple/"/>
    <url>/2023/03/10/clickhouse%E7%9A%84%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B%E4%B8%8ETuple/</url>
    
    <content type="html"><![CDATA[<p>下面是关于Nested类型和Tuple类型的SQL用法的例子，两者插入数据的方法不一样，存储方式也不也一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test(<br>    uid Int8 ,<br>    dns_flag_desc String,<br>    answer Nested(<br>        type String,<br>        info String <br>     )<br>) engine <span class="hljs-operator">=</span> MergeTree <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> uid ;<br><br>## 插入数据<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;NO ERROR&#x27;</span>,[<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>],[<span class="hljs-string">&#x27;1.1.1.1&#x27;</span>, <span class="hljs-string">&#x27;2.2.2.2&#x27;</span>]);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;NO ERROR&#x27;</span>,[<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>],[<span class="hljs-string">&#x27;1.1.1.1&#x27;</span>, <span class="hljs-string">&#x27;2.2.2.2&#x27;</span>,<span class="hljs-string">&#x27;3.3.3.3&#x27;</span>]);<br>## 查询数据<br><span class="hljs-keyword">select</span> answer.type <span class="hljs-keyword">from</span> test<br></code></pre></td></tr></table></figure><p>Nested存储到数据库后是存储为了多列，比如这里存储的时候存储为了answer.type和answer.info这两列，删除的时候也要分别删除这两列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> my_table<br>(<br>    `id` UInt32,<br>    `nested_array` <span class="hljs-keyword">Array</span>(Tuple(Int32, String))<br>)<br>ENGINE <span class="hljs-operator">=</span> Memory<br><br>## 插入数据<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> my_table (id, nested_array)<br>                <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, [(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;foo&#x27;</span>), (<span class="hljs-number">20</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)]<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> my_table (id, nested_array)<br>                <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, [(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;foo&#x27;</span>), (<span class="hljs-number">20</span>, <span class="hljs-string">&#x27;bar&#x27;</span>), (<span class="hljs-number">30</span>, <span class="hljs-string">&#x27;bar1&#x27;</span>)]  <br>## 查询数据<br><span class="hljs-keyword">select</span> nested_array<span class="hljs-number">.1</span> <span class="hljs-keyword">from</span> test # 这里查询的出来的就是第一个列，也就是Int32那一列的数据<br></code></pre></td></tr></table></figure><p>如果是Array(Tuple(Int32, String))类型的，存储到数据库实际上只存储为了一列，只是这一列是个数组，数组的每个元素是个json对象。</p><p>Nested比Tuple更为灵活，可以指定字段名</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DNS抓包请求详解</title>
    <link href="/2023/02/24/DNS%E8%AF%B7%E6%B1%82%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/02/24/DNS%E8%AF%B7%E6%B1%82%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>DNS的传输层使用的是<strong>UDP协议或者TCP协议。</strong></p><p>DNS在某些情况下会使用TCP协议。DNS通常使用UDP协议（用户数据报协议）来进行域名查询，因为UDP速度快、效率高，而且查询数据包通常较小，适合在UDP上进行。但是，当DNS查询数据包的大小超过了UDP数据包的最大限制时（通常是512字节），DNS会使用TCP协议来进行查询。此外，某些DNS服务器也会将DNS查询请求强制转换为TCP协议，以增加安全性和可靠性。</p></blockquote><h2 id="Transaction-ID"><a href="#Transaction-ID" class="headerlink" title="Transaction ID"></a>Transaction ID</h2><p>在DNS协议中，每个DNS请求报文都包含一个16位的Transaction ID字段，用于标识该DNS请求和对应的DNS响应。<strong>Transaction ID由客户端随机生成，并且在DNS响应报文中原样返回，以便客户端能够将响应与请求进行匹配</strong>。Transaction ID的生成没有特定的规律，通常是使用伪随机数生成算法来生成。</p><h2 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h2><h3 id="终端输出"><a href="#终端输出" class="headerlink" title="终端输出"></a>终端输出</h3><p>执行<code>dig +trace www.baidu.com</code>返回的结果为：</p><details><summary>展开/收起</summary>dig +trace www.baidu.com<br><br>; <<>> DiG 9.10.6 <<>> +trace www.baidu.com<br>;; global options: +cmd<br>.            255946    IN    NS    f.root-servers.net.<br>.            255946    IN    NS    g.root-servers.net.<br>.            255946    IN    NS    h.root-servers.net.<br>.            255946    IN    NS    b.root-servers.net.<br>.            255946    IN    NS    j.root-servers.net.<br>.            255946    IN    NS    l.root-servers.net.<br>.            255946    IN    NS    k.root-servers.net.<br>.            255946    IN    NS    e.root-servers.net.<br>.            255946    IN    NS    a.root-servers.net.<br>.            255946    IN    NS    c.root-servers.net.<br>.            255946    IN    NS    m.root-servers.net.<br>.            255946    IN    NS    i.root-servers.net.<br>.            255946    IN    NS    d.root-servers.net.<br>.            255946    IN    RRSIG    NS 8 0 518400 20230305170000 20230220160000 951 . xU5kKOHDoGfyQVeW8Huv74NJxyAaKyuDUxli5P0K08z+vvLlA3N87OVL bhwoihWpKg+Of2S2nI6jx80n+S2Ty74PSOijnu9sW7vvTD30Wg1Vgtda rrOc2gf9UmDkT+mLda/IiX7DtAla76k9t+owykaxyPHfdkLH1cfZmGj6 0KPRJDf9gnopBomQIBa4/m3UqwJlefYA0Wr01Bs+BaCKHPQEnrBSsBYJ jBbFOkadtuXtVym5Bapg8TYJQQfJxlutIuuEyC1BDSqw33poKUcKzXg3 v7VIeHSq+wKaOyDt7m9wrCxOhj3uZurNO+b88xmtV4pX+HxRGs+Yx2QY kCGskQ==<br>;; Received 1097 bytes from 10.50.4.107#53(10.50.4.107) in 12 ms<br><br>com.            172800    IN    NS    m.gtld-servers.net.<br>com.            172800    IN    NS    k.gtld-servers.net.<br>com.            172800    IN    NS    c.gtld-servers.net.<br>com.            172800    IN    NS    i.gtld-servers.net.<br>com.            172800    IN    NS    h.gtld-servers.net.<br>com.            172800    IN    NS    b.gtld-servers.net.<br>com.            172800    IN    NS    e.gtld-servers.net.<br>com.            172800    IN    NS    f.gtld-servers.net.<br>com.            172800    IN    NS    d.gtld-servers.net.<br>com.            172800    IN    NS    g.gtld-servers.net.<br>com.            172800    IN    NS    j.gtld-servers.net.<br>com.            172800    IN    NS    a.gtld-servers.net.<br>com.            172800    IN    NS    l.gtld-servers.net.<br>com.            86400    IN    DS    30909 8 2 E2D3C916F6DEEAC73294E8268FB5885044A833FC5459588F4A9184CF C41A5766<br>com.            86400    IN    RRSIG    DS 8 1 86400 20230308170000 20230223160000 951 . eiW76HnA6iWoL7HVQQlR5GwBc3QagvdHZJEH3d13ze+ukMwieArh0Ec2 pd10S4nFcW8S37ajG+u2tzLV09ZlXhpRNbXX84qD17QvWeh7IeT+vCFl lk4I/+55UcVdI3LfhHmJPF4cjMLQsIbKCB1Ryf+sWQsVKYE9XeoUR5Mp rV7W8I1UWn9e1yMs5C+ujrd/UFPb/Uw4QS6RZ7Q0K39XOUqFRqUuSnFQ Klg5fExB7I6/dARBqK4lnOzMssrF97HmGtGNUkpb3CgBMIwSDGriM+Uf vQVRzFyhGNHD3KigUV18uYw8Yqq48By+BKJmzMd4IQGiy0e0WNavs2vd 9Ph/+A==<br>;; Received 1176 bytes from 192.5.5.241#53(f.root-servers.net) in 27 ms<br><br>baidu.com.        172800    IN    NS    ns2.baidu.com.<br>baidu.com.        172800    IN    NS    ns3.baidu.com.<br>baidu.com.        172800    IN    NS    ns4.baidu.com.<br>baidu.com.        172800    IN    NS    ns1.baidu.com.<br>baidu.com.        172800    IN    NS    ns7.baidu.com.<br>CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN NSEC3 1 1 0 - CK0Q2D6NI4I7EQH8NA30NS61O48UL8G5  NS SOA RRSIG DNSKEY NSEC3PARAM<br>CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN RRSIG NSEC3 8 2 86400 20230227052255 20230220041255 36739 com. YJw2xFEhDVUfIlym8yUrXw8rVYLxS+e/EkIJVmOkBANnfCmNPVATcGuM /DIrUz8PTWTezM5z6f2tM+KnzzXYMNL1ScDIgO/jaJUrs4aOz1EOPwD4 hk5rJ/pRSY9C87vRoxqdryDIHxg3TwwEfQglqQ9hk+P1qvU7qY5nd0yc tO+IV8Vqd0sRiteg/P1h6Bpp79v/kZNjntRTdnWLI2oW2g==<br>HPVV07LPQ3T8RQS9HETLBJF268LK3OQ2.com. 86400 IN NSEC3 1 1 0 - HPVV8SARM2LDLRBTVC5EP1CUB1EF7LOP  NS DS RRSIG<br>HPVV07LPQ3T8RQS9HETLBJF268LK3OQ2.com. 86400 IN RRSIG NSEC3 8 2 86400 20230301070223 20230222055223 36739 com. Z4AFqvwBHDHfzuf37WTbdeC0SMt15I4qG2MUUhjv14m7MJ6AwDCHVXAZ tqi9T+xttD0xo0wgL5pRciXRTdNPUFBq/mu5Fimp/tfosWjcshv50+4c TNdbMXubTw4yr7DLDlQGO5a2cSa6T/HrDnpdDjZJcfVYLGZP1k5nFXhc +TKjOrScSPq9lG3hH7n7SGxCTrp7j+tCjzrHjH8egq2tKg==<br>;; Received 849 bytes from 192.5.6.30#53(a.gtld-servers.net) in 187 ms<br><br>www.baidu.com.        1200    IN    CNAME    www.a.shifen.com.<br>;; Received 72 bytes from 110.242.68.134#53(ns1.baidu.com) in 29 ms<br></details><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>下面是对应的执行抓到的包：</p><p>首先访问192.5.5.241，192.5.5.241返回了<strong>13台通用顶级域名.com服务器</strong>的信息，如下：</p><p><a href="https://imgse.com/i/pSz3zXn"><img src="https://s1.ax1x.com/2023/02/24/pSz3zXn.png" alt="pSz3zXn.png"></a></p><p>ID 81中Additional records比Authoritative nameservers多了返回addr，他们的IP地址包括IPv4和IPv6，这俩可以通过type区分，type分别为A和AAAA。ID81对应的请求为ID80：<code>Standard query. 0x2935 A www.baidu.com OPT</code></p><p>然后选择了其中的一台，这里选择了a.gtld-servers.net，地址为192.5.6.30，192.5.6.30返回的内容如下：</p><p><a href="https://imgse.com/i/pSzGdM9"><img src="https://s1.ax1x.com/2023/02/24/pSzGdM9.png" alt="pSzGdM9.png"></a></p><p>然后选择了其中的一台，这里选择了ns1.baidu.com，地址为110.242.68.134，110.242.68.134返回的内容如下：</p><p><a href="https://imgse.com/i/pSzGxZq"><img src="https://s1.ax1x.com/2023/02/24/pSzGxZq.png" alt="pSzGxZq.png"></a></p><h2 id="DNS响应时间"><a href="#DNS响应时间" class="headerlink" title="DNS响应时间"></a>DNS响应时间</h2><h3 id="响应和请求相邻时"><a href="#响应和请求相邻时" class="headerlink" title="响应和请求相邻时"></a>响应和请求相邻时</h3><p>首先调整下wireshark的显示设置：</p><p><a href="https://imgse.com/i/pSzaS8f"><img src="https://s1.ax1x.com/2023/02/24/pSzaS8f.png" alt="pSzaS8f.png"></a></p><p>因为发现本次的dns查询的请求和响应都是相邻的，所以响应包里这个设置显示的时间就是响应时间。</p><p>wireshark抓到的包中可以看到响应时间（发出包和接收到这个包的时间差），wireshark抓到的包结果是这样的：</p><p><img src="https://s1.ax1x.com/2023/02/24/pSza6it.png" alt="pSza6it.png"></p><p>命令行返回的结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">dig +trace csdn.com +time=1 +noall +stats<br><br>; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; +trace csdn.com +time=1 +noall +stats<br>;; global options: +cmd<br>;; Query time: 51 msec<br>;; SERVER: 8.8.8.8#53(8.8.8.8)<br>;; WHEN: Fri Feb 24 15:11:09 CST 2023<br>;; MSG SIZE  rcvd: 525<br><br>;; Query time: 193 msec<br>;; SERVER: 198.41.0.4#53(198.41.0.4)<br>;; WHEN: Fri Feb 24 15:11:09 CST 2023<br>;; MSG SIZE  rcvd: 1168<br><br>;; Query time: 195 msec<br>;; SERVER: 192.54.112.30#53(192.54.112.30)<br>;; WHEN: Fri Feb 24 15:11:09 CST 2023<br>;; MSG SIZE  rcvd: 946<br><br>;; Query time: 12 msec<br>;; SERVER: 47.118.199.202#53(47.118.199.202)<br>;; WHEN: Fri Feb 24 15:11:09 CST 2023<br>;; MSG SIZE  rcvd: 53<br></code></pre></td></tr></table></figure><p>可以看到4个DNS请求的响应时间在wireshark都有对应的结果，包括SERVER字段和wireshark里的也是一致的。</p><h3 id="响应和请求分隔时"><a href="#响应和请求分隔时" class="headerlink" title="响应和请求分隔时"></a>响应和请求分隔时</h3><p>试着执行了下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">dig +trace csdn.com +time=1 +noall +stats &amp;<br>dig +trace zhihu.com +time=1 +noall +stats<br></code></pre></td></tr></table></figure><p>运行结果为：</p><details><summary>展开/收起</summary>; <<>> DiG 9.10.6 <<>> +trace zhihu.com +time=1 +noall +stats<br>;; global options: +cmd<br><br>; <<>> DiG 9.10.6 <<>> +trace csdn.com +time=1 +noall +stats<br>;; global options: +cmd<br>;; Query time: 45 msec<br>;; SERVER: 8.8.8.8#53(8.8.8.8)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 525<br><br>;; Query time: 46 msec<br>;; SERVER: 8.8.8.8#53(8.8.8.8)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 525<br><br>;; Query time: 29 msec<br>;; SERVER: 199.7.83.42#53(199.7.83.42)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 1168<br><br>;; Query time: 81 msec<br>;; SERVER: 202.12.27.33#53(202.12.27.33)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 1169<br><br>;; Query time: 212 msec<br>;; SERVER: 192.48.79.30#53(192.48.79.30)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 946<br><br>;; Query time: 5 msec<br>;; SERVER: 139.224.142.121#53(139.224.142.121)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 53<br><br>;; Query time: 211 msec<br>;; SERVER: 192.52.178.30#53(192.52.178.30)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 909<br><br>;; Query time: 8 msec<br>;; SERVER: 183.192.164.119#53(183.192.164.119)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 108<br></details><p>wireshark抓到的包为：</p><p><a href="https://imgse.com/i/pSzgIPg"><img src="https://s1.ax1x.com/2023/02/24/pSzgIPg.png" alt="pSzgIPg.png"></a></p><p>共16个包。</p><p>因为加了&amp;，两个<code>dig</code>命令是同一时刻执行的，而且每个DNS请求的响应不全是请求的下一个包。如图响应包和请求包之间就有2个包。我整理了一下：</p><table><thead><tr><th>请求包序号</th><th>响应包序号</th><th>响应时间</th><th>第几个dig命令产生的包</th><th>对应dig命令的输出</th></tr></thead><tbody><tr><td>23</td><td>25</td><td>0.045652</td><td>不确定，我好像看不出来。。</td><td>;; Query time: 45 msec<br>;; SERVER: 8.8.8.8#53(8.8.8.8)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 525</td></tr><tr><td>24</td><td>26</td><td>0.046427</td><td>不确定，我好像看不出来。。</td><td>;; Query time: 46 msec<br>;; SERVER: 8.8.8.8#53(8.8.8.8)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 525</td></tr><tr><td>27</td><td>34</td><td>0.08078</td><td>2</td><td>;; Query time: 29 msec<br>;; SERVER: 199.7.83.42#53(199.7.83.42)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 1168</td></tr><tr><td>28</td><td>29</td><td>0.028015</td><td>1</td><td>;; Query time: 81 msec<br>;; SERVER: 202.12.27.33#53(202.12.27.33)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 1169</td></tr><tr><td>32</td><td>48</td><td>0.212717</td><td>1</td><td>;; Query time: 212 msec<br>;; SERVER: 192.48.79.30#53(192.48.79.30)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 946</td></tr><tr><td>35</td><td>51</td><td>0.210875</td><td>2</td><td>;; Query time: 5 msec<br>;; SERVER: 139.224.142.121#53(139.224.142.121)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 53</td></tr><tr><td>49</td><td>50</td><td>0.004978</td><td>1</td><td>;; Query time: 211 msec<br>;; SERVER: 192.52.178.30#53(192.52.178.30)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 909</td></tr><tr><td>52</td><td>53</td><td>0.007501</td><td>2</td><td>;; Query time: 8 msec<br>;; SERVER: 183.192.164.119#53(183.192.164.119)<br>;; WHEN: Fri Feb 24 16:50:14 CST 2023<br>;; MSG SIZE  rcvd: 108</td></tr></tbody></table><p>根据之前所说，每次DNS请求的transaction id都是无序的，在本次抓包结果可以验证。</p><p>DNS解析这里是2个命令同时执行的，我理解的就是2个进程分别对应着2个命令的执行，这2个进程分别生成随机的Transaction ID，然后请求，DNS的响应中会有请求的Transaction ID，这2个进程只会处理自己生成的Transaction ID对应的响应，根据响应的结果判断出下一个请求该如何发送。这样发送几次请求后，得到对应的结果。2个进程也不会互相干扰，只会处理跟自己生成的Transaction ID相关的内容。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>golang实现二进制位</title>
    <link href="/2023/02/21/golang%E5%AE%9E%E7%8E%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
    <url>/2023/02/21/golang%E5%AE%9E%E7%8E%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Bit <span class="hljs-type">int16</span><br><br><span class="hljs-comment">// 设置第i位置为1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BitMask)</span></span> Set(i <span class="hljs-type">int</span>) &#123;<br>*b |= (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>))<br>&#125;<br><br><span class="hljs-comment">// 判断是否第i位是否为1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b BitMask)</span></span> IsSet(i <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> b&amp;(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>)) != <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// 设置第i位置为0，即取消设置第i位</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BitMask)</span></span> Unset(i <span class="hljs-type">int</span>) &#123;<br>*b &amp;^= (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>))<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang将某个整数存储到文件中与读取</title>
    <link href="/2023/02/21/golang%E5%B0%86%E6%9F%90%E4%B8%AA%E6%95%B4%E6%95%B0%E5%AD%98%E5%82%A8%E5%88%B0%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B8%8E%E8%AF%BB%E5%8F%96/"/>
    <url>/2023/02/21/golang%E5%B0%86%E6%9F%90%E4%B8%AA%E6%95%B4%E6%95%B0%E5%AD%98%E5%82%A8%E5%88%B0%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B8%8E%E8%AF%BB%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<p><strong>写入</strong></p><p>Go语言提供了内置的标准库，可以方便地将整数存储到文件中。您可以使用encoding&#x2F;binary包进行二进制编码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go">mport (<br><span class="hljs-string">&quot;encoding/binary&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 打开文件</span><br>file, err := os.Create(<span class="hljs-string">&quot;integer.bin&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br><span class="hljs-comment">// 写入整数</span><br>integer := <span class="hljs-type">int64</span>(<span class="hljs-number">123456789</span>)<br>err = binary.Write(file, binary.LittleEndian, &amp;integer)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在该代码中看到，使用binary.Write方法将整数写入文件。您可以指定存储字节序，例如binary.LittleEndian或binary.BigEndian。</p><p>此外，也可以使用其他三方库，如gopkg.in&#x2F;vmihailenco&#x2F;msgpack.v2或github.com&#x2F;tinylib&#x2F;msgp，以更方便地将整数进行编码并存储到文件中。</p><p><strong>读取</strong></p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/binary&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 打开文件</span><br>file, err := os.Open(<span class="hljs-string">&quot;integer.bin&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br><span class="hljs-comment">// 读取整数</span><br><span class="hljs-keyword">var</span> integer <span class="hljs-type">int64</span><br>err = binary.Read(file, binary.LittleEndian, &amp;integer)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>log.Printf(<span class="hljs-string">&quot;Read integer: %d&quot;</span>, integer)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用binary.Read方法从文件中读取整数，并将其存储在变量中。同样，可以指定读取字节序，以确保与写入时使用的字节序相同。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse cli使用</title>
    <link href="/2023/02/21/clickhouse%20cli%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/02/21/clickhouse%20cli%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>参考<a href="https://clickhouse.com/docs/zh/interfaces/cli/">官方文档</a></p><p>比如执行下面的语句，就相当于登录上了clickhouse服务器并执行了SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">clickhouse<span class="hljs-operator">-</span>client <span class="hljs-comment">--host=&quot;x&quot; --user=&quot;x&quot; --database=&quot;x&quot; --password=&quot;x&quot; --query=&quot;select count() from x where create_time &lt; date_add(DAY, -7, date_trunc(&#x27;day&#x27;, now()));&quot;;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse的where中使用不确定性函数</title>
    <link href="/2023/02/21/clickhouse%E7%9A%84where%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%87%BD%E6%95%B0/"/>
    <url>/2023/02/21/clickhouse%E7%9A%84where%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>要实现一个脚本，删除clickhouse七天前的数据</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>找到了date_trunc函数，参考了 <a href="https://clickhouse.com/docs/en/sql-reference/functions/date-time-functions/">https://clickhouse.com/docs/en/sql-reference/functions/date-time-functions/</a></p><p>官方用法，比如<code>SELECT now(), date_trunc(&#39;hour&#39;, now());</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">date_trunc(unit, <span class="hljs-keyword">value</span>[, timezone])<br></code></pre></td></tr></table></figure><p>Alias: <code>dateTrunc</code>.</p><p><strong>Arguments</strong></p><ul><li><code>unit</code> — The type of interval to truncate the result. <a href="https://clickhouse.com/docs/en/sql-reference/syntax#syntax-string-literal">String Literal</a>. Possible values:<ul><li><code>second</code></li><li><code>minute</code></li><li><code>hour</code></li><li><code>day</code></li><li><code>week</code></li><li><code>month</code></li><li><code>quarter</code></li><li><code>year</code></li></ul></li><li><code>value</code> — Date and time. <a href="https://clickhouse.com/docs/en/sql-reference/data-types/datetime">DateTime</a> or <a href="https://clickhouse.com/docs/en/sql-reference/data-types/datetime64">DateTime64</a>.</li><li><code>timezone</code> — <a href="https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings#server_configuration_parameters-timezone">Timezone name</a> for the returned value (optional). If not specified, the function uses the timezone of the <code>value</code> parameter. <a href="https://clickhouse.com/docs/en/sql-reference/data-types/string">String</a>.</li></ul><p>执行：</p><p><code>ALTER table t ON CLUSTER c DELETE WHERE create_time &lt; date_add(DAY, -7, date_trunc(&#39;day&#39;, now())))</code></p><p>报错了：ALTER UPDATE&#x2F;ALTER DELETE statements must use only deterministic functions.</p><p>报错原因：因为clickhouse在where中使用不确定性函数，<code>now()</code> 函数在 ClickHouse 中也是不确定性函数。”date_add” 和 “date_trunc” 不是确定性函数。where后面不可以放上不确定性函数。</p><h2 id="通过shell脚本实现"><a href="#通过shell脚本实现" class="headerlink" title="通过shell脚本实现"></a>通过shell脚本实现</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">该脚本的功能为：删除clickhouse里的七天前的数据</span><br><br>BEGIN=$(date +%s --date=&#x27;-7 day&#x27;)<br>HOST=x<br>DATABASE=x<br>USERNAME=x<br>PASSWORD=x<br>TABLE=x<br>CLUSTER=x<br><br>clickhouse-client \<br>--host=&quot;$HOST&quot; \<br>--user=&quot;$USERNAME&quot; \<br>--database=&quot;$DATABASE&quot; \<br>--password=&quot;$PASSWORD&quot; \<br>--query=&quot;ALTER table $TABLE ON CLUSTER $CLUSTER DELETE WHERE create_time &lt; FROM_UNIXTIME($BEGIN);&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go的delve调试工具</title>
    <link href="/2023/02/17/go%E7%9A%84delve%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <url>/2023/02/17/go%E7%9A%84delve%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>起因是我在阅读一段比较难懂的源码，写了个单元测试想查看程序的具体运行状况，但是源码很长通过打印很难明白到底是如何执行的。由此想到可以用go的调试，但是我很久没用了，有些不记得了。于是再重新整理下。</p><h2 id="delve的安装"><a href="#delve的安装" class="headerlink" title="delve的安装"></a>delve的安装</h2><p>使用到调试器是Delve。这是专门为了go语言开发的调试工具。</p><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get -u github.com/go-delve/delve/cmd/dlv<br></code></pre></td></tr></table></figure><p>确认版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dlv version<br></code></pre></td></tr></table></figure><p>使用</p><p>切换到待调试的go项目所在的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dlv debug<br></code></pre></td></tr></table></figure><p>执行help命令之后可以看到有很多提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs shell">dlv debug <br>Type &#x27;help&#x27; for list of commands.<br>(dlv) help<br>The following commands are available:<br><br>Running the program:<br>    call ------------------------ Resumes process, injecting a function call (EXPERIMENTAL!!!)<br>    continue (alias: c) --------- Run until breakpoint or program termination.<br>    next (alias: n) ------------- Step over to next source line.<br>    rebuild --------------------- Rebuild the target executable and restarts it. It does not work if the executable was not built by delve.<br>    restart (alias: r) ---------- Restart process.<br>    step (alias: s) ------------- Single step through program.<br>    step-instruction (alias: si)  Single step a single cpu instruction.<br>    stepout (alias: so) --------- Step out of the current function.<br><br>Manipulating breakpoints:<br>    break (alias: b) ------- Sets a breakpoint.<br>    breakpoints (alias: bp)  Print out info for active breakpoints.<br>    clear ------------------ Deletes breakpoint.<br>    clearall --------------- Deletes multiple breakpoints.<br>    condition (alias: cond)  Set breakpoint condition.<br>    on --------------------- Executes a command when a breakpoint is hit.<br>    toggle ----------------- Toggles on or off a breakpoint.<br>    trace (alias: t) ------- Set tracepoint.<br>    watch ------------------ Set watchpoint.<br><br>Viewing program variables and memory:<br>    args ----------------- Print function arguments.<br>    display -------------- Print value of an expression every time the program stops.<br>    examinemem (alias: x)  Examine raw memory at the given address.<br>    locals --------------- Print local variables.<br>    print (alias: p) ----- Evaluate an expression.<br>    regs ----------------- Print contents of CPU registers.<br>    set ------------------ Changes the value of a variable.<br>    vars ----------------- Print package variables.<br>    whatis --------------- Prints type of an expression.<br><br>Listing and switching between threads and goroutines:<br>    goroutine (alias: gr) -- Shows or changes current goroutine<br>    goroutines (alias: grs)  List program goroutines.<br>    thread (alias: tr) ----- Switch to the specified thread.<br>    threads ---------------- Print out info for every traced thread.<br><br>Viewing the call stack and selecting frames:<br>    deferred --------- Executes command in the context of a deferred call.<br>    down ------------- Move the current frame down.<br>    frame ------------ Set the current frame, or execute command on a different frame.<br>    stack (alias: bt)  Print stack trace.<br>    up --------------- Move the current frame up.<br><br>Other commands:<br>    config --------------------- Changes configuration parameters.<br>    disassemble (alias: disass)  Disassembler.<br>    dump ----------------------- Creates a core dump from the current process state<br>    edit (alias: ed) ----------- Open where you are in $DELVE_EDITOR or $EDITOR<br>    exit (alias: quit | q) ----- Exit the debugger.<br>    funcs ---------------------- Print list of functions.<br>    help (alias: h) ------------ Prints the help message.<br>    libraries ------------------ List loaded dynamic libraries<br>    list (alias: ls | l) ------- Show source code.<br>    source --------------------- Executes a file containing a list of delve commands<br>    sources -------------------- Print list of source files.<br>    target --------------------- Manages child process debugging.<br>    transcript ----------------- Appends command output to a file.<br>    types ---------------------- Print list of types<br><br>Type help followed by a command for full documentation.<br>(dlv)<br></code></pre></td></tr></table></figure><p>调试的过程中可以看到当前目录下会生成一个调试日志，日志名类似于__debug_bin528272488，不要操作这个文件，在执行quit命令推出delve的时候这个日志文件就会被自动删除。</p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>如果要调试程序，不可缺少的就是设置断点。所谓的断点，就是在调试程序时，程序指定到这个地方会停下，此时可以在dlv里查看当前的变量值是什么，或者可以之后逐行执行程序也就是每执行一行就停下来一次（因为默认情况下程序是会执行到下个断电或者执行到终端才停止的），或者可以设置接下来的条件断点（也就是满足指定条件时才触发断点）。</p><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><h4 id="为入口main设置断点"><a href="#为入口main设置断点" class="headerlink" title="为入口main设置断点"></a><strong>为入口main设置断点</strong></h4><p><strong>这个不是必要操作，不操作这个也可以调试程序。</strong></p><p>（每个Go程序的入口是main.main，可以用break在这个入口设置断点）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) break main.main<br>Breakpoint 1 set at 0x19aa9af for main.main() ./main.go:30<br></code></pre></td></tr></table></figure><h4 id="在某一行设置断点"><a href="#在某一行设置断点" class="headerlink" title="在某一行设置断点"></a><strong>在某一行设置断点</strong></h4><p>如main.go的第10行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) break main.go:10<br>Breakpoint 2 set at 0x10aea33 for main.main() ./main.go:10<br></code></pre></td></tr></table></figure><blockquote><p>如果设置断点时报错，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) break main.go:32<br>Command failed: Location &quot;main.go:32&quot; ambiguous: /Users/xxxx/MyLocalFile/代码/fromweb/gopacket-fram/a_runner/main.go, /Users/rhettnina/go/pkg/mod/github.com/jinzhu/now@v1.1.5/main.go…<br></code></pre></td></tr></table></figure><p>这是因为delve在设置断点时发生错误，即有多个文件包含相同的文件路径和行号，这可能是Go的模块的缓存导致的。可以在break后加上文件的完整路径来解决此问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">break /Users/xxxx/MyLocalFile/代码/fromweb/gopacket-fram/a_runner/main.go:32<br></code></pre></td></tr></table></figure></blockquote><h4 id="设置条件断点"><a href="#设置条件断点" class="headerlink" title="设置条件断点"></a><strong>设置条件断点</strong></h4><p>首先查看所有断点和断点ID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) breakpoints<br>Breakpoint runtime-fatal-throw (enabled) at 0x103b500,0x103b600 for (multiple functions)() &lt;multiple locations&gt;:0 (0)<br>Breakpoint unrecovered-panic (enabled) at 0x103b9a0 for runtime.fatalpanic() /usr/local/Cellar/go/1.20.6/libexec/src/runtime/panic.go:1145 (0)<br>print runtime.curg._panic.arg<br>Breakpoint 1 (enabled) at 0x19aa9e5 for main.main() ./main.go:32 (0)<br></code></pre></td></tr></table></figure><p>我想设置的是main.go的第32行，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">31for i := 0; i &lt; 3; i++ &#123;<br>32fmt.Println(i)<br>33&#125;<br></code></pre></td></tr></table></figure><p>在i的值为2时出现断点。</p><p>执行如下命令：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">condition <span class="hljs-number">1</span> i<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>这里的1是断点ID，后面i&#x3D;&#x3D;2是断点出现的条件。</p><h3 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h3><p>在调试模式下输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">breakpoints<br></code></pre></td></tr></table></figure><p>在不人为设置断点的默认情况下，会有一个panic函数断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) breakpoints<br>Breakpoint runtime-fatal-throw (enabled) at 0x103b600,0x103b500 for (multiple functions)() &lt;multiple locations&gt;:0 (0)<br>Breakpoint unrecovered-panic (enabled) at 0x103b9a0 for runtime.fatalpanic() /usr/local/Cellar/go/1.20.6/libexec/src/runtime/panic.go:1145 (0)<br>print runtime.curg._panic.arg<br></code></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="没有函数调用的情况"><a href="#没有函数调用的情况" class="headerlink" title="没有函数调用的情况"></a>没有函数调用的情况</h3><p>下面是一个示范，给一个例子进行调试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>nums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>nums[i] = i * i<br>&#125;<br>fmt.Println(nums)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>nums = <span class="hljs-built_in">append</span>(nums, i)<br>&#125;<br>fmt.Println(nums)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>dlv debug</code>进入调试模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">dlv debug</span>                                                       <br>Type &#x27;help&#x27; for list of commands.<br></code></pre></td></tr></table></figure><p>在main.go的第10行设置断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) break main.go:10<br>Breakpoint 1 set at 0x10b5c6f for main.main() ./main.go:10<br></code></pre></td></tr></table></figure><p>执行c会在下一个断点处中止：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) c<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:10 (hits goroutine(1):1 total:1) (PC: 0x10b5c6f)</span><br>     5:)<br>     6:<br>     7:func main() &#123;<br>     8:nums := make([]int, 5)<br>     9:for i := 0; i &lt; 5; i++ &#123;<br>=&gt;  10:nums[i] = i * i<br>    11:&#125;<br>    12:fmt.Println(nums)<br>    13:for i := 0; i &lt; 5; i++ &#123;<br>    14:nums = append(nums, i)<br>    15:&#125;<br></code></pre></td></tr></table></figure><p>在此处可以查看全部包级变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) vars<br>......<br>sync.allPoolsMu = sync.Mutex &#123;state: 0, sema: 0&#125;<br>sync.allPools = []*sync.Pool len: 0, cap: 0, nil<br>sync.oldPools = []*sync.Pool len: 0, cap: 0, nil<br></code></pre></td></tr></table></figure><p>因为vars输出特别多，可以用正则表达式过滤，比如过滤出变量名包含sync的所有变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) vars sync<br>runtime.asyncPreemptStack = 472<br>sync/atomic.firstStoreInProgress = 0<br>sync.expunged = (*interface &#123;&#125;)(0xc000096020)<br>sync.allPoolsMu = sync.Mutex &#123;state: 0, sema: 0&#125;<br>sync.allPools = []*sync.Pool len: 0, cap: 0, nil<br>sync.oldPools = []*sync.Pool len: 0, cap: 0, nil<br></code></pre></td></tr></table></figure><p>通过locals查看局部变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) locals<br>nums = []int len: 5, cap: 5, [...]<br>i = 0<br></code></pre></td></tr></table></figure><p>打印某个变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) print nums<br>[]int len: 5, cap: 5, [0,0,0,0,0]<br></code></pre></td></tr></table></figure><p><strong>此时nums还没有append第一个元素，虽然已经进入了循环内，因为调试模式此时的断点停止位置是在断点处也就是第10行执行之前停止的。</strong></p><p>然后继续执行c（即continue），让程序运行到下个断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) c<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:10 (hits goroutine(1):2 total:2) (PC: 0x10b5c6f)</span><br>     5:)<br>     6:<br>     7:func main() &#123;<br>     8:nums := make([]int, 5)<br>     9:for i := 0; i &lt; 5; i++ &#123;<br>=&gt;  10:nums[i] = i * i<br>    11:&#125;<br>    12:fmt.Println(nums)<br>    13:for i := 0; i &lt; 5; i++ &#123;<br>    14:nums = append(nums, i)<br>    15:&#125;<br></code></pre></td></tr></table></figure><p>除了执行c以外控制程序到下个断点处，还可以执行next即n，让调试程序逐行执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) n<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:9 (PC: 0x10b5ca5)</span><br>     4:&quot;fmt&quot;<br>     5:)<br>     6:<br>     7:func main() &#123;<br>     8:nums := make([]int, 5)<br>=&gt;   9:for i := 0; i &lt; 5; i++ &#123;<br>    10:nums[i] = i * i<br>    11:&#125;<br>    12:fmt.Println(nums)<br>    13:for i := 0; i &lt; 5; i++ &#123;<br>    14:nums = append(nums, i)<br>(dlv) n<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:10 (hits goroutine(1):3 total:3) (PC: 0x10b5c6f)</span><br>     5:)<br>     6:<br>     7:func main() &#123;<br>     8:nums := make([]int, 5)<br>     9:for i := 0; i &lt; 5; i++ &#123;<br>=&gt;  10:nums[i] = i * i<br>    11:&#125;<br>    12:fmt.Println(nums)<br>    13:for i := 0; i &lt; 5; i++ &#123;<br>    14:nums = append(nums, i)<br>    15:&#125;<br></code></pre></td></tr></table></figure><p>查看此时的本地变量，和预期相同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) locals<br>nums = []int len: 5, cap: 5, [...]<br>i = 2<br>(dlv) print nums<br>[]int len: 5, cap: 5, [0,1,0,0,0]<br>(dlv) print i<br>2<br></code></pre></td></tr></table></figure><p>此时i的值为2。下面设置一个条件断点，在第14行<code>    nums = append(nums, i)</code>当i为3时断点生效。</p><p>首先设置14行的断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv)  break main.go:14<br>Breakpoint 2 set at 0x10b5d5a for main.main() ./main.go:14<br></code></pre></td></tr></table></figure><p>通过输出可以看到该断点的ID是2。如果不设置条件，那么第14行就是一个断点，程序运行到第14行就会触发断点。下面设置这个断点的生效条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell]">(dlv) condition 2 i==3<br></code></pre></td></tr></table></figure><p>这样只有i&#x3D;&#x3D;3时才会触发断点2。</p><p>下面继续运行查看条件断点生效效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) c<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:10 (hits goroutine(1):4 total:4) (PC: 0x10b5c6f)</span><br>     5:)<br>     6:<br>     7:func main() &#123;<br>     8:nums := make([]int, 5)<br>     9:for i := 0; i &lt; 5; i++ &#123;<br>=&gt;  10:nums[i] = i * i<br>    11:&#125;<br>    12:fmt.Println(nums)<br>    13:for i := 0; i &lt; 5; i++ &#123;<br>    14:nums = append(nums, i)<br>    15:&#125;<br>(dlv) c<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:10 (hits goroutine(1):5 total:5) (PC: 0x10b5c6f)</span><br>     5:)<br>     6:<br>     7:func main() &#123;<br>     8:nums := make([]int, 5)<br>     9:for i := 0; i &lt; 5; i++ &#123;<br>=&gt;  10:nums[i] = i * i<br>    11:&#125;<br>    12:fmt.Println(nums)<br>    13:for i := 0; i &lt; 5; i++ &#123;<br>    14:nums = append(nums, i)<br>    15:&#125;<br>(dlv) c<br>[0 1 4 9 16]<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:14 (hits goroutine(1):1 total:1) (PC: 0x10b5d5a)</span><br>     9:for i := 0; i &lt; 5; i++ &#123;<br>    10:nums[i] = i * i<br>    11:&#125;<br>    12:fmt.Println(nums)<br>    13:for i := 0; i &lt; 5; i++ &#123;<br>=&gt;  14:nums = append(nums, i)<br>    15:&#125;<br>    16:fmt.Println(nums)<br>    17:&#125;<br>    18:<br>    19:func cleanPath(p string) string &#123;<br>(dlv) print i<br>3<br></code></pre></td></tr></table></figure><p>可以看到触发14行的断点时，i的就是3，达到了满足断点触发的条件。</p><p>接下来继续运行c命令，程序推出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) c<br>[0 1 4 9 16 0 1 2 3 4]<br>Process 77401 has exited with status 0<br></code></pre></td></tr></table></figure><h3 id="查看有函数调用的情况"><a href="#查看有函数调用的情况" class="headerlink" title="查看有函数调用的情况"></a>查看有函数调用的情况</h3><h4 id="在函数内部设置断点"><a href="#在函数内部设置断点" class="headerlink" title="在函数内部设置断点"></a>在函数内部设置断点</h4><p><strong>想要查看函数内部的运行情况，可以在函数内部设置断点。</strong></p><p>以下面这个源代码的调试为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">package main<br><br>import (<br>&quot;fmt&quot;<br>)<br><br>func main() &#123;<br>i := 10<br>j := 20<br>r := multi(i, j)<br>fmt.Println(r)<br>&#125;<br><br>func multi(i, j int) int &#123;<br>r := i * j<br>return r<br>&#125;<br></code></pre></td></tr></table></figure><p>现在进入multi函数前设置断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">dlv debug<br>Type &#x27;help&#x27; for list of commands.<br>(dlv) break main.go:9<br>Breakpoint 1 set at 0x10b5c21 for main.main() ./main.go:9<br>(dlv) c<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:9 (hits goroutine(1):1 total:1) (PC: 0x10b5c21)</span><br>Warning: listing may not match stale executable<br>     4:&quot;fmt&quot;<br>     5:)<br>     6:<br>     7:func main() &#123;<br>     8:i := 10<br>=&gt;   9:j := 20<br>    10:r := multii(i, j)<br>    11:fmt.Println(r)<br>    12:&#125;<br>    13:<br>    14:func multii(i, j int) int &#123;<br></code></pre></td></tr></table></figure><p>下面单步执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) n<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:10 (PC: 0x10b5c2a)</span><br>Warning: listing may not match stale executable<br>     5:)<br>     6:<br>     7:func main() &#123;<br>     8:i := 10<br>     9:j := 20<br>=&gt;  10:r := multi(i, j)<br>    11:fmt.Println(r)<br>    12:&#125;<br>    13:<br>    14:func multi(i, j int) int &#123;<br>    15:r := i * j<br>(dlv) n<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:11 (PC: 0x10b5c3e)</span><br>Warning: listing may not match stale executable<br>     6:<br>     7:func main() &#123;<br>     8:i := 10<br>     9:j := 20<br>    10:r := multi(i, j)<br>=&gt;  11:fmt.Println(r)<br>    12:&#125;<br>    13:<br>    14:func multi(i, j int) int &#123;<br>    15:r := i * j<br>    16:return r<br></code></pre></td></tr></table></figure><p>发现跳过了进入函数的内部。下面重新执行以下，在函数内部设置断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">dlv debug</span><br>(dlv) break main.go:9<br>Breakpoint 1 set at 0x10b5c21 for main.main() ./main.go:9<br>(dlv) c<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:9 (hits goroutine(1):1 total:1) (PC: 0x10b5c21)</span><br>     4:&quot;fmt&quot;<br>     5:)<br>     6:<br>     7:func main() &#123;<br>     8:i := 10<br>=&gt;   9:j := 20<br>    10:r := multi(i, j)<br>    11:fmt.Println(r)<br>    12:&#125;<br>    13:<br>    14:func multi(i, j int) int &#123;<br>(dlv) break main.go:15<br>Breakpoint 2 set at 0x10b5d00 for main.multi() ./main.go:15<br></code></pre></td></tr></table></figure><p>下面继续执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) c<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:9 (hits goroutine(1):1 total:1) (PC: 0x10b5c21)</span><br>     4:&quot;fmt&quot;<br>     5:)<br>     6:<br>     7:func main() &#123;<br>     8:i := 10<br>=&gt;   9:j := 20<br>    10:r := multi(i, j)<br>    11:fmt.Println(r)<br>    12:&#125;<br>    13:<br>    14:func multi(i, j int) int &#123;<br>(dlv) break main.go:15<br>Breakpoint 2 set at 0x10b5d00 for main.multi() ./main.go:15<br>(dlv) c<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.multi() ./main.go:15 (hits goroutine(1):1 total:1) (PC: 0x10b5d00)</span><br>    10:r := multi(i, j)<br>    11:fmt.Println(r)<br>    12:&#125;<br>    13:<br>    14:func multi(i, j int) int &#123;<br>=&gt;  15:r := i * j<br>    16:<br></code></pre></td></tr></table></figure><p>可以看到此时到达了函数内部。</p><p>在函数内部，有不同的命令可以用，args可以查看函数接收的参数是什么</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) args<br>i = 10<br>j = 20<br>~r0 = 0<br></code></pre></td></tr></table></figure><p>stack查看调用栈：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) stack<br>0  0x00000000010b5d00 in main.multi<br>   at ./main.go:15<br>1  0x00000000010b5c39 in main.main<br>   at ./main.go:10<br>2  0x00000000010394f3 in runtime.main<br>   at /usr/local/Cellar/go/1.20.6/libexec/src/runtime/proc.go:250<br>3  0x0000000001066b61 in runtime.goexit<br>   at /usr/local/Cellar/go/1.20.6/libexec/src/runtime/asm_amd64.s:1598<br></code></pre></td></tr></table></figure><p>查看goroutine相关信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) goroutines<br>* Goroutine 1 - User: ./main.go:15 main.multi (0x10b5d00) (thread 6973579)<br>  Goroutine 2 - User: /usr/local/Cellar/go/1.20.6/libexec/src/runtime/proc.go:382 runtime.gopark (0x103999d) [force gc (idle)]<br>  Goroutine 3 - User: /usr/local/Cellar/go/1.20.6/libexec/src/runtime/proc.go:382 runtime.gopark (0x103999d) [GC sweep wait]<br>  Goroutine 4 - User: /usr/local/Cellar/go/1.20.6/libexec/src/runtime/proc.go:382 runtime.gopark (0x103999d) [GC scavenge wait]<br>  Goroutine 5 - User: /usr/local/Cellar/go/1.20.6/libexec/src/runtime/proc.go:382 runtime.gopark (0x103999d) [finalizer wait]<br>[5 goroutines]<br>(dlv) goroutine<br>Thread 6973579 at ./main.go:15<br>Goroutine 1:<br>Runtime: ./main.go:15 main.multi (0x10b5d00)<br>User: ./main.go:15 main.multi (0x10b5d00)<br>Go: &lt;autogenerated&gt;:1 runtime.newproc (0x1069365)<br>Start: /usr/local/Cellar/go/1.20.6/libexec/src/runtime/proc.go:145 runtime.main (0x1039320)<br></code></pre></td></tr></table></figure><p>最后通过quit退出函数。</p><h4 id="设置函数名处断点"><a href="#设置函数名处断点" class="headerlink" title="设置函数名处断点"></a>设置函数名处断点</h4><p>比如对于上面的源码，设置断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">break main<br></code></pre></td></tr></table></figure><p>那么执行c命令时会在调用该函数处触发断点，接下来使用n即可进入函数内部查看具体调用情况。</p><p>此外还有很多其他可以运行的命令，在help命令里列出来了，这里介绍了一些基本的常用的命令。</p><p>print命令可以用p代替，表示缩写。</p><h4 id="调试过程中执行函数调用"><a href="#调试过程中执行函数调用" class="headerlink" title="调试过程中执行函数调用"></a>调试过程中执行函数调用</h4><p>这个步骤就是在执行过程中自定义参数调用函数，比如对于上面的例子程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">dlv debug                                           <br>Type &#x27;help&#x27; for list of commands.<br>(dlv) break main.main<br>Breakpoint 1 set at 0x10b5c0a for main.main() ./main.go:7<br>(dlv) break main.go:10<br>Breakpoint 2 set at 0x10b5c2a for main.main() ./main.go:10<br>(dlv) c<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:7 (hits goroutine(1):1 total:1) (PC: 0x10b5c0a)</span><br>     2:<br>     3:import (<br>     4:&quot;fmt&quot;<br>     5:)<br>     6:<br>=&gt;   7:func main() &#123;<br>     8:i := 10<br>     9:j := 20<br>    10:r := multi(i, j)<br>    11:fmt.Println(r)<br>    12:&#125;<br>(dlv) c<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:10 (hits goroutine(1):1 total:1) (PC: 0x10b5c2a)</span><br>     5:)<br>     6:<br>     7:func main() &#123;<br>     8:i := 10<br>     9:j := 20<br>=&gt;  10:r := multi(i, j)<br>    11:fmt.Println(r)<br>    12:&#125;<br>    13:<br>    14:func multi(i, j int) int &#123;<br>    15:r := i * j<br></code></pre></td></tr></table></figure><p>此时到达了断点，然后按行执行下一步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) n<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:11 (PC: 0x10b5c3e)</span><br>     6:<br>     7:func main() &#123;<br>     8:i := 10<br>     9:j := 20<br>    10:r := multi(i, j)<br>=&gt;  11:fmt.Println(r)<br>    12:&#125;<br>    13:<br>    14:func multi(i, j int) int &#123;<br>    15:r := i * j<br>    16:return r<br></code></pre></td></tr></table></figure><p>程序里调用multi传递的参数值是10和20，如果在调试中我突然想测试一些极端情况，可以执行call命令，自定义参数调用函数，比如传递-1 -1给multi：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) call multi(-1,-1)<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:11 (PC: 0x10b5c3e)</span><br>Values returned:<br>~r0: 1<br><br>     6:<br>     7:func main() &#123;<br>     8:i := 10<br>     9:j := 20<br>    10:r := multi(i, j)<br>=&gt;  11:fmt.Println(r)<br>    12:&#125;<br>    13:<br>    14:func multi(i, j int) int &#123;<br>    15:r := i * j<br>    16:return r<br></code></pre></td></tr></table></figure><p>可以看到有值返回了，返回的值是1，也就是multi(-1,-1)的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Values returned:<br>~r0: 1<br></code></pre></td></tr></table></figure><p>因为上一步程序调试停在了11行fmt.Println(r)，这里中途执行call不会影响上一步调试的停止，中途执行call之后程序还是停在了11行，下面把程序执行完毕：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">(dlv) n<br>200<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">main.main() ./main.go:12 (PC: 0x10b5cba)</span><br>     7:func main() &#123;<br>     8:i := 10<br>     9:j := 20<br>    10:r := multi(i, j)<br>    11:fmt.Println(r)<br>=&gt;  12:&#125;<br>    13:<br>    14:func multi(i, j int) int &#123;<br>    15:r := i * j<br>    16:return r<br>    17:&#125;<br>(dlv) c<br>Process 11724 has exited with status 0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>tcp的flag标识</title>
    <link href="/2023/02/13/tcp%E7%9A%84flag%E6%A0%87%E8%AF%86/"/>
    <url>/2023/02/13/tcp%E7%9A%84flag%E6%A0%87%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="所有标识位"><a href="#所有标识位" class="headerlink" title="所有标识位"></a>所有标识位</h2><p>图片来自<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">维基百科</a></p><p><a href="https://imgse.com/i/pSWuNHs"><img src="https://s1.ax1x.com/2023/02/09/pSWuNHs.png" alt="pSWuNHs.png"></a></p><p>TCP报文段分为首部和数据部分，TCP首部分为固定部分和选项(变长部分)，首部的固定部分(共有20字节);可选部分的长度为0~40字节</p><h3 id="6个主要的标志位"><a href="#6个主要的标志位" class="headerlink" title="6个主要的标志位"></a>6个主要的标志位</h3><blockquote><p>URG和PSH在数据传输的过程中使用</p></blockquote><p>紧急位URG</p><p>确认位ACKACK 携带两个信息。期待要收到下一个数据包的编号、接收方的接收窗口的剩余容量</p><p>推送位PSH(Push)。PSH 标志位表示发送端请求接收端尽快将数据传递给应用层。</p><p>复位位RST (Reset)：RST&#x3D; 1时，表明TCP连接中出现严重差错（如主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。</p><p>同步位SYN：表示这是一个连接请求或连接接受报文。</p><p>终止位FIN：表明此报文段的发送方的数据已发送完毕，并要求释放传输连接。</p><p>###<strong>另外3个</strong></p><p>CWR：告诉对方本端已经减小了拥赛窗口</p><p>ECE：告诉对端对端的网络发生的拥赛</p><p>NS：无报文段</p><h2 id="常见的三次握手四次挥手"><a href="#常见的三次握手四次挥手" class="headerlink" title="常见的三次握手四次挥手"></a>常见的三次握手四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><a href="https://imgse.com/i/pSRjFr4"><img src="https://s1.ax1x.com/2023/02/09/pSRjFr4.png" alt="pSRjFr4.png"></a></p><p>SYN&#x3D;1</p><p>SYN&#x3D;1 ACK&#x3D;1</p><p>ACK&#x3D;1</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><a href="https://imgse.com/i/pSRjXQO"><img src="https://s1.ax1x.com/2023/02/09/pSRjXQO.png" alt="pSRjXQO.png"></a></p><p>FIN&#x3D;1</p><p>ACK&#x3D; 1</p><p>FIN&#x3D;1，ACK&#x3D; 1</p><p>ACK &#x3D; 1</p><p>这是wireshark里的抓到的三次握手四次挥手，可以观察具体场景中的Flag设置情况</p><p><a href="https://imgse.com/i/pSoehKf"><img src="https://s1.ax1x.com/2023/02/13/pSoehKf.png" alt="pSoehKf.png"></a></p><p>我抓到的Flags有9位：</p><p><a href="https://imgse.com/i/pSRv3lT"><img src="https://s1.ax1x.com/2023/02/09/pSRv3lT.png" alt="pSRv3lT.png"></a></p><h2 id="所有常见的flag组合"><a href="#所有常见的flag组合" class="headerlink" title="所有常见的flag组合"></a>所有常见的flag组合</h2><p>根据我电脑上抓包的结果，共18项</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-number">20</span><span class="hljs-symbol">:ACK+RST</span> 重置连接，并且确认了已经收到了对端的消息<br><span class="hljs-number">18</span><span class="hljs-symbol">:ACK+SYN</span> 确认连接建立<br><span class="hljs-number">25</span><span class="hljs-symbol">:ACK+PSH+FIN</span> 要求对端尽快将数据传递给应用层且关闭连接<br><span class="hljs-number">153</span><span class="hljs-symbol">:CWR+ACK+PSH+FIN</span> 正在结束连接，并且请求对端尽快将数据传递给应用层，通知对端本端已经减小了拥戴窗口<br><span class="hljs-number">144</span><span class="hljs-symbol">:CWR+ACK</span> 告诉对端本端已经减小了拥戴窗口<br><span class="hljs-number">194</span><span class="hljs-symbol">:CWR+ECE+SYN</span> 请求建立<span class="hljs-title class_">TCP</span>连接，告诉对端本端已经减小了拥戴窗口且对端网络拥塞了<br><span class="hljs-number">152</span><span class="hljs-symbol">:CWR+ACK+PSH</span> 收到了发送端传输的数据，并请求对端紧急发送数据，告诉对端本端已经减小了拥戴窗口<br><span class="hljs-number">24</span><span class="hljs-symbol">:ACK+PSH</span> 确认了已经收到了对端尽快将数据传递给应用层，如发送<span class="hljs-title class_">HTTP</span>请求和<span class="hljs-title class_">HTTP</span>响应中会出现<br><span class="hljs-number">16</span><span class="hljs-symbol">:ACK</span> 确认数据已成功接收<br><span class="hljs-number">17</span><span class="hljs-symbol">:ACK+FIN</span> 关闭连接<br><span class="hljs-number">2</span><span class="hljs-symbol">:SYN</span> 建立连接<br><span class="hljs-number">82</span><span class="hljs-symbol">:ECE+ACK+SYN</span> <span class="hljs-title class_">TCP</span>连接正在建立，通知对端其网络拥塞了<br><span class="hljs-number">4</span><span class="hljs-symbol">:RST</span> 重置连接<br><span class="hljs-number">148</span><span class="hljs-symbol">:CWR+ACK+RST</span> 强制重置连接且通知发送方网络拥塞的情况。通常在网络出现故障或拥塞时使用，用于快速终止连接。<br><span class="hljs-number">34</span><span class="hljs-symbol">:URG+SYN</span> 在连接建立时发送紧急数据<br><span class="hljs-number">210</span><span class="hljs-symbol">:CWR+ECE+ACK+SYN</span> <span class="hljs-title class_">TCP</span>的<span class="hljs-title class_">ECN</span> (显式拥塞通知)功能被启用，同时也表示<span class="hljs-title class_">TCP</span>连接正在建立。<br><span class="hljs-number">146</span><span class="hljs-symbol">:CWR+ACK+SYN</span> 发送方已经接收到对方的<span class="hljs-title class_">SYN</span>请求，并且表示接收到对方的拥塞窗口减少通知，同时也向对方发送一个确认应答。<br><span class="hljs-number">26</span><span class="hljs-symbol">:ACK+PSH+SYN</span> 发送方已经接收到对方的<span class="hljs-title class_">SYN</span>请求，同时需要立即推送数据，并向对方发送一个确认应答。<br></code></pre></td></tr></table></figure><p>没有URG的包，根据chatgpt的回答，增加了以下这些URG的情况：</p><blockquote><p>来自chatgpt</p><p>根据TCP协议的标准（RFC 793），所有合法的TCP标志组合如下：</p><ol><li>ACK：一般用于确认数据已成功接收。</li><li>SYN：用于建立连接。</li><li>SYN-ACK：连接请求后，服务端会返回SYN-ACK标志以确认连接建立。</li><li><strong>FIN：用于关闭连接。</strong>（这个上面的没有）</li><li>FIN-ACK：在关闭连接请求后，服务端会返回FIN-ACK标志以确认连接关闭。</li><li>RST：用于重置连接。</li><li>ACK-RST：表示重置请求已确认。</li><li><strong>PSH：用于将数据强制刷到接收端，以避免缓存。</strong></li><li><strong>URG：用于标识数据有紧急标志。</strong></li><li><strong>ECE：拥塞状态下的TCP的标志。</strong></li><li><strong>CWR：拥塞状态下的TCP的标志。</strong></li><li>NS：用于识别非恶意的报文。(我没有统计这个，忽略这个)</li></ol></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-number">56</span><span class="hljs-symbol">:URG+PSH+ACK</span> 强制将紧急数据立即传递给应用层<br><span class="hljs-number">48</span><span class="hljs-symbol">:URG+ACK</span> 优先处理紧急数据<br></code></pre></td></tr></table></figure><p>总结下来就是如下这些TCP标志位（应该是大部分的，可能不是全部的）和对应的含义：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-number">20</span>: <span class="hljs-title class_">ACK</span>、<span class="hljs-title class_">RST</span>被设置，表示重置连接，并且确认了已经收到了对端的消息<br><span class="hljs-number">18</span>: <span class="hljs-title class_">ACK</span>、<span class="hljs-title class_">SYN</span>被设置，表示确认连接建立<br><span class="hljs-number">25</span>: <span class="hljs-title class_">ACK</span>、<span class="hljs-title class_">PSH</span>、<span class="hljs-title class_">FIN</span>被设置，表示要求对端尽快将数据传递给应用层且关闭连接<br><span class="hljs-number">153</span>: <span class="hljs-title class_">CWR</span>、<span class="hljs-title class_">ACK</span>、<span class="hljs-title class_">PSH</span>、<span class="hljs-title class_">FIN</span>被设置，表示正在结束连接，并且请求对端尽快将数据传递给应用层，通知对端本端已经减小了拥戴窗口<br><span class="hljs-number">144</span>: <span class="hljs-title class_">CWR</span>、<span class="hljs-title class_">ACK</span>被设置，表示告诉对端本端已经减小了拥戴窗口<br><span class="hljs-number">194</span>: <span class="hljs-title class_">CWR</span>、<span class="hljs-title class_">ECE</span>、<span class="hljs-title class_">SYN</span>被设置，表示请求建立<span class="hljs-title class_">TCP</span>连接，告诉对端本端已经减小了拥戴窗口且对端网络拥塞了<br><span class="hljs-number">152</span> <span class="hljs-symbol">:CWR</span>、<span class="hljs-title class_">ACK</span>、<span class="hljs-title class_">PSH</span>被设置，表示收到了发送端传输的数据，并请求对端紧急发送数据，告诉对端本端已经减小了拥戴窗口<br><span class="hljs-number">24</span>: <span class="hljs-title class_">ACK</span>、<span class="hljs-title class_">PSH</span>被设置，表示确认了已经收到了对端尽快将数据传递给应用层，如发送<span class="hljs-title class_">HTTP</span>请求和<span class="hljs-title class_">HTTP</span>响应中会出现<br><span class="hljs-number">16</span>: <span class="hljs-title class_">ACK</span>被设置，表示确认数据已成功接收<br><span class="hljs-number">17</span>: <span class="hljs-title class_">ACK</span>、<span class="hljs-title class_">FIN</span>被设置，表示关闭连接<br><span class="hljs-number">2</span>: <span class="hljs-title class_">SYN</span>被设置，表示建立连接<br><span class="hljs-number">82</span>: <span class="hljs-title class_">ECE</span>、<span class="hljs-title class_">ACK</span>、<span class="hljs-title class_">SYN</span>被设置，表示<span class="hljs-title class_">TCP</span>连接正在建立，通知对端其网络拥塞了<br><span class="hljs-number">4</span>: <span class="hljs-title class_">RST</span>被设置，表示重置连接<br><span class="hljs-number">148</span><span class="hljs-symbol">:CWR+ACK+RST</span> 强制重置连接且通知发送方网络拥塞的情况。通常在网络出现故障或拥塞时使用，用于快速终止连接。<br><span class="hljs-number">34</span><span class="hljs-symbol">:URG+SYN</span> 在连接建立时发送紧急数据<br><span class="hljs-number">210</span><span class="hljs-symbol">:CWR+ECE+ACK+SYN</span> <span class="hljs-title class_">TCP</span>的<span class="hljs-title class_">ECN</span> (显式拥塞通知)功能被启用，同时也表示<span class="hljs-title class_">TCP</span>连接正在建立。<br><span class="hljs-number">146</span><span class="hljs-symbol">:CWR+ACK+SYN</span> 发送方已经接收到对方的<span class="hljs-title class_">SYN</span>请求，并且表示接收到对方的拥塞窗口减少通知，同时也向对方发送一个确认应答。<br><span class="hljs-number">26</span><span class="hljs-symbol">:ACK+PSH+SYN</span> 发送方已经接收到对方的<span class="hljs-title class_">SYN</span>请求，同时需要立即推送数据，并向对方发送一个确认应答。<br></code></pre></td></tr></table></figure><h2 id="不常见的标识"><a href="#不常见的标识" class="headerlink" title="不常见的标识"></a>不常见的标识</h2><h3 id="CWR和ECE"><a href="#CWR和ECE" class="headerlink" title="CWR和ECE"></a>CWR和ECE</h3><p>这2个在TCP拥塞控制中使用。</p><p>TCP拥塞控制通过计算窗口大小，动态调整发送速率来实现。在网络拥塞时，窗口大小会减小，减缓数据的发送速率；在网络空闲时，窗口大小会增加，加快数据的发送速率。通过这种方式，TCP拥塞控制能够在网络拥塞状态下有效地避免数据的丢失。</p><p><a href="https://www.catchpoint.com/blog/ece-cwr-tcp">参考</a></p><p>这两个 TCP 标志与 IP 标头中的两个标志（ECT 和 CE）一起使用，以警告发送方网络拥塞，从而避免数据包丢失和重传。</p><p>Prior to acknowledging the receipt of the packet, the receiver sets the ECE flag in the TCP header of the ACK and sends it back to the sender. The sender having received the ECE marked ACK responds by halving the send window and reducing the slow start threshold.</p><p><a href="https://www.geeksforgeeks.org/working-of-explicit-congestion-notification/">参考</a>（这个讲得很好）这个讲了TCP拥塞控制的整个过程是什么样子的。</p><ol start="0"><li><p>ECN协商</p></li><li><p>现在发件人正在向另一方发送数据包。 它将在 IP 标头中设置 ECT 以通知路由器发送方和接收方都启用了 ECN，并且他们已经相互通话。</p></li><li><p>路由器检测到了当前网络遇到了拥塞，当数据包到达路由器时，检测到数据包的IP头部有ECT，路由设置EC。CE 表明路由器正在经历拥塞。 CE 从路由器发送到接收方。这个过程中标头的变化是ECT [0 1] -&gt; CE [1 1]</p></li><li><p>接收方看到 IP 报头中的 CE 标记，就知道路由器拥塞了。 现在接收方有责任通知发送方拥塞。接收方标记TCP的ECE标头。</p><p>当 SYN&#x2F;ACK 位打开时，ECE 位表示 ECN 协商（也就是步骤0），而不是拥塞。 但是现在，ACK 数据包中的 ECE 位处于打开状态，因此发送方知道路由器拥塞。</p></li><li><p>发送方收到了ECE标志后，发送方将其拥塞窗口减少一半。</p></li><li><p>发送方在TCP头中设置CWR，在IP头中设置ECT，告诉接收方自己已经减小了拥塞窗口为了避免拥塞。</p></li><li><p>当数据包到达路由器时，如果路由器感到拥塞，它可以将 ECT 推销给 CE。</p></li><li><p>当数据包到达接收方时，因为这个数据包有CWR标识，接收方检测到这个标识后会停止在后续的 ACK 数据包中向发送方发送 ECE 标志。</p></li></ol><h3 id="PSH和URG"><a href="#PSH和URG" class="headerlink" title="PSH和URG"></a>PSH和URG</h3><p><a href="https://packetlife.net/blog/2011/mar/2/tcp-flags-psh-and-urg/">参考</a></p><p>初始 HTTP 请求设置了 PSH 标志，表明发送方没有进一步的数据要添加，接收方应立即发送到应用程序，不要把数据放到TCP缓冲区了。</p><p>URG用来告诉接收方有些数据是紧急的并且应该被优先处理。如果设置了 URG 标志，将评估紧急指针，这是 TCP 标头中的一个 16 位字段。 该指针指示数据包中有多少数据（从第一个字节开始计算）是紧急的。</p><p><a href="https://imgse.com/i/pSoVGsU"><img src="https://s1.ax1x.com/2023/02/13/pSoVGsU.png" alt="pSoVGsU.png"></a></p><p>这个URG的情况很少出现。</p><h2 id="RFC文档"><a href="#RFC文档" class="headerlink" title="RFC文档"></a>RFC文档</h2><p>可以查看<a href="https://datatracker.ietf.org/doc/html/rfc793">rfc793文档</a>里的各个Figure，获取关于TCP连接状态变更和Flag变更的图。</p><h2 id="打印某个flag对应所有被设置的位"><a href="#打印某个flag对应所有被设置的位" class="headerlink" title="打印某个flag对应所有被设置的位"></a>打印某个flag对应所有被设置的位</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">type</span> FlagName <span class="hljs-keyword">struct</span> &#123;<br>Flag <span class="hljs-type">int</span><br>Name <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-keyword">const</span> (<br>FlagFIN = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span><br>FlagSYN<br>FlagRST<br>FlagPSH<br>FlagACK<br>FlagURG<br>FlagECE<br>FlagCWR<br>)<br>flagList := []FlagName&#123;<br>&#123;FlagFIN, <span class="hljs-string">&quot;FIN&quot;</span>&#125;,<br>&#123;FlagSYN, <span class="hljs-string">&quot;SYN&quot;</span>&#125;,<br>&#123;FlagRST, <span class="hljs-string">&quot;RST&quot;</span>&#125;,<br>&#123;FlagPSH, <span class="hljs-string">&quot;PSH&quot;</span>&#125;,<br>&#123;FlagACK, <span class="hljs-string">&quot;ACK&quot;</span>&#125;,<br>&#123;FlagURG, <span class="hljs-string">&quot;URG&quot;</span>&#125;,<br>&#123;FlagECE, <span class="hljs-string">&quot;ECE&quot;</span>&#125;,<br>&#123;FlagCWR, <span class="hljs-string">&quot;CWR&quot;</span>&#125;,<br>&#125;<br>all := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0x014</span>, <span class="hljs-number">0x012</span>, <span class="hljs-number">0x019</span>, <span class="hljs-number">0x099</span>, <span class="hljs-number">0x090</span>, <span class="hljs-number">0x0c2</span>, <span class="hljs-number">0x098</span>, <span class="hljs-number">0x018</span>, <span class="hljs-number">0x010</span>, <span class="hljs-number">0x011</span>, <span class="hljs-number">0x002</span>, <span class="hljs-number">0x052</span>, <span class="hljs-number">0x004</span>&#125;<br><span class="hljs-comment">// all := []int&#123;20, 18, 25, 153, 144, 194, 152, 24, 16, 17, 2, 82, 4&#125;</span><br><span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> all &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d:&quot;</span>, i)<br><span class="hljs-keyword">for</span> index := <span class="hljs-keyword">range</span> flagList &#123;<br>last := <span class="hljs-built_in">len</span>(flagList) - <span class="hljs-number">1</span> - index<br>current := flagList[last]<br><span class="hljs-keyword">if</span> current.Flag&amp;i != <span class="hljs-number">0</span> &#123;<br>fmt.Print(current.Name + <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br>&#125;<br>fmt.Println()<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IntToByteArray</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>size := <span class="hljs-type">int</span>(unsafe.Sizeof(num))<br>arr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, size)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>byt := *(*<span class="hljs-type">uint8</span>)(unsafe.Pointer(<span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;num)) + <span class="hljs-type">uintptr</span>(i)))<br>arr[i] = byt<br>&#125;<br><span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><p>比如打印wireshark抓到的flags对应的0x010，就可以查看有哪些位被设置了。</p><p><a href="https://imgse.com/i/pSoqqtH"><img src="https://s1.ax1x.com/2023/02/14/pSoqqtH.png" alt="pSoqqtH.png"></a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>geoip的使用</title>
    <link href="/2023/02/07/geoip%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/02/07/geoip%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Maxminds的官网：<a href="https://www.maxmind.com/en/geoip2-services-and-databases">https://www.maxmind.com/en/geoip2-services-and-databases</a></p><h2 id="GeoIP2和GeoIPLite2的对比"><a href="#GeoIP2和GeoIPLite2的对比" class="headerlink" title="GeoIP2和GeoIPLite2的对比"></a>GeoIP2和GeoIPLite2的对比</h2><p>两者都提供了获取某个指定IP的信息的功能。</p><p>GeoIP2和GeoIPLite2都提供了数据库和web服务。</p><p>GeoIPLite2数据库和web服务提供了指定IP的免费地理定位和有限的网络数据。通过GeoIP2获取的数据比通过GeoIP2获取的数据更为准确，也就是准确性更高。</p><p>下载GeoLite2数据库或者访问GeoLite2的web服务都需要先注册GeoLite2的账号。</p><p>GeoLite2 使用与 GeoIP2相同的集成方法和文档，并进行了一些小的修改。</p><p>GeoIP2比GeoLite2的数据更为准确，每个月的第一个周二，这两个数据库都会有更新。</p><p>GeoIP2 数据库比 GeoLite2 数据库更准确，因为前者是使用更多数据构建的。</p><p>GeoIP2 在国家层面上的准确率为 99.8%。 GeoLite2 在国家层面上应该是差不多的。</p><h2 id="自动更新数据库"><a href="#自动更新数据库" class="headerlink" title="自动更新数据库"></a>自动更新数据库</h2><p>可以使用MaxMind的GeoIP更新程序（参考<a href="https://github.com/maxmind/geoipupdate%EF%BC%89%E6%88%96%E8%80%85%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%82%E5%89%8D%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E6%9B%B4%E4%B8%BA%E6%8E%A8%E8%8D%90%EF%BC%8C%E4%B8%8B%E9%9D%A2%E4%BB%8B%E7%BB%8D%E5%89%8D%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BB%A5Mac%E4%B8%BA%E4%BE%8B%EF%BC%9A">https://github.com/maxmind/geoipupdate）或者直接下载数据库。前一种方法更为推荐，下面介绍前一种方法，以Mac为例：</a></p><ol><li><p>安装geoipupdate程序：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>geoipupdatec<br></code></pre></td></tr></table></figure></li><li><p>在<a href="https://www.maxmind.com/en/accounts/current/license-key%E7%94%9F%E6%88%90license">https://www.maxmind.com/en/accounts/current/license-key生成license</a> key信息， 复制<a href="https://www.maxmind.com/en/accounts/current/license-key/GeoIP.conf%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E5%B0%86%E5%85%B6%E4%B8%AD%E7%9A%84LicenseKey%E7%9A%84%E5%86%85%E5%AE%B9%E6%9B%BF%E6%8D%A2%E6%88%90%E7%94%9F%E6%88%90%E7%9A%84license">https://www.maxmind.com/en/accounts/current/license-key/GeoIP.conf的内容，将其中的LicenseKey的内容替换成生成的license</a> key信息，最后将修改后的内容复制到&#x2F;usr&#x2F;local&#x2F;etc&#x2F;GeoIP.conf，最终&#x2F;usr&#x2F;local&#x2F;etc&#x2F;GeoIP.conf的内容格式为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># GeoIP.conf file for `geoipupdate` program, for versions &gt;= 3.1.1.</span><br><span class="hljs-comment"># Used to update GeoIP databases from https://www.maxmind.com.</span><br><span class="hljs-comment"># For more information about this config file, visit the docs at</span><br><span class="hljs-comment"># https://dev.maxmind.com/geoip/updating-databases?lang=en.</span><br><br><span class="hljs-comment"># `AccountID` is from your MaxMind account.</span><br><span class="hljs-attribute">AccountID</span> <span class="hljs-number">777777</span><br><br><span class="hljs-comment"># Replace YOUR_LICENSE_KEY_HERE with an active license key associated</span><br><span class="hljs-comment"># with your MaxMind account.</span><br><span class="hljs-attribute">LicenseKey</span> IXXXXXXXX<br><br><span class="hljs-comment"># `EditionIDs` is from your MaxMind account.</span><br><span class="hljs-attribute">EditionIDs</span> GeoLite2-ASN GeoLite2-City GeoLite2-Country<br></code></pre></td></tr></table></figure></li><li><p>运行：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">geoipupdate</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="获取IP信息"><a href="#获取IP信息" class="headerlink" title="获取IP信息"></a>获取IP信息</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><br><span class="hljs-string">&quot;github.com/oschwald/geoip2-golang&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db, err := geoip2.Open(<span class="hljs-string">&quot;GeoLite2-City.mmdb&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> db.Close()<br><span class="hljs-comment">// If you are using strings that may be invalid, check that ip is not nil</span><br>ip := net.ParseIP(<span class="hljs-string">&quot;81.2.69.142&quot;</span>)<br>record, err := db.City(ip)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;Portuguese (BR) city name: %v\n&quot;</span>, record.City.Names[<span class="hljs-string">&quot;zh-CN&quot;</span>])<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(record.Subdivisions) &gt; <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;English subdivision name: %v\n&quot;</span>, record.Subdivisions[<span class="hljs-number">0</span>].Names[<span class="hljs-string">&quot;zh-CN&quot;</span>])<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;country name: %v\n&quot;</span>, record.Country.Names[<span class="hljs-string">&quot;zh-CN&quot;</span>])<br>fmt.Printf(<span class="hljs-string">&quot;ISO country code: %v\n&quot;</span>, record.Country.IsoCode)<br>fmt.Printf(<span class="hljs-string">&quot;Time zone: %v\n&quot;</span>, record.Location.TimeZone)<br>fmt.Printf(<span class="hljs-string">&quot;Coordinates: %v, %v\n&quot;</span>, record.Location.Latitude, record.Location.Longitude)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">Portuguese (BR) city name: <br>English subdivision name: 英格兰<br>country name: 英国<br>ISO country code: GB<br>Time zone: Europe/London<br>Coordinates: 53.3022, -2.2312<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>golang定义func类型</title>
    <link href="/2023/02/06/golang%E5%AE%9A%E4%B9%89func%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/02/06/golang%E5%AE%9A%E4%B9%89func%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>如下，定义一个DecodeFunc类型，DecodeFunc是一个func([]byte, PacketBuilder)类型，可以通过d(data, p)调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> DecodeFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">([]<span class="hljs-type">byte</span>, PacketBuilder)</span></span> <span class="hljs-type">error</span><br><br><span class="hljs-comment">// Decode implements Decoder by calling itself.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d DecodeFunc)</span></span> Decode(data []<span class="hljs-type">byte</span>, p PacketBuilder) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// function, call thyself.</span><br><span class="hljs-keyword">return</span> d(data, p)<br>&#125;<br><br><span class="hljs-comment">// DecodePayload is a Decoder that returns a Payload layer containing all</span><br><span class="hljs-comment">// remaining bytes.</span><br><span class="hljs-keyword">var</span> DecodePayload Decoder = DecodeFunc(decodePayload)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodePayload</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>, p PacketBuilder)</span></span> <span class="hljs-type">error</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整洁架构项目的随手整理</title>
    <link href="/2023/02/01/%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%9A%8F%E6%89%8B%E6%95%B4%E7%90%86/"/>
    <url>/2023/02/01/%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%9A%8F%E6%89%8B%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="viper库的使用"><a href="#viper库的使用" class="headerlink" title="viper库的使用"></a>viper库的使用</h2><p>在阅读<a href="https://github.com/bxcodec/go-clean-arch%E6%97%B6%EF%BC%8C%E5%8F%91%E7%8E%B0%E4%BA%86viper%E5%BA%93%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%97%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E5%BA%93%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E5%AE%9A%E4%B9%89struct">https://github.com/bxcodec/go-clean-arch时，发现了viper库，这是一个加载配置时使用的库，可以避免定义struct</a></p><h2 id="errgroup"><a href="#errgroup" class="headerlink" title="errgroup"></a>errgroup</h2><p>下面这块的写法可以学习下，来自<a href="https://github.com/bxcodec/go-clean-arch/blob/master/article/usecase/article_ucase.go">https://github.com/bxcodec/go-clean-arch/blob/master/article/usecase/article_ucase.go</a></p><p>这个函数实现的功能就是根据data里数组的各个ID，查询其具体内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *articleUsecase)</span></span> fillAuthorDetails(c context.Context, data []domain.Article) ([]domain.Article, <span class="hljs-type">error</span>) &#123;<br>g, ctx := errgroup.WithContext(c) <span class="hljs-comment">// 当某个goroutine出错后或者传入的c超时了，返回的ctx会被cancel掉</span><br><br><span class="hljs-comment">// Get the author&#x27;s id</span><br>mapAuthors := <span class="hljs-keyword">map</span>[<span class="hljs-type">int64</span>]domain.Author&#123;&#125;<br><br><span class="hljs-keyword">for</span> _, article := <span class="hljs-keyword">range</span> data &#123; <span class="hljs-comment">//nolint</span><br>mapAuthors[article.Author.ID] = domain.Author&#123;&#125;<br>&#125;<br><span class="hljs-comment">// Using goroutine to fetch the author&#x27;s detail</span><br>chanAuthor := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> domain.Author) <span class="hljs-comment">// channel初始化后可以无线接收</span><br><span class="hljs-keyword">for</span> authorID := <span class="hljs-keyword">range</span> mapAuthors &#123;<br>authorID := authorID<br>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-comment">// g.Go开启goroutine</span><br>res, err := a.authorRepo.GetByID(ctx, authorID)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>chanAuthor &lt;- res<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>&#125;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>err := g.Wait() <span class="hljs-comment">// 等待所有查询goroutine执行完毕，查询goroutine并行可以提高速度</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Error(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-built_in">close</span>(chanAuthor) <span class="hljs-comment">// 一定要关闭</span><br>&#125;()<br><br><span class="hljs-keyword">for</span> author := <span class="hljs-keyword">range</span> chanAuthor &#123;<br><span class="hljs-keyword">if</span> author != (domain.Author&#123;&#125;) &#123;<br>mapAuthors[author.ID] = author<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> err := g.Wait(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// merge the author&#x27;s data</span><br><span class="hljs-keyword">for</span> index, item := <span class="hljs-keyword">range</span> data &#123; <span class="hljs-comment">//nolint</span><br><span class="hljs-keyword">if</span> a, ok := mapAuthors[item.Author.ID]; ok &#123;<br>data[index].Author = a<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> data, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据库抽象"><a href="#数据库抽象" class="headerlink" title="数据库抽象"></a>数据库抽象</h2><p>总结起来就是数据库的操作需要抽象成interface，对外提供方法供API端调用</p><p>名字可以参考定义为XXXUsecase，XXX就是关联的数据库模型，比如对文章的操作就是articleUsecase</p><h2 id="启动文件位置"><a href="#启动文件位置" class="headerlink" title="启动文件位置"></a>启动文件位置</h2><p>启动的main.go可以放到单独的目录，比如app目录</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何通过wireshark抓VPN的数据包</title>
    <link href="/2023/01/23/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87wireshark%E6%8A%93VPN%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/"/>
    <url>/2023/01/23/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87wireshark%E6%8A%93VPN%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>当VPN连接建立后，如果你使用ping命令进行网络测试，那么ping的流量将通过VPN网络接口进行传输。这是因为VPN连接会创建一个虚拟网络接口，所有的网络流量都将通过该接口转发到VPN服务器。这样做可以保证网络流量的安全性和隐私性。</p><p>这里举个例子： 假设你的网络接口为eth0，你在连接VPN后，系统会创建一个新的VPN接口，如tun0，在这种情况下，ping的流量将通过tun0接口进行传输。</p><p>注意:</p><ul><li>这只是一般情况，具体情况还要根据你使用的VPN客户端和VPN服务器的配置而定。</li><li>你可以使用命令“ipconfig &#x2F;all”(Windows) 或 “ifconfig”(Linux)来查看你的网络接口。</li></ul><p>比如我未连接VPN前，通过ifconfig查看了所有网络接口。连接了VPN后，通过ifconfig查看了所有网络接口，发现比之前多了一个utun3，那么Wireshark抓包的时候抓这个utun3接口就可以抓到所有VPN的流量。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gopacket的afpacket的介绍和使用</title>
    <link href="/2023/01/01/gopacket%E7%9A%84afpacket%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/01/01/gopacket%E7%9A%84afpacket%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>之前写了篇叫《gopacket源代码阅读》，主要介绍了gopacket的最基本部分的源代码的原理。写完后继续看了下gopacket的其他包的源代码。发现其他包阅读起来没有基本部分的源代码那么轻松也看不太懂了。</p><p>因为examples包下面列出了使用一些包的方法，给出的都是示例的main文件。大概看了一下这些例子，发现了其中一个比较有用的包叫afpacket。</p><p>之前提到gopacket是Google出品的一个<code>PF_RING</code>和<code>AF_PACKET</code>和基于C语言的libpcap的网络数据包抓取和分析包。之前介绍的是基于libpcap的部分，本文介绍当gopacket基于AF_PACKET的情况。而afpacket包正是基于AF_PACKET套接字的实现。</p><p><strong>afpacket 使用 Linux 内核的 <code>AF_PACKET</code> 套接字进行数据包捕获。</strong>此时无需使用gopacket的其他功能。使用时只需要导入afpacket包即可。</p><blockquote><p>Linux 的 AF_PACKET（全称是 “Advanced Packet Socket”）套接字是一种用于在用户空间进行网络数据包捕获和注入的机制。<strong>它允许用户程序直接访问网络设备的数据流，而无需经过内核的协议栈处理。</strong></p></blockquote><p>使用 <code>gopacket</code> 库进行数据包捕获时，你可以选择不同的捕获源，包括 <code>afpacket</code>、<code>pcap</code>、<code>pcapng</code> 等。底层的抓包工具可能是libpcap或者AF_PACKET或者PF_RING。</p><p>afpacket也提供了一种数据包读取的方法，<strong>但是只可以在linux上使用和运行</strong>。和之前使用的如下的数据包读取方法不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">handle, err := pcap.OpenLive(iface.Name, <span class="hljs-number">65536</span>, <span class="hljs-literal">true</span>, pcap.BlockForever)<br>...<br>src := gopacket.NewPacketSource(handle, layers.LayerTypeEthernet)<br>in := src.Packets()<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">var</span> packet gopacket.Packet<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-stop:<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> packet = &lt;-in:<br>      <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>afpacket的使用方法可以参考这个文件：</p><p><img src="/../images/image-20240508172047843.png" alt="image-20240508172047843"></p><p>我模仿这个文件，写了统计网卡总流量大小的一个程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;os/signal&quot;</span><br><span class="hljs-string">&quot;sync/atomic&quot;</span><br><span class="hljs-string">&quot;syscall&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/google/gopacket&quot;</span><br><span class="hljs-string">&quot;github.com/google/gopacket/afpacket&quot;</span><br><span class="hljs-string">&quot;github.com/google/gopacket/pcap&quot;</span><br><span class="hljs-string">&quot;github.com/google/gopacket/pcapgo&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>device := <span class="hljs-string">&quot;lo&quot;</span><br>bufferSize := <span class="hljs-number">88</span><br>snaplen := <span class="hljs-number">65535</span><br>addVLAN := <span class="hljs-literal">true</span><br>szFrame, szBlock, numBlocks, err := afpacketComputeSize(bufferSize, snaplen, os.Getpagesize())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>afpacketHandle, err := newAfpacketHandle(device, szFrame, szBlock, numBlocks, addVLAN, pcap.BlockForever)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>source := gopacket.ZeroCopyPacketDataSource(afpacketHandle)<br><span class="hljs-keyword">defer</span> afpacketHandle.Close()<br>f, _ := os.Create(<span class="hljs-string">&quot;test.pcap&quot;</span>)<br><span class="hljs-keyword">defer</span> f.Close()<br>w := pcapgo.NewWriter(f)<br>handle, _ := pcap.OpenLive(device, <span class="hljs-type">int32</span>(snaplen), <span class="hljs-literal">true</span>, <span class="hljs-number">-1</span>*time.Second)<br>w.WriteFileHeader(<span class="hljs-type">uint32</span>(snaplen), handle.LinkType())<br><span class="hljs-keyword">defer</span> handle.Close()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>data, meta, err := source.ZeroCopyReadPacketData()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>w.WritePacket(meta, data)<br>Add(<span class="hljs-type">uint64</span>(meta.CaptureLength))<br>&#125;<br>&#125;()<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)<br>signal.Notify(c, os.Interrupt, syscall.SIGTERM)<br>&lt;-c<br>fmt.Println(<span class="hljs-string">&quot;.......Read().............&quot;</span>, Read())<br>&#125;<br><br><span class="hljs-keyword">type</span> AtomicCounter <span class="hljs-keyword">struct</span> &#123;<br>number <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-keyword">var</span> Counter *AtomicCounter<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>Counter = &amp;AtomicCounter&#123;<span class="hljs-number">0</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(num <span class="hljs-type">uint64</span>)</span></span> &#123;<br>atomic.AddUint64(&amp;Counter.number, num)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Read</span><span class="hljs-params">()</span></span> <span class="hljs-type">uint64</span> &#123;<br><span class="hljs-keyword">return</span> atomic.LoadUint64(&amp;Counter.number)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">afpacketComputeSize</span><span class="hljs-params">(targetSizeMb <span class="hljs-type">int</span>, snaplen <span class="hljs-type">int</span>, pageSize <span class="hljs-type">int</span>)</span></span> (<br>frameSize <span class="hljs-type">int</span>, blockSize <span class="hljs-type">int</span>, numBlocks <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-keyword">if</span> snaplen &lt; pageSize &#123;<br>frameSize = pageSize / (pageSize / snaplen)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>frameSize = (snaplen/pageSize + <span class="hljs-number">1</span>) * pageSize<br>&#125;<br><br><span class="hljs-comment">// 128 is the default from the gopacket library so just use that</span><br>blockSize = frameSize * <span class="hljs-number">128</span><br>numBlocks = (targetSizeMb * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) / blockSize<br><br><span class="hljs-keyword">if</span> numBlocks == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;Interface buffersize is too small&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">return</span> frameSize, blockSize, numBlocks, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">type</span> afpacketHandle <span class="hljs-keyword">struct</span> &#123;<br>TPacket *afpacket.TPacket<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newAfpacketHandle</span><span class="hljs-params">(device <span class="hljs-type">string</span>, snaplen <span class="hljs-type">int</span>, block_size <span class="hljs-type">int</span>, num_blocks <span class="hljs-type">int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">useVLAN <span class="hljs-type">bool</span>, timeout time.Duration)</span></span> (*afpacketHandle, <span class="hljs-type">error</span>) &#123;<br><br>h := &amp;afpacketHandle&#123;&#125;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><br><span class="hljs-keyword">if</span> device == <span class="hljs-string">&quot;any&quot;</span> &#123;<br>h.TPacket, err = afpacket.NewTPacket(<br>afpacket.OptFrameSize(snaplen),<br>afpacket.OptBlockSize(block_size),<br>afpacket.OptNumBlocks(num_blocks),<br>afpacket.OptAddVLANHeader(useVLAN),<br>afpacket.OptPollTimeout(timeout),<br>afpacket.SocketRaw,<br>afpacket.TPacketVersion3)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>h.TPacket, err = afpacket.NewTPacket(<br>afpacket.OptInterface(device),<br>afpacket.OptFrameSize(snaplen),<br>afpacket.OptBlockSize(block_size),<br>afpacket.OptNumBlocks(num_blocks),<br>afpacket.OptAddVLANHeader(useVLAN),<br>afpacket.OptPollTimeout(timeout),<br>afpacket.SocketRaw,<br>afpacket.TPacketVersion3)<br>&#125;<br><span class="hljs-keyword">return</span> h, err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *afpacketHandle)</span></span> ZeroCopyReadPacketData() (data []<span class="hljs-type">byte</span>, ci gopacket.CaptureInfo, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> h.TPacket.ZeroCopyReadPacketData()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *afpacketHandle)</span></span> Close() &#123;<br>h.TPacket.Close()<br>&#125;<br></code></pre></td></tr></table></figure><p>我这个程序是统计了所有的数据包的总流量。测试时是使用iperf3打流测试的，但是不知道为何，程序统计出来的流量几乎是iperf3显示的2倍，正确的结果应该是程序统计出来的和iperf3的差不多。</p><p>然后将程序抓到的数据包存到pcap文件，查看该pcap文件，同时通过tcpdump将对应网卡抓到的数据包存储到pcap文件，对比这两个pcap文件。发现程序抓到的文件多捕获到了重传的数据包：</p><p><img src="/../images/image-20240510140703339.png" alt="image-20240510140703339"></p><p><img src="/../images/image-20240510140757863.png" alt="image-20240510140757863"></p><p>至于为什么程序里的AF_PACKET会抓到重传的数据包，我没有找到原因。</p><hr><p>NewTPacket的源代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTPacket</span><span class="hljs-params">(opts ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (h *TPacket, err <span class="hljs-type">error</span>) &#123;<br>h = &amp;TPacket&#123;&#125;<br><span class="hljs-keyword">if</span> h.opts, err = parseOptions(opts...); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>fd, err := unix.Socket(unix.AF_PACKET, <span class="hljs-type">int</span>(h.opts.socktype), <span class="hljs-type">int</span>(htons(unix.ETH_P_ALL)))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>h.fd = fd<br><span class="hljs-keyword">if</span> err = h.bindToInterface(h.opts.iface); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">goto</span> errlbl<br>&#125;<br><span class="hljs-keyword">if</span> err = h.setRequestedTPacketVersion(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">goto</span> errlbl<br>&#125;<br><span class="hljs-keyword">if</span> err = h.setUpRing(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">goto</span> errlbl<br>&#125;<br><span class="hljs-comment">// Clear stat counter from socket</span><br><span class="hljs-keyword">if</span> err = h.InitSocketStats(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">goto</span> errlbl<br>&#125;<br>runtime.SetFinalizer(h, (*TPacket).Close)<br><span class="hljs-keyword">return</span> h, <span class="hljs-literal">nil</span><br>errlbl:<br>h.Close()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br></code></pre></td></tr></table></figure><p>这里源代码的重点就是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unix.Socket(unix.AF_PACKET, int(h.opts.socktype), int(htons(unix.ETH_P_ALL)))<br></code></pre></td></tr></table></figure><p>这一行</p><p>AF_PACKET实现了数据链路层的raw socket，ETH_P_ALL可以匹配所有类型的以太网帧，也就是这里可以捕获到所有的以太网帧。</p><p>AF_PACKET raw soket的能力如下：</p><ul><li>能接收发往本地mac的数据帧</li><li>能接收从本机发送出去的数据帧(<strong>第3个参数需要设置为ETH_P_ALL</strong>才行)</li><li>接收非发往本地mac的数据帧(网卡需要设置为promisc混杂模式)</li></ul><p>第二个参数可以传递SOCK_RAW或者SOCK_DGRAM</p><ul><li>SOCK_RAW ： 用户接收的数据包将包含链路层的协议头(即Ethernet 帧头)， 发送数据时， 用户需要填充链路层的协议头(即Ethernet 帧头)</li><li>SOCK_DGRAM ： 用户接收&#x2F;发送的数据包都不包含链路层的协议头(即Ethernet 帧头)， 发送数据时， 用户指定的物理层地址只是作为参考， kernel将自动填充合适的物理层地址</li></ul><p>以一个udp数据包为例</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">14byte            20byte      8byte        100byte  4byte</span><br><span class="hljs-section">+-----------------+-----------+------------+--------+-----+</span><br><span class="hljs-section">| Ethernet Header | ip header | udp header |  data  | fcs |</span><br><span class="hljs-section">+-----------------+-----------+------------+--------+-----+</span><br></code></pre></td></tr></table></figure><ul><li>SOCK_RAW 可以接收到 Ethernet header + ip header + udp header + data 即 (14 + 20 + 8 + 100 byte)</li><li>SOCK_DGRAM 可以接收到 ip header + udp header + data 即 (20 + 8 + 100 byte)</li></ul><p>第二个参数默认情况下传递的值是 SOCK_RAW。</p><p>AF_PACKET 协议族的socket需要指定protocol， 也就是第三个参数，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP))<br>socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ARP))<br>socket(PF_PACKET, SOCK_RAW, htons(ETH_P_EAPOL))<br>socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))<br></code></pre></td></tr></table></figure><p>任何网络协议的代码， 都可以通过 dev_add_pack() 来注册一个 struct packet_type， 来声明其感兴趣的以太网帧，感兴趣的网络设备接口， 以及对应的处理函数。比如ETH_P_IP、ETH_P_ARP、ETH_P_EAPOL、ETH_P_ALL都有对应的处理函数。</p><blockquote><ul><li>ip协议栈注册了一个名为“ip_packet_type” 的结构体，关注类型为 ETH_P_IP的以太网帧, 处理处理函数为 ip_rcv()</li><li>arp协议注册了一个名为“arp_packet_type” 的结构体，关注类型为 ETH_P_ARP的以太网帧, 处理函数为arp_rcv()</li></ul><p>在 Linux 内核中，ETH_P_ALL 是一个特殊的以太网类型，用于捕获所有传入的以太网帧，而不管它们的协议类型是什么。当注册了一个 ETH_P_ALL 类型的以太网帧时，操作系统的网络协议栈会接收所有传入的以太网帧，并将它们传递给注册的处理函数进行处理。注册 ETH_P_ALL 类型的以太网帧的处理函数可以是一个称为 “eth_rcv()” 或类似名称的函数。这个函数负责接收所有传入的以太网帧，并将它们传递给适当的协议处理程序，或者进一步处理它们</p></blockquote><p> <strong>tcpdump就使用了 AF_PACKET raw socket</strong></p><p>我的理解：拿AF_PACKET举例，每个数据包都有自己的类型，比如有的数据包类型是ETH_P_IP，可能表示其有IP层，有的数据包类型是ETH_P_ARP，可能表明其有以太网层的数据。应该每个数据包不止有一个类型，应该差不多每个数据包都包含了ETH_P_ALL类型。所以当某个结构体关注了ETH_P_ALL类型的以太网帧时，会有对应的处理函数，处理函数一般是读取以太网帧。</p><p>参考文章：</p><p><a href="https://medium.com/@pavel.odintsov/capturing-packets-in-linux-at-a-speed-of-millions-of-packets-per-second-without-using-third-party-ef782fe8959d">https://medium.com/@pavel.odintsov/capturing-packets-in-linux-at-a-speed-of-millions-of-packets-per-second-without-using-third-party-ef782fe8959d</a></p><p><a href="https://gist.github.com/pavel-odintsov/c2154f7799325aed46ae">https://gist.github.com/pavel-odintsov/c2154f7799325aed46ae</a></p><p><a href="https://worktile.com/kb/ask/430068.html">https://worktile.com/kb/ask/430068.html</a></p><p><a href="https://lishiwen4.github.io/network/raw-socket">https://lishiwen4.github.io/network/raw-socket</a></p><p> <a href="https://lishiwen4.github.io/page10/">https://lishiwen4.github.io/page10/</a></p><p><a href="https://lishiwen4.github.io/network/netfilter">https://lishiwen4.github.io/network/netfilter</a></p><p><a href="https://lishiwen4.github.io/network/socket-interface-and-network-protocol">https://lishiwen4.github.io/network/socket-interface-and-network-protocol</a></p><p><a href="https://www.opensourceforu.com/2015/03/a-guide-to-using-raw-sockets/">https://www.opensourceforu.com/2015/03/a-guide-to-using-raw-sockets/</a> </p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gopher-lua使用与简介</title>
    <link href="/2023/01/01/gopher-lua%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/01/01/gopher-lua%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>GopherLua是一个用Go写的lua虚拟机和编译器。GopherLua提供了API，可以让你轻松将lua脚本嵌入Go主机主机程序中。GopherLua目标是成为具有可扩展语义的脚本语言。</p><p>github地址为：<a href="https://github.com/yuin/gopher-lua#installation">https://github.com/yuin/gopher-lua#installation</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get github.com/yuin/gopher-lua<br></code></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="直接运行lua命令"><a href="#直接运行lua命令" class="headerlink" title="直接运行lua命令"></a>直接运行lua命令</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> lua <span class="hljs-string">&quot;github.com/yuin/gopher-lua&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>L := lua.NewState()<br><span class="hljs-keyword">defer</span> L.Close()<br><span class="hljs-keyword">if</span> err := L.DoString(<span class="hljs-string">`print(&quot;hello&quot;)`</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">go run .      <br>hello<br></code></pre></td></tr></table></figure><h3 id="运行lua文件"><a href="#运行lua文件" class="headerlink" title="运行lua文件"></a>运行lua文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> lua <span class="hljs-string">&quot;github.com/yuin/gopher-lua&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>L := lua.NewState()<br><span class="hljs-keyword">defer</span> L.Close()<br><span class="hljs-keyword">if</span> err := L.DoFile(<span class="hljs-string">&quot;hello.lua&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>hello.lua的内容为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>下面介绍如何向lua程序传递参数和接收参数</p><p>所有GopherLua里的数据都是一个LValue类型的值。LValue有以下方法可以调用：</p><ul><li><code>String() string</code></li><li><code>Type() LValueType</code></li></ul><p>LValue类型是一个interface，有很多类型实现了该interface，比如LNilType、LBool、LNumber、LString、LFunction、LUserData、LState、LTable、LChannel等等</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>netfilter框架和网络相关的一些总结（比较乱）</title>
    <link href="/2023/01/01/netfilter%E6%A1%86%E6%9E%B6%E5%92%8C%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%EF%BC%88%E6%AF%94%E8%BE%83%E4%B9%B1%EF%BC%89/"/>
    <url>/2023/01/01/netfilter%E6%A1%86%E6%9E%B6%E5%92%8C%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%EF%BC%88%E6%AF%94%E8%BE%83%E4%B9%B1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>参考文章 <a href="https://www.thebyte.com.cn/">https://www.thebyte.com.cn/</a></p><p><img src="/../images/image-20240226160531038.png" alt="image-20240226160531038"></p><p>Netfilter 实际上就是一个过滤器框架，Netfilter 在网络包收发以及路由的“管道”中，一共切了 5 个口（hook），分别是 PREROUTING、FORWARD、POSTROUTING、INPUT 以及 OUTPUT，其它内核模块(例如 iptables、IPVS 等)可以向这些 hook 点注册处理函数。每当有数据包留到网络层，就会自动触发内核模块注册在这里的回调函数，这样程序代码就能够通过回调函数来干预 Linux 的网络通信，进而实现对数据包过滤、修改、SNAT&#x2F;DNAT 等各类功能。</p><blockquote><ul><li><strong>PREROUTING:</strong> 接收到的包进入协议栈后立即触发此链，在进行任何路由判断（将包发往哪里）之前。</li><li><strong>INPUT:</strong> 接收到的包经过路由判断，如果目的是本机，将触发此链。</li><li><strong>FORWARD</strong> 接收到的包经过路由判断，如果目的是其他机器，将触发此链。</li><li><strong>OUTPUT:</strong> 本机产生的准备发送的包，在进入协议栈后立即触发此链。</li><li><strong>POSTROUTING:</strong> 本机产生的准备发送的包或者转发的包，在经过路由判断之后，将触发此链。</li></ul></blockquote><p>Linux 网络协议栈的处理是一套相对固定和封闭的流程，整套处理过程中，除了网络设备层能看到一点点程序以设备的形式介入处理的空间外，其他过程似乎就没有什么可提供程序插手的空间了。然而事实并非如此，</p><p>从 Linux 内核 2.4 版本起，内核就开放了一套通用的，可提供代码干预数据在协议栈流转的过滤框架 – Netfilter</p><p>iptables通常是系统自带的防火墙，</p><p>支持RSS的网卡数据并行能力的优化：</p><p>如果在多核 CPU 的服务器上，网卡内部会有多个 Ring Buffer，网卡负责将传进来的数据分配给不同的 Ring Buffer，同时触发的中断也可以分配到多个 CPU 上处理，这样存在多个 Ring Buffer 的情况下 Ring Buffer 缓存的数据也同时被多个 CPU 处理，就能提高数据的并行处理能力。</p><p>要实现“网卡负责将传进来的数据分配给不同的 Ring Buffer”，网卡必须支持 Receive Side Scaling(RSS) 或者叫做 multiqueue 的功能。</p><p>查看网卡是否支持RSS：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ethtool -k  eth0|grep receive-hashing<br>receive-hashing: off [fixed]<br></code></pre></td></tr></table></figure><p>这是我的输出结果。 <code>off</code> 表示接收哈希功能被禁用，而 <code>[fixed]</code> 表示该参数是固定的，无法通过修改网卡的配置来改变。</p><p>如果支持，可以参考<a href="https://www.thebyte.com.cn/network/RSS.html#_2-2-%E9%98%9F%E5%88%97%E5%A4%A7%E5%B0%8F%E8%B0%83%E6%95%B4">链接</a>进行RSS的多队列调整和队列大小调整。</p><p>由于 TCP 双全工的特性，安全关闭一个连接需要四次挥手，如图 3-17 所示。但复杂的网络环境中存在很多异常情况，异常断开连接会导致产生“孤儿连”，<strong>这种连接既不能发送数据，也无法接收数据，累计过多，会消耗大量系统资源，资源不足时产生 Address already in use: connect 类似的错误。</strong></p><p>也可以调整一些和TCP握手挥手相关的配置，参考<a href="https://www.thebyte.com.cn/network/netstack-performance.html">文章</a></p><p>高并发下网络协议栈的冗长流程是最主要的性能负担，也就是说<strong>内核才是高并发的瓶颈所在。</strong></p><p>应用程序比如浏览器、电子邮件、文件传输服务器等产生的数据，会通过传输层协议进行传输，而应用程序是不会和传输层直接建立联系的，而是有一个能够连接应用层和传输层之间的套件，这个套件就是 <code>Socket</code>。</p><p><code>netstat</code>命令用于显示所有的IP。从netstat命令可以看出，一个套接字就是五元组（协议、本地地址、外部地址、状态、PID）。有的时候也被叫做四元组，四元组不包括协议。</p><p>How does the AF_PACKET socket work in Linux?：<a href="https://stackoverflow.com/questions/62866943/how-does-the-af-packet-socket-work-in-linux">https://stackoverflow.com/questions/62866943/how-does-the-af-packet-socket-work-in-linux</a></p><p><a href="https://stackoverflow.com/questions/829455/iptables-and-libpcap%EF%BC%9A">https://stackoverflow.com/questions/829455/iptables-and-libpcap：</a></p><p>Yes, libpcap sees all the packets.. They are being captured before being processed by the netfilter.</p><p><a href="https://superuser.com/questions/925286/does-tcpdump-bypass-iptables%EF%BC%9A">https://superuser.com/questions/925286/does-tcpdump-bypass-iptables：</a></p><p>tcpdump的运行路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Wire -&gt; NIC -&gt; tcpdump -&gt; netfilter/iptables<br><br>iptables -&gt; tcpdump -&gt; NIC -&gt; Wire<br></code></pre></td></tr></table></figure><p>也许我应该添加一些细节。 tcpdump 基于 libpcap，一个创建数据包套接字的库。 当网络堆栈中收到常规数据包时，内核首先检查是否存在对新到达的数据包感兴趣的数据包套接字，如果有，则将数据包转发到该数据包套接字。 如果选择 ETH_P_ALL 选项，则所有协议都通过数据包套接字。</p><p>libpcap 实现了一个这样的数据包套接字，并激活了该选项，保留一份副本供自己使用，并将数据包复制回网络堆栈，由内核以通常的方式处理，包括首先将其传递给内核 netfilter -space 与 iptables 相对应。 同样的事情，以相反的顺序（即，第一个网络过滤器，然后最后一个通过数据包套接字的通道），在出去。</p><p>这容易被黑客攻击吗？ 但是当然。 当然，有一些概念验证的 Rootkit 使用 libpcap 在防火墙攻击它们之前拦截发往 Rootkit 的通信。 但即便如此，与一个简单的 Google 查询甚至可以从 libpcap 中挖掘出隐藏流量的工作代码这一事实相比，这还是相形见绌的。 尽管如此，大多数专业人士认为在调试网络数据包过滤器时优点远远超过缺点。</p><p>AF_PACKET 是面向链路层的套接字</p><p>同一个计算机中不同的程序会和同一个TCP&#x2F;IP协议的端口交互，为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP&#x2F;IP协议交互提供了称为套接字(Socket)的接口。</p><p>linux以文件的形式实现套接口，与套接口相应的文件属于sockfs特殊文件系统，创建一个套接口就是在sockfs中创建一个特殊文件，并建立起为实现套接口功能的相关数据结构。换句话说，对每一个新创建的套接字，linux内核都将在sockfs特殊文件系统中创建一个新的inode。</p><p>套接字有本地套接字和网络套接字两种。本地套接字的名字是Linux文件系统中的文件名，一般放在&#x2F;tmp或&#x2F;usr&#x2F;tmp目录中；网络套接字的名字是与客户连接的特定网络有关的服务标识符（端口号或访问点）。这</p><p>常用的TCP&#x2F;IP协议的3种套接字类型如下所示：</p><p>流套接字（SOCK_STREAM）：流套接字用于提供面向连接、可靠的数据传输服务。流套接字之所以能够实现可靠的数据服务，原因在于其使用了传输控制协议，即TCP（The Transmission Control Protocol）协议。</p><p>数据报套接字（SOCK_DGRAM）：数据报套接字提供了一种无连接的服务。该服务并不能保证数据传输的可靠性，数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。数据报套接字使用UDP（User Datagram Protocol）协议进行数据的传输。</p><p>原始套接字（SOCK_RAW）：允许对较低层次的协议直接访问，比如IP、 ICMP协议</p><p>用户使用socket系统调用编写应用程序时，通过一个数字来表示一个socket，所有的操作都在该数字上进行，这个数字称为<strong>套接字描述符</strong>。</p><p>基本接口函数：</p><p>创建套接字的函数socket( )，可以指定不同的参数创建不同的socket描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">( <span class="hljs-type">int</span> domain,   <span class="hljs-comment">/*  创建的套接字的协议族, AF_XXX */</span></span><br><span class="hljs-params">            <span class="hljs-type">int</span> type,     <span class="hljs-comment">/*  创建的套接字的类型, SOCK_XXX  */</span></span><br><span class="hljs-params">            <span class="hljs-type">int</span> protocol)</span>;<span class="hljs-comment">/* 创建的套接字的协议，与type有关  */</span><br></code></pre></td></tr></table></figure><p>domain表示协议族，常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</p><p>type，指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</p><p>protocol，故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。</p><p>通过socket调用创建的套接字必须经过命名（绑定地址）后才能使用。</p><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket。<br>如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p><p>参考</p><p><a href="https://blog.csdn.net/gatieme/article/details/46241975">https://blog.csdn.net/gatieme/article/details/46241975</a></p><p><a href="https://lishiwen4.github.io/network/raw-socket">https://lishiwen4.github.io/network/raw-socket</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>tcpdump是如何抓包的</title>
    <link href="/2023/01/01/tcpdump%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%93%E5%8C%85%E7%9A%84/"/>
    <url>/2023/01/01/tcpdump%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%93%E5%8C%85%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>在网络的发送和接收过程中，绝大部分工作都是在内核态完成的。那么用户使用的tcpdump是如何抓到内核态的包的呢？</p><p> tcpdump 是基于 libpcap 实现的，golang中用于分析网络数据包的gopacket库也是基于libpcap 写的。libpcap是一个网络数据包捕获框架，是用C语言写的。</p><p>在开始研究tcpdump之前，需要知道网络包是如何从网卡到达用户进程的。即数据包的接收流程。</p><h2 id="Linux网络数据包接收流程"><a href="#Linux网络数据包接收流程" class="headerlink" title="Linux网络数据包接收流程"></a>Linux网络数据包接收流程</h2><blockquote><p>具体可以看<a href="https://cloud.tencent.com/developer/article/1966873">原文</a>，本文只对原文做了小总结，原文涉及到了源代码分析，比较详细但是难懂。</p></blockquote><p>Linux视角的网络协议栈可以参考下图：</p><p><img src="/../images/image-20240227171206638.png" alt="image-20240227171206638"></p><p>该图总结起来就是：链路层协议靠网卡驱动来实现，内核协议栈实现了网络层和传输层。负责这两层的内核会提供socket接口来供更上层也就是用户进程来访问。</p><p>内核收包的路径示意图：</p><p><img src="/../images/image-20240229110320205.png" alt="image-20240229110320205"></p><p>注意3和4的两次中断，分别是硬中断和软中断</p><p>这个图总结起来就是：当网卡上收到数据以后，Linux中第一个工作的模块是网络驱动。网络驱动会以DMA的方式把网卡上收到的帧写到内存里。再向CPU发起一个中断，以通知CPU有数据到达。第二，当CPU收到中断请求后，会去调用网络驱动注册的中断处理函数。网卡的中断处理函数并不做过多工作，发出软中断请求，然后尽快释放CPU。<strong>ksoftirqd检测到有软中断请求到达，调用poll开始轮询收包</strong>，收到后交由各级协议栈处理。对于UDP包来说，会被放到用户socket的接收队列中。</p><p>用另一张更简洁的图总结，如下：</p><p><img src="/../images/image-20240229143443817.png" alt="image-20240229143443817"></p><p>这个过程可以用下面这个图概括：</p><p><img src="/../images/image-20240227165648231.png" alt="image-20240227165648231"></p><p>这个图描述了数据包进入系统后的流程。</p><hr><p>ethtool命令之所以能查看网卡收发包统计、能修改网卡自适应模式、能调整RX 队列的数量和大小，是因为ethtool命令最终调用到了网卡驱动的相应方法，而不是ethtool本身有这个超能力</p><p>在数据包分析中，DMA 功能通常与网络接口卡（NIC）结合使用，用于将网络数据包直接传输到内存中，而无需 CPU 参与每个数据包的传输过程。</p><p><strong>本文总结下来大概就是：</strong></p><p>首先在开始收包之前，Linux要做许多的准备工作：</p><ul><li>创建ksoftirqd线程，为它设置好它自己的线程函数，后面指望着它来处理软中断呢</li><li>协议栈注册，linux要实现许多协议，比如arp，icmp，ip，udp，tcp，每一个协议都会将自己的处理函数注册一下，方便包来了迅速找到对应的处理函数</li><li>网卡驱动初始化，每个驱动都有一个初始化函数，内核会让驱动也初始化一下。在这个初始化过程中，把自己的DMA准备好，把NAPI的poll函数地址告诉内核</li><li>启动网卡，分配RX，TX队列，注册中断对应的处理函数</li></ul><p>以上是内核准备收包之前的重要工作，当上面都ready之后，就可以打开硬中断，等待数据包的到来了。</p><p>当数据到来了以后，第一个迎接它的是网卡（我去，这不是废话么）：</p><ul><li>网卡将数据帧DMA到内存的RingBuffer中，然后向CPU发起中断通知</li><li>CPU响应中断请求，调用网卡启动时注册的中断处理函数</li><li>中断处理函数几乎没干啥，就发起了软中断请求</li><li>内核线程ksoftirqd线程发现有软中断请求到来，先关闭硬中断</li><li>ksoftirqd线程开始调用驱动的poll函数收包</li><li>poll函数将收到的包送到协议栈注册的ip_rcv函数中</li><li>ip_rcv函数再讲包送到udp_rcv函数中（对于tcp包就送到tcp_rcv）</li></ul><p>Linux收一个包的开销包括：首先第一块是用户进程调用系统调用陷入内核态的开销。第二块是CPU响应包的硬中断的CPU开销。第三块是ksoftirqd内核线程的软中断上下文花费的。</p><h2 id="tcpdump是如何抓到数据包的"><a href="#tcpdump是如何抓到数据包的" class="headerlink" title="tcpdump是如何抓到数据包的"></a>tcpdump是如何抓到数据包的</h2><blockquote><p>可以看<a href="https://www.eet-china.com/mp/a78228.html">原文</a>，原文涉及到了很多源代码解析，很详细，但是有点难懂。</p></blockquote><p>网络包的接收和发送，大部分都是在内核中完成的。</p><p>用户态的 tcpdump 挂载协议到内 ptype_all 上</p><p><strong>tcpdump是如何工作的：</strong></p><p><strong>用户态 tcpdump 命令是通过 socket 系统调用，在内核源码中用到的 ptype_all 中挂载了函数钩子上去。</strong>无论是在网络包接收过程中，还是在发送过程中，都会在网络设备层遍历 ptype_all 中的协议，并执行其中的回调。tcpdump 命令就是基于这个底层原理来工作的。</p><p><strong>netfilter 过滤的包 tcpdump是否可以抓的到？</strong></p><p>关于这个问题，得分接收和发送过程分别来看。在网络包接收的过程中，由于 tcpdump 近水楼台先得月，所以完全可以捕获到命中 netfilter 过滤规则的包。</p><p><img src="/../images/MBXY-CR-f6de712d96114cc62a0e21cc4cb49503.png" alt="img"></p><p>但是在发送的过程中，恰恰相反。网络包先经过协议层，这时候被 netfilter 过滤掉的话，底层工作的 tcpdump 还没等看见就啥也没了。</p><p><img src="/../images/MBXY-CR-e1c911d4778cc70223c44b341b2da1f7.png" alt="img"></p><p>数据包进入OS及出去的顺序：</p><p><code>网卡nic</code> -&gt; <code>tcpdump</code> -&gt; <code>iptables(netfilter)</code> -&gt; <code>app</code> -&gt; <code>iptables(netfilter)</code> -&gt; <code>tcpdump</code> -&gt; <code>网卡nic</code></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编写中，未定稿</title>
    <link href="/2023/01/01/%EF%BC%88%E6%AD%A3%E5%9C%A8%E7%BC%96%E5%86%99%E4%B8%AD%EF%BC%89gin%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2023/01/01/%EF%BC%88%E6%AD%A3%E5%9C%A8%E7%BC%96%E5%86%99%E4%B8%AD%EF%BC%89gin%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>我把代码复制到了 ~&#x2F;我的本地文件&#x2F;代码&#x2F;fromweb 目录下了。目前clone了gin项目和go-gin-example项目，此外还有example项目，这个是gin官方提供的示例项目。</p><p>##go-gin-example阅读</p><p>读取配置和数据库初始化的过程，可以放在func init() 里，参考：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>setting.Setup() <span class="hljs-comment">// 读取配置文件的所有部分，并对申明好了的全局配置变量赋值</span><br>models.Setup() <span class="hljs-comment">// 初始化mysql db，并自定义了Create Update Delete时的回调函数</span><br>logging.Setup() <span class="hljs-comment">// 初始化日志，是基于标准库里面的日志包初始化的</span><br>gredis.Setup() <span class="hljs-comment">// 初始化redis，包括设置连接redis时会调用的Dial函数</span><br>util.Setup() <span class="hljs-comment">// 设置pkg包里jwtSecret的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>init已经看完了，下面就是看 routers.InitRouter() 的具体内容</p><p>准备看   r.POST(“&#x2F;auth”, api.GetAuth) 及之后的内容了。</p><p>项目里使用到了<a href="https://github.com/beego/beego%E6%A1%86%E6%9E%B6%EF%BC%8C%E7%94%A8%E4%BA%86%E5%85%B6validation%E5%8C%85%E5%81%9A%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81%EF%BC%8C%E5%85%B6%E4%BB%96%E7%9A%84%E5%8C%85%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E3%80%82">https://github.com/beego/beego框架，用了其validation包做数据验证，其他的包没有使用。</a></p><blockquote><p>beego框架可以用于开发包括传统的 Web 网站、API 服务、后台管理系统</p></blockquote><p>validation包的使用方法可以参考：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> auth <span class="hljs-keyword">struct</span> &#123;<br>Username <span class="hljs-type">string</span> <span class="hljs-string">`valid:&quot;Required; MaxSize(50)&quot;`</span> <span class="hljs-comment">// 这个地方要遵循 validation 的语法</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`valid:&quot;Required; MaxSize(50)&quot;`</span><br>&#125;<br>a := auth&#123;Username: username, Password: password&#125;<br>ok, _ := valid.Valid(&amp;a)<br></code></pre></td></tr></table></figure><p>用到了<a href="https://github.com/unknwon/com%E5%8C%85%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%98%AF%E9%92%88%E5%AF%B9">https://github.com/unknwon/com包，这个是针对</a> Go 编程语言常用函数的开源项目。</p><p>router目录存放了rest api的路由定义和rest api的rest部分，而且router的目录结构和路由的结构也是一样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├── api<br>│   ├── auth.go<br>│   ├── upload.go<br>│   └── v1<br>│       ├── article.go<br>│       └── tag.go<br>└── router.go<br></code></pre></td></tr></table></figure><p>已经读完了，笔记都记录在了项目里，没有记录在这个文档里面</p><h2 id="gin源代码阅读"><a href="#gin源代码阅读" class="headerlink" title="gin源代码阅读"></a>gin源代码阅读</h2><p>我电脑上gin的储存位置为<code> ~/MyLocalFile/代码/fromweb/gopacket-fram</code>，改名是为了上班时看便于伪装，这个项目里记录了我阅读时的笔记记录。</p><p>gin是一个知名的HTTP web框架。</p><p>对于gin的调用处一般都是这样写的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>gin.SetMode(setting.ServerSetting.RunMode)<br><br>routersInit := routers.InitRouter() <span class="hljs-comment">// 注意</span><br>readTimeout := setting.ServerSetting.ReadTimeout<br>writeTimeout := setting.ServerSetting.WriteTimeout<br>endPoint := fmt.Sprintf(<span class="hljs-string">&quot;:%d&quot;</span>, setting.ServerSetting.HttpPort)<br>maxHeaderBytes := <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span><br>server := &amp;http.Server&#123;<br>Addr:           endPoint,<br>Handler:        routersInit,<br>ReadTimeout:    readTimeout,<br>WriteTimeout:   writeTimeout,<br>MaxHeaderBytes: maxHeaderBytes,<br>&#125;<br><br>log.Printf(<span class="hljs-string">&quot;[info] start http server listening %s&quot;</span>, endPoint)<br>server.ListenAndServe()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitRouter</span><span class="hljs-params">()</span></span> *gin.Engine &#123;<br>r := gin.New()<br>apiv1 := r.Group(<span class="hljs-string">&quot;/api/v1&quot;</span>)<br>apiv1.Use(jwt.JWT())<br>&#123;<br><span class="hljs-comment">//获取标签列表</span><br>apiv1.GET(<span class="hljs-string">&quot;/tags&quot;</span>, v1.GetTags)<br>    <span class="hljs-comment">// ....</span><br><span class="hljs-comment">//生成文章海报</span><br>apiv1.POST(<span class="hljs-string">&quot;/articles/poster/generate&quot;</span>, v1.GenerateArticlePoster)<br>&#125;<br><span class="hljs-keyword">return</span> r<br>&#125;<br></code></pre></td></tr></table></figure><p>gin项目没有main.go文件，其实：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以理解为通常的入口文件。</p><p>返回的Engine实现了http的ServeHTTP方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>ServeHTTP(ResponseWriter, *Request)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>gin官方提供了一个example项目，<a href="https://github.com/gin-gonic/examples%EF%BC%8C%E9%87%8C%E9%9D%A2%E5%88%97%E4%B8%BE%E4%BA%86%E4%B8%80%E4%BA%9Bgin%E7%9A%84%E7%94%A8%E6%B3%95">https://github.com/gin-gonic/examples，里面列举了一些gin的用法</a></p></blockquote><p>go:build 是一个编译指令（build constraint），用于在不同的Go版本或操作系统之间条件编译代码。<code>!go1.20</code>表示如果Go版本小于1.20，那么以下代码块将会被编译，否则将被忽略。<code>go1.20</code> 表示如果Go版本等于1.20或更高，那么以下代码块将会被编译，否则将被忽略。</p><p>golang有个类型是any，是原生的，其作用和interface相同，其实是interface的别名</p><p>1.16更新</p><p>看关于cleanPath的实现</p><p><img src="/../images/image-20240116143401223.png" alt="image-20240116143401223"></p><h2 id="进度记录"><a href="#进度记录" class="headerlink" title="进度记录"></a>进度记录</h2><p>1.18准备看这个tree.go文件</p><p><img src="/../images/image-20240118150735607.png" alt="image-20240118150735607"></p><p>还是在看tree相关的</p><blockquote><p>gin的路由功能使用了“前缀树“的数据结构</p><p><a href="https://cloud.tencent.com/developer/article/2255850">参考</a></p><p>前缀树的插入操作是添加一个新的字符串到 Trie 树中并尝试最小化<a href="https://cloud.tencent.com/product/cdcs?from_column=20065&from=20065">数据存储</a>（即对某些节点进行合并）。</p><p>因为基数树的本质依然属于字典树，因此在查找使用上和字典树并无不同。从根节点开始遍历字符串，对于每个字符，检查当前节点的子节点是否包含该字符，如果包含，则继续遍历下一个字符，否则说明该字符串不存在于 Radix 树中。</p><p>Radix 树的查找操作相对于 Trie 树的查找操作有一个优点，<strong>因为基数树通过压缩，使得在前缀有一定规律的串在树中的深度更低，因此查找效率也较高。</strong></p><p>因为 Engine 就实现了 ServeHTTP，这里会将 Engine 本身传给 ListenAndServe 方法，当监听的端口有新的连接时，ListenAndServe 会负责 accept 建立连接，并且在连接上有数据时，会调用 handler 的 ServeHTTP 方法进行处理。</p></blockquote><p>阅读源代码可以参考<a href="https://wmf.im/p/gin-%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">网上的文章</a>，围绕gin的这几个特点来阅读：</p><ul><li>Middleware support</li><li>Crash-free</li><li>JSON validation</li><li>Routes grouping</li><li>Error management</li><li>Rendering built-in&#x2F;Extendable</li></ul><p>1.31 在看</p><h2 id="runtime-Caller"><a href="#runtime-Caller" class="headerlink" title="runtime.Caller"></a>runtime.Caller</h2><p>a_tester下的func stack(skip int) []byte </p><p>关于runtime.Caller函数：</p><p>用于获取调用栈的信息，包括调用者的文件名、行号和函数名。函数定义为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">func Caller(skip int) (pc uintptr, file string, line int, ok bool)<br></code></pre></td></tr></table></figure><ul><li><code>pc</code> 表示调用者函数的程序计数器（program counter），用于标识调用者函数的指令地址。</li><li><code>file</code> 表示调用者函数所在的文件名。</li><li><code>line</code> 表示调用者函数所在的行号。</li><li><code>ok</code> 表示是否成功获取了调用者的信息，如果成功为 true，否则为 false。当传递的i值太大了，没有对应的调用者信息，返回的ok就是false。</li></ul><p>传递0表示调用Caller函数的位置的信息，传递1表示调用Caller函数的位置所在函数 的调用者的信息，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>stackTest(<span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stackTest</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>pc, file, line, ok := runtime.Caller(i)<br>fmt.Println(<span class="hljs-string">&quot;..........&quot;</span>, pc, file, line, ok)<br>&#125;<br></code></pre></td></tr></table></figure><p>传递0打印出来的结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">.......... 17359146 /Users/rhettnina/MyLocalFile/代码/fromweb/gopacket-fram/a_tester/main.go 15 true<br></code></pre></td></tr></table></figure><p>也就是调用runtime.Caller这一行的代码信息，包括所在文件，行号等等</p><p>传递1打印出来的结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">.......... 17359069 /Users/rhettnina/MyLocalFile/代码/fromweb/gopacket-fram/a_tester/main.go 11 true<br></code></pre></td></tr></table></figure><p>因为调用runtime.Caller的函数是stackTest，也就是runtime.Caller的一级调用者是stackTest，传递0返回的是1级调用者的调用详情。传递1表示的是一级调用者的调用者 也就是二级调用者的调用信息，二级调用者main函数是在main.go的第11行调用的。</p><h2 id="router匹配"><a href="#router匹配" class="headerlink" title="router匹配"></a>router匹配</h2><p>主要就是看<code>tree.go</code>这个文件</p><p>24.2.22 正在研究ginrouter的匹配方法</p><p> gin的路径匹配部分使用的是基数树（Radix Trie）数据结构，这是一种多叉树，是一种更节省空间的Trie（前缀树）。也就是努力将多个节点合并为一个。基数树中作为唯一子结点的每个结点都与其父结点合并，每个内部结点的子结点数最多为基数树的基数 r，r 为正整数且等于2^n(n&gt;&#x3D;1)。<a href="https://cloud.tencent.com/developer/article/2255850">参考文章</a></p><p>要解决的问题：</p><p>gin.PrintNode打印出来的indices字段是什么意思，这个字段的euqsa、&#x2F;、euq、pu、ts这些值是什么意思</p><p>wildChild字段是干什么的</p><h3 id="indices作用"><a href="#indices作用" class="headerlink" title="indices作用"></a>indices作用</h3><p>indices是所有子child的path的第一个字母连起来的字符串，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs shell">...............printNode....  HEAD<br>    path:  /<br>    indices:  euq<br>    wildChild:  false<br>    nType:  root<br>    priority:  3<br>    fullPath:  /<br>    handlers:  []<br>    has  3 child........<br>       path:  export<br>       indices:  /<br>       wildChild:  false<br>       nType:  static<br>       priority:  1<br>       fullPath:  /<br>       handlers:  []<br>       has  1 child........<br>             path:<br>             indices:<br>             wildChild:  true<br>             nType:  catchAll<br>             priority:  1<br>             fullPath:  /export/*filepath<br>             handlers:  []<br>             has  1 child........<br>                         path:  /*filepath<br>                         indices:<br>                         wildChild:  false<br>                         nType:  catchAll<br>                         priority:  1<br>                         fullPath:  /export/*filepath<br>                         handlers:  [0x155c600 0x155d400 0x1560340]<br>       path:  upload/images<br>       indices:  /<br>       wildChild:  false<br>       nType:  static<br>       priority:  1<br>       fullPath:  /upload/images/*filepath<br>       handlers:  []<br>       has  1 child........<br>             path:<br>             indices:<br>             wildChild:  true<br>             nType:  catchAll<br>             priority:  1<br>             fullPath:  /upload/images/*filepath<br>             handlers:  []<br>             has  1 child........<br>                         path:  /*filepath<br>                         indices:<br>                         wildChild:  false<br>                         nType:  catchAll<br>                         priority:  1<br>                         fullPath:  /upload/images/*filepath<br>                         handlers:  [0x155c600 0x155d400 0x1560340]<br>       path:  qrcode<br>       indices:  /<br>       wildChild:  false<br>       nType:  static<br>       priority:  1<br>       fullPath:  /qrcode/*filepath<br>       handlers:  []<br>       has  1 child........<br>             path:<br>             indices:<br>             wildChild:  true<br>             nType:  catchAll<br>             priority:  1<br>             fullPath:  /qrcode/*filepath<br>             handlers:  []<br>             has  1 child........<br>                         path:  /*filepath<br>                         indices:<br>                         wildChild:  false<br>                         nType:  catchAll<br>                         priority:  1<br>                         fullPath:  /qrcode/*filepath<br>                         handlers:  [0x155c600 0x155d400 0x1560340]<br></code></pre></td></tr></table></figure><p>这里第一个indices的值是euq，然后它有三个child，三个child的path分别为export、upload&#x2F;images、qrcode，其实euq就是这三个path的首字母拼起来的。</p><p>作用：目前看起来是寻找路径对应的handler时会根据indices的每个字符进行匹配，验证该路径的hander是否存在于当前节点。但是这个字段好像是和wildChild一起使用的？？？</p><h3 id="wildChild"><a href="#wildChild" class="headerlink" title="wildChild"></a>wildChild</h3><p>wildChild似乎是表示children中是否包含通配符，即 : 或者 *</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">...............printNode....  GET<br>    path:  /<br>    indices:  euqsa<br>    wildChild:  false<br>    nType:  root<br>    priority:  5<br>    fullPath:  /<br>    handlers:  []<br>    has  5 child........<br>       path:  export<br>       indices:  /<br>       wildChild:  false # 只有一个child，这个child的path为空，没有通配符，wildChild为false<br>       nType:  static<br>       priority:  1<br>       fullPath:  /<br>       handlers:  []<br>       has  1 child........<br>             path:<br>             indices:<br>             wildChild:  true# 只有一个child，这个child的path为/*filepath，有通配符，wildChild为true<br>             nType:  catchAll<br>             priority:  1<br>             fullPath:  /export/*filepath<br>             handlers:  []<br>             has  1 child........<br>                         path:  /*filepath<br>                         indices:<br>                         wildChild:  false# 没有child，为false<br>                         nType:  catchAll<br>                         priority:  1<br>                         fullPath:  /export/*filepath<br>                         handlers:  [0x155c600 0x155d400 0x1560340]<br></code></pre></td></tr></table></figure><h3 id="priority？"><a href="#priority？" class="headerlink" title="priority？"></a>priority？</h3><p>好像不是child的数量</p><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>handler中记录了所有的中间件和处理函数，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitRouter</span><span class="hljs-params">()</span></span> *gin.Engine &#123;<br>r := gin.New()<br>r.Use(gin.Logger())<br>r.Use(gin.Recovery())<br><span class="hljs-comment">// r 的 Handers 长度是 2，就是对应了两个中间件</span><br><br><span class="hljs-comment">// 这里其实是调用 r.RouterGroup.StaticFS 等路由</span><br>r.StaticFS(<span class="hljs-string">&quot;/export&quot;</span>, http.Dir(<span class="hljs-string">&quot;xxxx&quot;</span>))<br></code></pre></td></tr></table></figure><p>export对应的handler是最后一个，里面有三个元素，分别对应了gin.Logger()、(gin.Recovery()和http.Dir(“xxxx”)，注意这个handler的父各个节点的handlers都是空</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">...............printNode....  GET<br>    path:  /<br>    indices:  euqsa<br>    wildChild:  false<br>    nType:  root<br>    priority:  5<br>    fullPath:  /<br>    handlers:  []<br>    has  5 child........<br>       path:  export<br>       indices:  /<br>       wildChild:  false<br>       nType:  static<br>       priority:  1<br>       fullPath:  /<br>       handlers:  []<br>       has  1 child........<br>             path:<br>             indices:<br>             wildChild:  true<br>             nType:  catchAll<br>             priority:  1<br>             fullPath:  /export/*filepath<br>             handlers:  []<br>             has  1 child........<br>                         path:  /*filepath<br>                         indices:<br>                         wildChild:  false<br>                         nType:  catchAll<br>                         priority:  1<br>                         fullPath:  /export/*filepath<br>                         handlers:  [0x155c600 0x155d400 0x1560340]<br></code></pre></td></tr></table></figure><p>24.2.23更新：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// addRoute adds a node with the given handle to the path.</span><br><br><span class="hljs-comment">// Not concurrency-safe!</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> addRoute(path <span class="hljs-type">string</span>, handlers HandlersChain)<br></code></pre></td></tr></table></figure><p>addRoute这个的实现是最关键的</p><p>这是是关于如何添加路由</p><p>还有需要看的是 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> getValue(path <span class="hljs-type">string</span>, params *Params, skippedNodes *[]skippedNode, unescape <span class="hljs-type">bool</span>) (value nodeValue)<br></code></pre></td></tr></table></figure><p>这是是关于如何寻找路由</p><p>都是tree.go里的函数，我决定把tree.go里面的函数都看一遍，先看简单的，看懂了就标记下来，看不懂的最难的放到最后。</p><p><img src="/../images/image-20240223181338554.png" alt="image-20240223181338554"></p><p><strong>utf8包的RuneStart函数解析</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RuneStart</span><span class="hljs-params">(b <span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> b&amp;<span class="hljs-number">0xC0</span> != <span class="hljs-number">0x80</span> &#125;<br></code></pre></td></tr></table></figure><p>这个函数是用来判断一个字节是否是 UTF-8 编码的字符序列的起始字节的</p><p>0xC0的二进制是1100 0000，0x80的二进制是1000 0000</p><p>b&amp;0xC0相当于只取b二进制的前两位，b&amp;0xC0 !&#x3D; 0x80 就是判断b的前两位不是10</p><blockquote><p>这里补充下utf8编码规范：</p><p>对于某一个字符的UTF-8编码，如果只有一个字节则其最高二进制位为0。</p><p>如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的位数，其余各字节均以10开头。UTF-8最多可用到6个字节。<br>如表：<br>1字节 0xxxxxxx<br>2字节 110xxxxx 10xxxxxx<br>3字节 1110xxxx 10xxxxxx 10xxxxxx<br>4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br>5字节 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx<br>6字节 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx </p></blockquote><p>根据上面的编码规则可以看出，utf8编码的第一个字节只能为0xxxxxxx、110xxxxx、1110xxxx 、11110xxx 、 111110xx 、1111110x 中的某一个，显然如果是10开头就不满足要求，不可能是utf8编码的第一个字节。所以是10的话就是UTF-8 编码中的非起始字节。</p><p><strong>utf8包的DecodeRune函数解析</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DecodeRune</span><span class="hljs-params">(p []<span class="hljs-type">byte</span>)</span></span> (r <span class="hljs-type">rune</span>, size <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>接受一个字节切片 <code>p</code> 作为参数，并返回两个值：<code>rune</code> 类型的字符值 <code>r</code> 和 <code>int</code> 类型的字符所占用的字节数 <code>size</code>。</p><p>函数的作用是解码字节切片 <code>p</code> 中的 UTF-8 编码字符序列，并返回第一个 Unicode 字符以及其所占用的字节数。如果字节切片 <code>p</code> 不是一个有效的 UTF-8 编码字符序列，函数将返回 <code>rune</code> 类型的 Unicode 替代字符 <code>RuneError</code>（通常是 Unicode 编码中的 <code>U+FFFD</code>）以及 0。</p><p>3.7 更新：最近以及之后大概一直在阅读tree.go文件</p><h2 id="阅读-findCaseInsensitivePathRec-函数"><a href="#阅读-findCaseInsensitivePathRec-函数" class="headerlink" title="阅读 findCaseInsensitivePathRec 函数"></a>阅读 findCaseInsensitivePathRec 函数</h2><blockquote><p>3.7 更新：</p><p>看得差不多了，但是还有 rb 和 off 这两个变量相关的东西没看懂，不知道这俩干啥的，测试也测试不到我想要的路径，已经在gin源代码里添加TODO了。🤡🤡🤡</p></blockquote><p>函数定义为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">func (n *node) findCaseInsensitivePathRec(path string, ciPath []byte, rb [4]byte, fixTrailingSlash bool) []byte<br></code></pre></td></tr></table></figure><p>fixTrailingSlash的意思是修复尾部斜杠</p><p>wildChild是用于标记子节点中是否有通配符的，如果有则wildChild为true</p><h3 id="举例示例"><a href="#举例示例" class="headerlink" title="举例示例"></a>举例示例</h3><h4 id="findCaseInsensitivePathRec函数fixTrailingSlash的作用"><a href="#findCaseInsensitivePathRec函数fixTrailingSlash的作用" class="headerlink" title="findCaseInsensitivePathRec函数fixTrailingSlash的作用"></a>findCaseInsensitivePathRec函数fixTrailingSlash的作用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>n := node&#123;<br>path:      <span class="hljs-string">&quot;/&quot;</span>,<br>indices:   <span class="hljs-string">&quot;au&quot;</span>,<br>wildChild: <span class="hljs-literal">false</span>,<br>fullPath:  <span class="hljs-string">&quot;/&quot;</span>,<br>priority:  <span class="hljs-number">3</span>,<br>handlers:  <span class="hljs-literal">nil</span>,<br>nType:     root,<br><span class="hljs-comment">// children 嵌套使用了 node</span><br>children: []*node&#123;<br>&#123;<br>path:      <span class="hljs-string">&quot;api/v1/tags&quot;</span>,<br>indices:   <span class="hljs-string">&quot;_&quot;</span>,<br>wildChild: <span class="hljs-literal">false</span>,<br>nType:     static,<br>priority:  <span class="hljs-number">2</span>,<br>fullPath:  <span class="hljs-string">&quot;/api/v1/tags&quot;</span>,<br>handlers:  []HandlerFunc&#123;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span> &#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span> &#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span> &#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span> &#123;&#125;&#125;,<br>children: []*node&#123;<br>&#123;<br>path:      <span class="hljs-string">&quot;_1&quot;</span>,<br>indices:   <span class="hljs-string">&quot;&quot;</span>,<br>wildChild: <span class="hljs-literal">false</span>,<br>nType:     static,<br>priority:  <span class="hljs-number">1</span>,<br>fullPath:  <span class="hljs-string">&quot;/api/v1/tags_1&quot;</span>,<br>handlers:  []HandlerFunc&#123;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span> &#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span> &#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span> &#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span> &#123;&#125;&#125;,<br>&#125;,<br>&#125;,<br>&#125;,<br>&#123;<br>path:      <span class="hljs-string">&quot;users/&quot;</span>,<br>indices:   <span class="hljs-string">&quot;&quot;</span>,<br>wildChild: <span class="hljs-literal">true</span>,<br>nType:     static,<br>priority:  <span class="hljs-number">1</span>,<br>fullPath:  <span class="hljs-string">&quot;/&quot;</span>,<br>children: []*node&#123;<br>&#123;<br>path:      <span class="hljs-string">&quot;:id&quot;</span>,<br>indices:   <span class="hljs-string">&quot;&quot;</span>,<br>wildChild: <span class="hljs-literal">false</span>,<br>nType:     param,<br>priority:  <span class="hljs-number">1</span>,<br>fullPath:  <span class="hljs-string">&quot;users/:id&quot;</span>,<br>handlers:  []HandlerFunc&#123;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span> &#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span> &#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span> &#123;&#125;&#125;,<br>&#125;,<br>&#125;,<br><span class="hljs-comment">// handlers:  [0x13dede0 0x13e0060 0x13e7b60],</span><br>&#125;,<br>&#125;,<br>&#125;<br>r := n.findCaseInsensitivePathRec(<span class="hljs-string">&quot;/users/user1/&quot;</span>, <span class="hljs-literal">nil</span>, [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;&#125;, <span class="hljs-literal">false</span>)<br>fmt.Println(<span class="hljs-string">&quot;.....findCaseInsensitivePathRec.....&quot;</span>, <span class="hljs-type">string</span>(r))<br>&#125;<br></code></pre></td></tr></table></figure><p>因为传递的findCaseInsensitivePathRec的第三个参数为false，打印出来的r是空的。如果传递的findCaseInsensitivePathRec为true，那么打印出来的findCaseInsensitivePathRec就是 &#x2F;users&#x2F;user1&#x2F;</p><h4 id="当两个路径中都有参数时，且参数后都有一个路径，生成的tree是什么样子的"><a href="#当两个路径中都有参数时，且参数后都有一个路径，生成的tree是什么样子的" class="headerlink" title="当两个路径中都有参数时，且参数后都有一个路径，生成的tree是什么样子的"></a>当两个路径中都有参数时，且参数后都有一个路径，生成的tree是什么样子的</h4><p>比如对于这两个路由：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">r.GET(<span class="hljs-string">&quot;/users/:id/ccc&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 获取路径参数的值</span><br>id := c.Param(<span class="hljs-string">&quot;id&quot;</span>)<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;CCC User ID: %s&quot;</span>, id)<br>&#125;)<br><br>r.GET(<span class="hljs-string">&quot;/users/:id/dddd&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 获取路径参数的值</span><br>id := c.Param(<span class="hljs-string">&quot;id&quot;</span>)<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;DDD User ID: %s&quot;</span>, id)<br>&#125;)<br></code></pre></td></tr></table></figure><p>调用时可以这样传递参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --location &#x27;http://localhost:9934/users/user1/dddd&#x27; <br></code></pre></td></tr></table></figure><p>返回的结果是：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">DDD User ID: user1<br></code></pre></td></tr></table></figure><p>那么对于路径&#x2F;users&#x2F;:id&#x2F;ccc和&#x2F;users&#x2F;:id&#x2F;dddd，生成的路由tree是什么样子的呢？</p><p>我预期的生成结果是类似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">users/<br>   - :id<br>     - ccc<br>     - dddd<br></code></pre></td></tr></table></figure><p>但是实际上的结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">users/<br>  - :id<br>    - /<br>      - ccc<br>      - dddd<br></code></pre></td></tr></table></figure><p>打印出来的完整node结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs shell">path:  /<br> indices:  ua<br> wildChild:  false<br> nType:  root<br> priority:  4<br> fullPath:  /<br> handlers:  []<br> has  2 child........<br>    path:  users/<br>    indices:<br>    wildChild:  true<br>    nType:  static<br>    priority:  2<br>    fullPath:  /<br>    handlers:  []<br>    has  1 child........<br>          path:  :id<br>          indices:<br>          wildChild:  false<br>          nType:  param<br>          priority:  2<br>          fullPath:  /users/:id/ccc<br>          handlers:  []<br>          has  1 child........<br>                      path:  /<br>                      indices:  cd<br>                      wildChild:  false<br>                      nType:  static<br>                      priority:  2<br>                      fullPath:  /use<br>                      handlers:  []<br>                      has  2 child........<br>                                              path:  ccc<br>                                              indices:<br>                                              wildChild:  false<br>                                              nType:  static<br>                                              priority:  1<br>                                              fullPath:  /users/:id/ccc<br>                                              handlers:  [0x13d5860 0x13d6ae0 0x13dea00]<br>                                              path:  dddd<br>                                              indices:<br>                                              wildChild:  false<br>                                              nType:  static<br>                                              priority:  1<br>                                              fullPath:  /users/:id/dddd<br>                                              handlers:  [0x13d5860 0x13d6ae0 0x13deba0]<br>    path:  a/<br>    .... 另一个节点的信息这里省略。<br></code></pre></td></tr></table></figure><p>为什么非要把这两条路径相同的<code>:id/</code>部分拆成两个node呢？分别是<code>:id</code>和<code>/</code>，且<code>/</code>是<code>:id</code>的子节点？</p><p>主要是因为findCaseInsensitivePathRec实现的过程中有一些特殊之处。关键在于下面的一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> n.nType &#123;<br><span class="hljs-keyword">case</span> param:<br><span class="hljs-comment">// Find param end (either &#x27;/&#x27; or path end)</span><br>end := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> end &lt; <span class="hljs-built_in">len</span>(path) &amp;&amp; path[end] != <span class="hljs-string">&#x27;/&#x27;</span> &#123;<br>end++<br>&#125;<br><br><span class="hljs-comment">// Add param value to case insensitive path</span><br>ciPath = <span class="hljs-built_in">append</span>(ciPath, path[:end]...)<br><br><span class="hljs-comment">// We need to go deeper!</span><br><span class="hljs-keyword">if</span> end &lt; <span class="hljs-built_in">len</span>(path) &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.children) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Continue with child node</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 测试这里的 n.children 长度大于 2 的情况</span><br>n = n.children[<span class="hljs-number">0</span>]<br>npLen = <span class="hljs-built_in">len</span>(n.path)<br>path = path[end:]<br><span class="hljs-keyword">continue</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这一段，只有节点的nType为param时才能执行到这里。显然path为<code>:id</code>的node执行findCaseInsensitivePathRec会走到这里。因为这里直接在len(n.children) &gt; 0的情况下使用了n.children[0]，并且执行了continue操作进入下个循环。所以显然gin默认执行到<code>if len(n.children) &gt; 0 &#123;</code>这里时只有一个children，所以需要在设置tree时让这里只有一个节点，所以设置<code>/</code>为<code>:id</code>的下一个节点而不是设置<code>:id/</code>为一个节点才能满足这里n.children[0]的需求。如果设置<code>:id/</code>为一个节点，那么这个节点必然有两个children，也就是<code>ccc</code>和<code>dddd</code>，那么这里直接取n.children[0]就无法取到第二个path为<code>dddd</code>的节点，就会出现问题了。</p><h3 id="路由里的特殊参数"><a href="#路由里的特殊参数" class="headerlink" title="路由里的特殊参数"></a>路由里的特殊参数</h3><p>**路由里的<code>:</code>**，用于匹配参数，用法如下：</p><p>比如对于这两个路由：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">r.GET(<span class="hljs-string">&quot;/users/:id/ccc&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 获取路径参数的值</span><br>id := c.Param(<span class="hljs-string">&quot;id&quot;</span>)<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;CCC User ID: %s&quot;</span>, id)<br>&#125;)<br><br>r.GET(<span class="hljs-string">&quot;/users/:id/dddd&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 获取路径参数的值</span><br>id := c.Param(<span class="hljs-string">&quot;id&quot;</span>)<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;DDD User ID: %s&quot;</span>, id)<br>&#125;)<br></code></pre></td></tr></table></figure><p>调用时可以这样传递参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --location &#x27;http://localhost:9934/users/user1/dddd&#x27; <br></code></pre></td></tr></table></figure><p>返回的结果是：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">DDD User ID: user1<br></code></pre></td></tr></table></figure><p><strong>路由里的<code>*</code></strong></p><p>符号通常用于匹配任意的路径片段，被称为通配符路由。</p><p>使用 * 符号时，这意味着该路由会匹配所有以它之后的路径。这样的路由通常用于处理动态的、不固定的路径。</p><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">r.GET(<span class="hljs-string">&quot;/static/*filepath&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 获取 *filepath 匹配的路径</span><br>filepath := c.Param(<span class="hljs-string">&quot;filepath&quot;</span>)<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;Static file path: %s&quot;</span>, filepath)<br>&#125;)<br></code></pre></td></tr></table></figure><p>下面调用一下进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --location &#x27;http://localhost:9934/static/abc&#x27; <br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Static file path: /abc<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --location &#x27;http://localhost:9934/static/*filepath&#x27; <br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Static file path: /*filepath<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --location &#x27;http://localhost:9934/static/*filepath&#x27; <br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Static file path: /abc/dddd<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --location &#x27;http://localhost:9934/static/*filepath/xxxx&#x27; <br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Static file path: /*filepath/xxxx<br></code></pre></td></tr></table></figure><p>可见<code>/static/*filepath</code>路由中的<code>filepath</code>会把<code>/static</code>之后的所有内容都匹配出来。一直匹配到传入路由的末尾。</p><p>我试了下，如果再在<code>*filepath</code> 后面追加东西，显然追加东西的话是多余的、不正确的操作，比如这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">r.GET(<span class="hljs-string">&quot;/static/*filepath/xxx&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 获取 *filepath 匹配的路径</span><br>filepath := c.Param(<span class="hljs-string">&quot;filepath&quot;</span>)<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;Static file path: %s&quot;</span>, filepath)<br>&#125;)<br></code></pre></td></tr></table></figure><p>程序会在启动时直接panic。</p><h2 id="阅读-getValue函数"><a href="#阅读-getValue函数" class="headerlink" title="阅读 getValue函数"></a>阅读 getValue函数</h2><p>getValue函数的定义是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> getValue(path <span class="hljs-type">string</span>, params *Params, skippedNodes *[]skippedNode, unescape <span class="hljs-type">bool</span>) (value nodeValue) <br></code></pre></td></tr></table></figure><p>3.13 更新，看得差不多了，但是还有一些细节不太明白，可能要把tree的代码都大概过一遍之后再看第二次</p><h2 id="阅读-findWildcard函数"><a href="#阅读-findWildcard函数" class="headerlink" title="阅读 findWildcard函数"></a>阅读 findWildcard函数</h2><p>这个很简单，飞快看懂了，小问题！</p><h2 id="阅读-insertChild函数"><a href="#阅读-insertChild函数" class="headerlink" title="阅读 insertChild函数"></a>阅读 insertChild函数</h2><p>看得大概懂了，但是不是100%</p><h2 id="阅读-addRoute函数"><a href="#阅读-addRoute函数" class="headerlink" title="阅读 addRoute函数"></a>阅读 addRoute函数</h2><p>函数定义为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> addRoute(path <span class="hljs-type">string</span>, handlers HandlersChain) <br></code></pre></td></tr></table></figure><blockquote><p>注意：定义相同的路由会直接panic</p><p>比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">r.GET(<span class="hljs-string">&quot;/notnow/:filepath/*xxxx&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 获取 *filepath 匹配的路径</span><br>name := c.Param(<span class="hljs-string">&quot;filepath&quot;</span>)<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;Static file path: %s&quot;</span>, name)<br>&#125;)<br><br>r.GET(<span class="hljs-string">&quot;/notnow/:filepath/*yyyy&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 获取 *filepath 匹配的路径</span><br>name := c.Param(<span class="hljs-string">&quot;filepath&quot;</span>)<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;Static file path: %s&quot;</span>, name)<br>&#125;)<br></code></pre></td></tr></table></figure><p>如果这样定义路由，程序会直接Panic，因为<code>/notnow/:filepath/*xxxx</code>和<code>/notnow/:filepath/*yyyy</code>本质上是一条路由。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">r.GET(<span class="hljs-string">&quot;/notnow/:filepath/*xxxx&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 获取 *filepath 匹配的路径</span><br>name := c.Param(<span class="hljs-string">&quot;filepath&quot;</span>)<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;Static file path: %s&quot;</span>, name)<br>&#125;)<br><br>r.GET(<span class="hljs-string">&quot;/notnow/:filepath/abc/*yyyy&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 获取 *filepath 匹配的路径</span><br>name := c.Param(<span class="hljs-string">&quot;filepath&quot;</span>)<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;Static file path: %s&quot;</span>, name)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样的也会报错，因为有些路由匹配时会有歧义，比如&#x2F;notnow&#x2F;love&#x2F;abc&#x2F;1 既可以匹配第一个，此时xxxx的值是abc&#x2F;1，也可以匹配到第二个路由，此时yyyy的值是1。</p></blockquote><p>3.18 更新，这个函数也都看完了，但是没有怎么懂。我准备画gin的架构图，根据架构图来画一个系统之类的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编写中，未定稿</title>
    <link href="/2023/01/01/%EF%BC%88%E6%AD%A3%E5%9C%A8%E7%BC%96%E5%86%99%E4%B8%AD%EF%BC%89gopher-lua%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/01/01/%EF%BC%88%E6%AD%A3%E5%9C%A8%E7%BC%96%E5%86%99%E4%B8%AD%EF%BC%89gopher-lua%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>GopherLua是一个用Go写的lua虚拟机和编译器。GopherLua提供了API，可以让你轻松将lua脚本嵌入Go主机主机程序中。GopherLua目标是成为具有可扩展语义的脚本语言。</p><p>github地址为：<a href="https://github.com/yuin/gopher-lua#installation">https://github.com/yuin/gopher-lua#installation</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get github.com/yuin/gopher-lua<br></code></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="直接运行lua命令"><a href="#直接运行lua命令" class="headerlink" title="直接运行lua命令"></a>直接运行lua命令</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> lua <span class="hljs-string">&quot;github.com/yuin/gopher-lua&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>L := lua.NewState()<br><span class="hljs-keyword">defer</span> L.Close()<br><span class="hljs-keyword">if</span> err := L.DoString(<span class="hljs-string">`print(&quot;hello&quot;)`</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">go run .      <br>hello<br></code></pre></td></tr></table></figure><h3 id="运行lua文件"><a href="#运行lua文件" class="headerlink" title="运行lua文件"></a>运行lua文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> lua <span class="hljs-string">&quot;github.com/yuin/gopher-lua&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>L := lua.NewState()<br><span class="hljs-keyword">defer</span> L.Close()<br><span class="hljs-keyword">if</span> err := L.DoFile(<span class="hljs-string">&quot;hello.lua&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>hello.lua的内容为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>下面介绍如何向lua程序传递参数和接收参数</p><p>所有GopherLua里的数据都是一个LValue类型的值。LValue有以下方法可以调用：</p><ul><li><code>String() string</code></li><li><code>Type() LValueType</code></li></ul><p>LValue类型是一个interface，有很多类型实现了该interface，比如LNilType、LBool、LNumber、LString、LFunction、LUserData、LState、LTable、LChannel等等</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编写中，未定稿</title>
    <link href="/2023/01/01/%EF%BC%88%E6%AD%A3%E5%9C%A8%E7%BC%96%E5%86%99%E4%B8%AD%EF%BC%89%E6%9C%80%E6%96%B0--gin%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2023/01/01/%EF%BC%88%E6%AD%A3%E5%9C%A8%E7%BC%96%E5%86%99%E4%B8%AD%EF%BC%89%E6%9C%80%E6%96%B0--gin%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>gin是一个知名的HTTP web框架，应用非常广泛。是用golang开发的。github项目地址为 <a href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a></p><h2 id="go-gin-example阅读"><a href="#go-gin-example阅读" class="headerlink" title="go-gin-example阅读"></a>go-gin-example阅读</h2><p>因为要阅读gin的源代码，所以想着先阅读完教如何 使用gin的示例代码，先大概了解gin是如何使用的。示例项目是<a href="https://github.com/eddycjy/go-gin-example%E3%80%82%E4%B8%8B%E9%9D%A2%E6%98%AF%E6%88%91%E9%98%85%E8%AF%BB%E5%AE%8C%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93%E7%9A%84%E4%B8%80%E4%BA%9B%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%8C%E5%BD%93%E8%87%AA%E5%B7%B1%E7%BC%96%E7%A0%81%E6%97%B6%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E3%80%82">https://github.com/eddycjy/go-gin-example。下面是我阅读完示例代码后的总结的一些比较重要的部分，当自己编码时可以参考。</a></p><p>读取配置和数据库初始化的过程，可以放在func init() 里，参考：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>setting.Setup() <span class="hljs-comment">// 读取配置文件的所有部分，并对申明好了的全局配置变量赋值</span><br>models.Setup() <span class="hljs-comment">// 初始化mysql db，并自定义了Create Update Delete时的回调函数</span><br>logging.Setup() <span class="hljs-comment">// 初始化日志，是基于标准库里面的日志包初始化的</span><br>gredis.Setup() <span class="hljs-comment">// 初始化redis，包括设置连接redis时会调用的Dial函数</span><br>util.Setup() <span class="hljs-comment">// 设置pkg包里jwtSecret的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>项目里使用到了<a href="https://github.com/beego/beego%E6%A1%86%E6%9E%B6%EF%BC%8C%E7%94%A8%E4%BA%86%E5%85%B6validation%E5%8C%85%E5%81%9A%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81%EF%BC%8C%E5%85%B6%E4%BB%96%E7%9A%84%E5%8C%85%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E3%80%82">https://github.com/beego/beego框架，用了其validation包做数据验证，其他的包没有使用。</a></p><blockquote><p>beego框架可以用于开发包括传统的 Web 网站、API 服务、后台管理系统</p></blockquote><p>validation包的使用方法可以参考：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> auth <span class="hljs-keyword">struct</span> &#123;<br>Username <span class="hljs-type">string</span> <span class="hljs-string">`valid:&quot;Required; MaxSize(50)&quot;`</span> <span class="hljs-comment">// 这个地方要遵循 validation 的语法</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`valid:&quot;Required; MaxSize(50)&quot;`</span><br>&#125;<br>a := auth&#123;Username: username, Password: password&#125;<br>ok, _ := valid.Valid(&amp;a)<br></code></pre></td></tr></table></figure><p>用到了<a href="https://github.com/unknwon/com%E5%8C%85%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%98%AF%E9%92%88%E5%AF%B9">https://github.com/unknwon/com包，这个是针对</a> Go 编程语言常用函数的开源项目。</p><p>router目录存放了rest api的路由定义和rest api的rest部分，而且router的目录结构和路由的结构也是一样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├── api<br>│   ├── auth.go<br>│   ├── upload.go<br>│   └── v1<br>│       ├── article.go<br>│       └── tag.go<br>└── router.go<br></code></pre></td></tr></table></figure><blockquote><p>PS：除了这个项目，gin还提供了官方的example的项目，<a href="https://github.com/gin-gonic/examples%EF%BC%8C%E9%87%8C%E9%9D%A2%E5%88%97%E4%B8%BE%E4%BA%86%E4%B8%80%E4%BA%9Bgin%E7%9A%84%E7%94%A8%E6%B3%95">https://github.com/gin-gonic/examples，里面列举了一些gin的用法</a></p></blockquote><h2 id="gin源代码阅读"><a href="#gin源代码阅读" class="headerlink" title="gin源代码阅读"></a>gin源代码阅读</h2><p>因为对于gin的调用通常是类似这样写的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>gin.SetMode(setting.ServerSetting.RunMode)<br><br>routersInit := routers.InitRouter() <span class="hljs-comment">// 注意</span><br>readTimeout := setting.ServerSetting.ReadTimeout<br>writeTimeout := setting.ServerSetting.WriteTimeout<br>endPoint := fmt.Sprintf(<span class="hljs-string">&quot;:%d&quot;</span>, setting.ServerSetting.HttpPort)<br>maxHeaderBytes := <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span><br>server := &amp;http.Server&#123;<br>Addr:           endPoint,<br>Handler:        routersInit,<br>ReadTimeout:    readTimeout,<br>WriteTimeout:   writeTimeout,<br>MaxHeaderBytes: maxHeaderBytes,<br>&#125;<br><br>log.Printf(<span class="hljs-string">&quot;[info] start http server listening %s&quot;</span>, endPoint)<br>server.ListenAndServe()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitRouter</span><span class="hljs-params">()</span></span> *gin.Engine &#123;<br>r := gin.New()<br>apiv1 := r.Group(<span class="hljs-string">&quot;/api/v1&quot;</span>)<br>apiv1.Use(jwt.JWT())<br>&#123;<br><span class="hljs-comment">//获取标签列表</span><br>apiv1.GET(<span class="hljs-string">&quot;/tags&quot;</span>, v1.GetTags)<br>    <span class="hljs-comment">// ....</span><br><span class="hljs-comment">//生成文章海报</span><br>apiv1.POST(<span class="hljs-string">&quot;/articles/poster/generate&quot;</span>, v1.GenerateArticlePoster)<br>&#125;<br><span class="hljs-keyword">return</span> r<br>&#125;<br></code></pre></td></tr></table></figure><p>全局搜寻gin项目的代码，没有main.go文件，也没有main入口，所以gin代码只有被调用时才生效。根据上面的InitRouter函数中的代码，可以发现，其实：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以理解为通常的入口文件。</p><p>返回的Engine实现了http的ServeHTTP方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>ServeHTTP(ResponseWriter, *Request)<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的实现代码为：</p><p><img src="/../images/image-20240520162232803.png" alt="image-20240520162232803"></p><p>这里是gin框架与外界调用之间的“对接点”。一个web框架的阅读，可以通过以下几个部分来阅读，</p><ul><li>路由分组</li><li>输入数据解析与验证（比如json验证）</li><li>中间件支持</li><li>输出渲染</li><li>错误处理</li><li>日志</li></ul><p>这几个部分也是一个请求的前后经过的几个步骤，首先在程序运行前定义好路由，然后运行。一个请求到达时，首先解析输入数据，然后经过中间件的处理，经过用户自定义的处理函数，最后渲染并返回输出。在这串运行过程中，可能会出错，那么就需要错误处理，也可能需要记录日志。</p><p>下面根据这几个部分来介绍。</p><h3 id="路由分组"><a href="#路由分组" class="headerlink" title="路由分组"></a>路由分组</h3><p> gin的路径匹配部分使用的是基数树（Radix Trie）数据结构，这是一种多叉树，是一种更节省空间的Trie（前缀树）。也就是努力将多个节点合并为一个。基数树中作为唯一子结点的每个结点都与其父结点合并，每个内部结点的子结点数最多为基数树的基数 r，r 为正整数且等于2^n(n&gt;&#x3D;1)。<a href="https://cloud.tencent.com/developer/article/2255850">参考文章</a></p><h3 id="输入数据解析与验证"><a href="#输入数据解析与验证" class="headerlink" title="输入数据解析与验证"></a>输入数据解析与验证</h3><p>以这个例子为例</p><p><img src="/../images/image-20240520163935782.png" alt="image-20240520163935782"></p><p>这个例子中，BindJSON就是把http请求的json格式的内容解析成golang中的名为Person的struct。</p><p>本小节就是介绍类似BindJSON这样的功能gin是如何实现的，这里除了BindJSON，也可以写BindXML等等，BindXML会在当请求被容为xml格式时会把请求内容解析出来。</p><p>BindJSON定义在源代码中的context.go中：</p><p><img src="/../images/image-20240520164501700.png" alt="image-20240520164501700"></p><p>所有和请求解析的函数都在该context.go中定义了，都是Context的方法，从<code>func (c *Context) Bind(obj any) error</code>到<code>func (c *Context) ShouldBindWith(obj any, b binding.Binding) error </code>。这里需要注意下第一个<code>func (c *Context) Bind(obj any) error </code>，这是比较特殊和实用的，因为这个函数会根据http请求的content-type自动找到不同content-type对应的输入解析函数。</p><p>在开始介绍其他的Bind相关函数之前，先介绍下基本且实用的<code>func (c *Context) Bind(obj any) error</code>。</p><h4 id="Bind函数实现"><a href="#Bind函数实现" class="headerlink" title="Bind函数实现"></a>Bind函数实现</h4><p>如上图可以看到Bind函数的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Bind(obj any) <span class="hljs-type">error</span> &#123;<br>b := binding.Default(c.Request.Method, c.ContentType())<br><span class="hljs-keyword">return</span> c.MustBindWith(obj, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是binding.Default(c.Request.Method, c.ContentType())第一个参数是c.Request.Method, c.Request.Method，c.Request为*http.Request类型，这里直接获取到了Method，没有任何多余的实现，而第二个 c.ContentType()是介绍如何获取请求的content-type的，其实现为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// context.go</span><br><span class="hljs-comment">// ContentType returns the Content-Type header of the request.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> ContentType() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> filterFlags(c.requestHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// context.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">filterFlags</span><span class="hljs-params">(content <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">for</span> i, char := <span class="hljs-keyword">range</span> content &#123;<br><span class="hljs-keyword">if</span> char == <span class="hljs-string">&#x27; &#x27;</span> || char == <span class="hljs-string">&#x27;;&#x27;</span> &#123;<br><span class="hljs-keyword">return</span> content[:i]<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> content<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> requestHeader(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> c.Request.Header.Get(key)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/image-20240520171104053.png" alt="image-20240520171104053"></p><p>可以看到实现的逻辑较为简单，最重要的还是调用了go标准库的net包中的<code>func (h Header) Get(key string) string</code>这个函数，才获取到了请求的content-type。</p><p>获取到了 binding.Default的两个参数后，下面是binding.Default的实现，这个函数的都是都是在binding包中的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// binding/binding.go</span><br><span class="hljs-keyword">type</span> Binding <span class="hljs-keyword">interface</span> &#123;<br>Name() <span class="hljs-type">string</span><br>Bind(*http.Request, any) <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Default</span><span class="hljs-params">(method, contentType <span class="hljs-type">string</span>)</span></span> Binding &#123;<br><span class="hljs-keyword">if</span> method == http.MethodGet &#123;<br><span class="hljs-keyword">return</span> Form<br>&#125;<br><br><span class="hljs-keyword">switch</span> contentType &#123;<br><span class="hljs-keyword">case</span> MIMEJSON:<br><span class="hljs-keyword">return</span> JSON<br><span class="hljs-keyword">case</span> MIMEXML, MIMEXML2:<br><span class="hljs-keyword">return</span> XML<br><span class="hljs-keyword">case</span> MIMEPROTOBUF:<br><span class="hljs-keyword">return</span> ProtoBuf<br><span class="hljs-keyword">case</span> MIMEMSGPACK, MIMEMSGPACK2:<br><span class="hljs-keyword">return</span> MsgPack<br><span class="hljs-keyword">case</span> MIMEYAML:<br><span class="hljs-keyword">return</span> YAML<br><span class="hljs-keyword">case</span> MIMETOML:<br><span class="hljs-keyword">return</span> TOML<br><span class="hljs-keyword">case</span> MIMEMultipartPOSTForm:<br><span class="hljs-keyword">return</span> FormMultipart<br><span class="hljs-keyword">default</span>: <span class="hljs-comment">// case MIMEPOSTForm:</span><br><span class="hljs-keyword">return</span> Form<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到实现也很简单，就是根据string类型的输入即content-type，返回不同类型如JSON、XML等对Binding的实现。比如Form对Binding interface的实现为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// binding/binding.go</span><br><span class="hljs-comment">// These implement the Binding interface and can be used to bind the data</span><br><span class="hljs-comment">// present in the request to struct instances.</span><br><span class="hljs-keyword">var</span> (<br>JSON          = jsonBinding&#123;&#125;<br>XML           = xmlBinding&#123;&#125;<br>Form          = formBinding&#123;&#125;<br>Query         = queryBinding&#123;&#125;<br>FormPost      = formPostBinding&#123;&#125;<br>FormMultipart = formMultipartBinding&#123;&#125;<br>ProtoBuf      = protobufBinding&#123;&#125;<br>MsgPack       = msgpackBinding&#123;&#125;<br>YAML          = yamlBinding&#123;&#125;<br>Uri           = uriBinding&#123;&#125;<br>Header        = headerBinding&#123;&#125;<br>TOML          = tomlBinding&#123;&#125;<br>)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// binding/form.go</span><br><span class="hljs-keyword">type</span> formBinding <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">type</span> formPostBinding <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">type</span> formMultipartBinding <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(formBinding)</span></span> Name() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;form&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(formBinding)</span></span> Bind(req *http.Request, obj any) <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-comment">// req.ParseForm 还是调用了go标准库中http request对form格式的处理函数</span><br><span class="hljs-keyword">if</span> err := req.ParseForm(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>  <span class="hljs-comment">// ParseMultipartForm 也是调用了go标准库中的函数</span><br><span class="hljs-keyword">if</span> err := req.ParseMultipartForm(defaultMemory); err != <span class="hljs-literal">nil</span> &amp;&amp; !errors.Is(err, http.ErrNotMultipart) &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> err := mapForm(obj, req.Form); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> validate(obj)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里还需要注意mapForm的实现，mapForm的作用在http的form格式的请求已经被成功解析到req.Form后，将req.Form解析到目标对象obj中 。那么mapForm是如何实现的呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapForm</span><span class="hljs-params">(ptr any, form <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-comment">// mapFormByTag 不止被 mapForm 一个函数所调用，不同函数传递的tag可能不一样，这里传递的tag为form</span><br><span class="hljs-keyword">return</span> mapFormByTag(ptr, form, <span class="hljs-string">&quot;form&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapFormByTag</span><span class="hljs-params">(ptr any, form <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>, tag <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// Check if ptr is a map</span><br>ptrVal := reflect.ValueOf(ptr)<br><span class="hljs-keyword">var</span> pointed any<br><span class="hljs-keyword">if</span> ptrVal.Kind() == reflect.Ptr &#123;<br>ptrVal = ptrVal.Elem()<br>pointed = ptrVal.Interface()<br>&#125;<br><span class="hljs-keyword">if</span> ptrVal.Kind() == reflect.Map &amp;&amp;<br>ptrVal.Type().Key().Kind() == reflect.String &#123;<br><span class="hljs-keyword">if</span> pointed != <span class="hljs-literal">nil</span> &#123;<br>ptr = pointed<br>&#125;<br><span class="hljs-keyword">return</span> setFormMap(ptr, form)<br>&#125;<br><br><span class="hljs-keyword">return</span> mappingByPtr(ptr, formSource(form), tag)<br>&#125;<br></code></pre></td></tr></table></figure><p>下面涉及setFormMap和mappingByPtr的代码都比较底层，这里就不贴出来了，主要作用就是根据反射给ptr赋值。</p><p>至此第一行执行完毕，下面就是执行<code>    return c.MustBindWith(obj, b)</code></p><p>这个小节讲的是Bind的实现，最后执行的语句是<code> c.MustBindWith(obj, b)</code>，其实binding.go中和Bind函数同级别的其他函数比如<code>func (c *Context) BindJSON(obj any) error </code>，<code>func (c *Context) BindXML(obj any) error </code>等等，都用到了c.MustBindWith这个函数，所以下面将c.MustBindWith单独介绍。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> MustBindWith(obj any, b binding.Binding) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := c.ShouldBindWith(obj, b); err != <span class="hljs-literal">nil</span> &#123;<br>c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) <span class="hljs-comment">//nolint: errcheck</span><br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>MustBindWith本质上还是在调用ShouldBindWith，下面介绍ShouldBindWith的实现，</p><h4 id="ShouldBindWith的实现"><a href="#ShouldBindWith的实现" class="headerlink" title="ShouldBindWith的实现"></a>ShouldBindWith的实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// context.go</span><br><span class="hljs-comment">// ShouldBindWith binds the passed struct pointer using the specified binding engine.</span><br><span class="hljs-comment">// See the binding package.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> ShouldBindWith(obj any, b binding.Binding) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> b.Bind(c.Request, obj)<br>&#125;<br></code></pre></td></tr></table></figure><p>ShouldBindWith接受两个参数，第一个是要绑定的对象，为any即interface类型，第二个是绑定的实现方法，是一个interface，由json、xml等实现。</p><p>b.Bind(c.Request, obj)就是调用binding.Binding类型的b实现的interface。这里超级简单。</p><h3 id="中间件支持"><a href="#中间件支持" class="headerlink" title="中间件支持"></a>中间件支持</h3><h3 id="输出渲染"><a href="#输出渲染" class="headerlink" title="输出渲染"></a>输出渲染</h3><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h2 id="gin阅读中的一些扩展"><a href="#gin阅读中的一些扩展" class="headerlink" title="gin阅读中的一些扩展"></a>gin阅读中的一些扩展</h2><p>下面是阅读中的一些知识点的总结，这些知识点和gin的框架实现关系不大，都是一些比较独立的知识点。</p><ol><li><p>gin源代码中很多地方都写了<code>go:build</code>，关于这个<code>go:build</code>，其实 go:build 是一个编译指令（build constraint），用于在不同的Go版本或操作系统之间条件编译代码。<code>!go1.20</code>表示如果Go版本小于1.20，那么以下代码块将会被编译，否则将被忽略。<code>go1.20</code> 表示如果Go版本等于1.20或更高，那么以下代码块将会被编译，否则将被忽略。</p></li><li><p>golang有个类型是any，是原生的，其作用和interface相同，其实是interface的别名</p></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://cloud.tencent.com/developer/article/2255850">基数树简介</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>golang时间相关计算等</title>
    <link href="/2022/12/27/golang%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97%E7%AD%89/"/>
    <url>/2022/12/27/golang%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h2 id="计算时间所在天，所在周，所在月的开始时间"><a href="#计算时间所在天，所在周，所在月的开始时间" class="headerlink" title="计算时间所在天，所在周，所在月的开始时间"></a>计算时间所在天，所在周，所在月的开始时间</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// timeByInterval 根据interval，计算t基于interval的开始时间是什么，可以按照天，月，周对时间统计，比如计算每周的时间有多少</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">timeByInterval</span><span class="hljs-params">(t time.Time, interval <span class="hljs-type">string</span>)</span></span> time.Time &#123;<br><span class="hljs-keyword">if</span> interval == <span class="hljs-string">&quot;day&quot;</span> &#123;<br>    <span class="hljs-comment">// 当天的开始时间</span><br><span class="hljs-keyword">return</span> time.Date(t.Year(), t.Month(), t.Day(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, t.Location())<br>&#125;<br><span class="hljs-keyword">if</span> interval == <span class="hljs-string">&quot;week&quot;</span> &#123;<br>    <span class="hljs-comment">// 当周的开始时间</span><br>t = t.AddDate(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-type">int</span>(t.Weekday())<span class="hljs-number">-1</span>)<br><span class="hljs-keyword">return</span> time.Date(t.Year(), t.Month(), t.Day(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, t.Location())<br>&#125;<br><span class="hljs-keyword">if</span> interval == <span class="hljs-string">&quot;month&quot;</span> &#123;<br>    <span class="hljs-comment">// 当月的开始时间</span><br><span class="hljs-keyword">return</span> time.Date(t.Year(), t.Month(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, t.Location())<br>&#125;<br><span class="hljs-comment">// interval默认值是day</span><br><span class="hljs-keyword">return</span> time.Date(t.Year(), t.Month(), t.Day(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, t.Location())<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gorm打印SQL操作日志</title>
    <link href="/2022/12/25/gorm%E6%89%93%E5%8D%B0SQL%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97/"/>
    <url>/2022/12/25/gorm%E6%89%93%E5%8D%B0SQL%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newModel</span><span class="hljs-params">(opts ...Option)</span></span> (*defaultDataModel, <span class="hljs-type">error</span>) &#123;<br>e := &amp;Options&#123;<br>Addr:     <span class="hljs-string">&quot;127.0.0.1:9999&quot;</span>,<br>Database: <span class="hljs-string">&quot;database&quot;</span>,<br>&#125;<br><span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> opts &#123;<br>o(e)<br>&#125;<br><br>connStr := fmt.Sprintf(<br><span class="hljs-string">&quot;tcp://%s?database=%s&amp;username=%s&amp;password=%s&amp;read_timeout=10&amp;write_timeout=20&quot;</span>,<br>e.Addr,<br>e.Database,<br>e.Username,<br>e.Password)<br>newLogger := logger.New(<br>log.New(os.Stdout, <span class="hljs-string">&quot;\r\n&quot;</span>, log.LstdFlags), <span class="hljs-comment">// io writer</span><br>logger.Config&#123;<br><span class="hljs-comment">// SlowThreshold: time.Microsecond, // 慢 SQL 阈值</span><br>LogLevel: logger.Info, <span class="hljs-comment">// Log level</span><br>Colorful: <span class="hljs-literal">false</span>,       <span class="hljs-comment">// 禁用彩色打印</span><br>&#125;,<br>)<br><br>db, err := gorm.Open(clickhouse.Open(connStr), &amp;gorm.Config&#123;<br>Logger: newLogger,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;defaultDataModel&#123;<br>db:    db,<br>table: <span class="hljs-string">&quot;`table`&quot;</span>,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>主要就是newLogger和下面的db, err :&#x3D; gorm.Open</p><p>另外一个：把慢查询日志单独放到一个文件里</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> logFile *os.File<br>fileName := <span class="hljs-string">&quot;gorm.log&quot;</span><br>_, err2 := os.Stat(fileName)<br><span class="hljs-keyword">if</span> err2 != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> os.IsNotExist(err2) &#123;<br>logFile, _ = os.Create(fileName)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>logFile, _ = os.Open(fileName)<br>&#125;<br>&#125;<br>ormLog := logger.New(<br>log.New(logFile, time.Now().Format(<span class="hljs-string">&quot;2006-01-02 15:04:05 &quot;</span>), log.Lshortfile),<br>logger.Config&#123;<br>SlowThreshold: <span class="hljs-number">200</span> * time.Millisecond,<br>LogLevel:      logger.Info, <span class="hljs-comment">// Log level</span><br>Colorful:      <span class="hljs-literal">false</span>,       <span class="hljs-comment">// 禁用彩色打印</span><br>&#125;,<br>)<br>connStr := fmt.Sprintf(<br><span class="hljs-string">&quot;tcp://%s?database=%s&amp;username=%s&amp;password=%s&amp;read_timeout=10&amp;write_timeout=20&quot;</span>,<br>e.Addr,<br>e.Database,<br>e.Username,<br>e.Password)<br>db, err := gorm.Open(clickhouse.Open(connStr), &amp;gorm.Config&#123;<br>Logger: ormLog,<br>&#125;)<br></code></pre></td></tr></table></figure><p>参考上面的写法，主要就是gorm.Open里只指定包含Logger的gorm Config，可以看到打印的效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs log">2022-12-13 15:45:05 logger.go:133: /Users/u/go/pkg/mod/gorm.io/driver/clickhouse@v0.3.3/clickhouse.go:55<br>[info] replacing callback `gorm:create` from /Users/u/go/pkg/mod/gorm.io/driver/clickhouse@v0.3.3/clickhouse.go:55<br>2022-12-13 15:45:05 logger.go:172: /Users/u/code/service/model/datamodel.go:222 SLOW SQL &gt;= 200ms<br>[725.062ms] [rows:900] SELECT u.ct, untuple(arrayJoin(arraySlice(arraySort((x, y)-&gt;-y, arrayMap((x, y, z) -&gt; (x, y, z), groupArray(u.src_ip), groupArray(u.dst_ip), groupArray(u.p)), groupArray(u.p)), 1, 5))) AS res FROM (SELECT toStartOfInterval(create_time, INTERVAL 10 minute) AS ct, src_ip, dst_ip, SUM(pack_size) AS p FROM `table` WHERE create_time &lt; FROM_UNIXTIME(1669968000) AND create_time &gt;= FROM_UNIXTIME(1669860000) GROUP BY ct, src_ip, dst_ip) AS u GROUP BY `ct` ORDER BY ct<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>es的lens各个点的值是怎么计算的</title>
    <link href="/2022/12/20/es%E7%9A%84lens%E7%9A%84%E5%80%BC%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E7%9A%84/"/>
    <url>/2022/12/20/es%E7%9A%84lens%E7%9A%84%E5%80%BC%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://imgse.com/i/z0aMR0"><img src="https://s1.ax1x.com/2022/12/01/z0aMR0.png" alt="z0aMR0.png"></a></p><p>主要讨论关于图上的值 6974378是如何计算的</p><p>通过实验，12:00这一个时刻发现这个值在ES中的计算方法对应的SQL可以写为：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">select</span> <span class="hljs-meta">SUM</span>(pack_size) <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> create_time &lt; FROM_UNIX<span class="hljs-meta">TIME</span>(1669867260) <span class="hljs-keyword">AND</span> create_time &gt;= FROM_UNIX<span class="hljs-meta">TIME</span>(1669867200)<br></code></pre></td></tr></table></figure><p>1669867260对应的时间戳是12:00，1669867200对应的时间戳是12:01</p><p>所以显示的数组是每分钟为一个单位计算的和，后台配置的是SUM</p><p>所以图上配置的图表写字节&#x2F;每秒不合适，应该写字节&#x2F;每分钟，和下面横坐标的per minute对应</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>把swagger文档的访问放到路由中</title>
    <link href="/2022/12/13/%E6%8A%8Aswagger%E6%96%87%E6%A1%A3%E7%9A%84%E8%AE%BF%E9%97%AE%E6%94%BE%E5%88%B0%E8%B7%AF%E7%94%B1%E4%B8%AD/"/>
    <url>/2022/12/13/%E6%8A%8Aswagger%E6%96%87%E6%A1%A3%E7%9A%84%E8%AE%BF%E9%97%AE%E6%94%BE%E5%88%B0%E8%B7%AF%E7%94%B1%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<p><strong>应该使用Raw函数而不是Exec函数，我尝试在连接clickhouse之后运行原始SQL语句，发现使用Exec会报错，但是用Raw的话就不会报错了，使用Exec报错似乎是在Scan调用的时候报错的</strong></p><p>**关于具体如何写，参考 **<a href="https://gorm.io/docs/sql_builder.html">https://gorm.io/docs/sql_builder.html</a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>需要增加一条单独的路由，通过该路由可以访问swagger格式的api文档。且支持配置该路由是否开启，默认开启，在生产环节中不开启。</p><p>PS：我项目使用的是go-zero框架。</p><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><p>收集了一些资料，首先发现了这种写法：</p><p>首先是生成的router文件：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">func RegisterHandlers(<span class="hljs-keyword">server</span> *rest.<span class="hljs-keyword">Server</span>, serverCtx *svc.ServiceContext) &#123;<br><span class="hljs-keyword">server</span>.AddRoutes(<br>[]rest.Route&#123;<br>&#123;<br><span class="hljs-keyword">Method</span>:  http.MethodGet,<br><span class="hljs-type">Path</span>:    &quot;/apiswagger&quot;,<br><span class="hljs-keyword">Handler</span>: apiSwaggerHandler(serverCtx),<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-built_in">apiSwaggerHandler</span>(svcCtx *svc.ServiceContext) http<span class="hljs-selector-class">.HandlerFunc</span> &#123;<br>return <span class="hljs-built_in">func</span>(w http<span class="hljs-selector-class">.ResponseWriter</span>, r *http.Request) &#123;<br>fs := http<span class="hljs-selector-class">.FileServer</span>(http<span class="hljs-selector-class">.Dir</span>(<span class="hljs-string">&quot;./swaggerui&quot;</span>))<br>fs<span class="hljs-selector-class">.ServeHTTP</span>(w, r)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>apiSwaggerHandler实现部分可以参考上面的写法，这样访问 <code>/apiswagger</code>路由的时候就会返回运行目录下的swaggerui目录下的index.html目录。测试访问了 <code>apiswagger</code>路由，在浏览器查看发现页面空白。但是postman可以显示index.html内容。</p><p>又继续收集了一些资料，尝试了另一种方法启动：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">func <span class="hljs-selector-tag">main</span>() &#123;<br>fs := http.<span class="hljs-built_in">FileServer</span>(http.<span class="hljs-built_in">Dir</span>(<span class="hljs-string">&quot;./apiswagger&quot;</span>))<br>http.<span class="hljs-built_in">Handle</span>(<span class="hljs-string">&quot;/&quot;</span>, fs)<br><br>err := http.<span class="hljs-built_in">ListenAndServe</span>(<span class="hljs-string">&quot;:9000&quot;</span>, nil)<br>if err != nil &#123;<br>log<span class="hljs-selector-class">.Fatal</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现这样写是可以正常显示页面的。</p><p>于是将index.html修改了一下，里面只有 <code>hello world</code>没有一些css和js的引用，发现可以正常显示。猜测也许go-zero只能显示单独的index.html，于是首先尝试将swaggerui目录下的所有css,js等文件集合到html中，发现集合起来太过复杂且文件很长很多，无法维护，最终也没有集合成功。</p><p>然后在浏览器打开开发者模式查看，发现获取css文件和js都失败了，猜测go zero可能对路由控制过于严格。</p><p><a href="https://imgse.com/i/zdqWDO"><img src="https://s1.ax1x.com/2022/11/29/zdqWDO.png" alt="zdqWDO.png"></a></p><p>继续搜罗资料，发现go zero需要一个个路由的定义，改成了如下写法：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"> <span class="hljs-comment">// 这是main函数中</span><br> server := rest.MustNewServer(c.RestConf)<br>if c.SwaggerEnabled &#123;<br><span class="hljs-built_in">staticFileHandler</span>(server)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">staticFileHandler</span><span class="hljs-params">(engine *rest.Server)</span></span> &#123;<br>path := <span class="hljs-string">&quot;apiswagger&quot;</span><br>rd, _ := ioutil.ReadDir(path)<br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> rd &#123;<br>filename := f.Name()<br>path := <span class="hljs-string">&quot;/apiswagger/&quot;</span> + filename<br>engine.AddRoute(<br>rest.Route&#123;<br>Method:  http.MethodGet,<br>Path:    path,<br>Handler: dirhandler(<span class="hljs-string">&quot;/apiswagger/&quot;</span>, <span class="hljs-string">&quot;apiswagger&quot;</span>),<br>&#125;)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dirhandler</span><span class="hljs-params">(patern, filedir <span class="hljs-type">string</span>)</span></span> http.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<br>handler := http.StripPrefix(patern, http.FileServer(http.Dir(filedir)))<br>handler.ServeHTTP(w, req)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>仍然在.api文件定义了swagger的路由，然后apiSwaggerHandler单独开启路由，发现这样可以访问 <code>apiswagger</code>路由可以成功显示页面，查看F12也可以看到成功获取到了css和js等文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-built_in">apiSwaggerHandler</span>(svcCtx *svc.ServiceContext) http<span class="hljs-selector-class">.HandlerFunc</span> &#123;<br>return <span class="hljs-built_in">func</span>(w http<span class="hljs-selector-class">.ResponseWriter</span>, r *http.Request) &#123;<br><span class="hljs-keyword">if</span> svcCtx<span class="hljs-selector-class">.Config</span><span class="hljs-selector-class">.SwaggerEnabled</span> &#123;<br>fs := http<span class="hljs-selector-class">.FileServer</span>(http<span class="hljs-selector-class">.Dir</span>(<span class="hljs-string">&quot;./apiswagger&quot;</span>))<br>http<span class="hljs-selector-class">.StripPrefix</span>(<span class="hljs-string">&quot;/apiswagger/&quot;</span>, fs)<span class="hljs-selector-class">.ServeHTTP</span>(w, r)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>唯一需要注意的可能就是http.StripPrefix的用法，比如</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span>.StripPrefix(<span class="hljs-string">&quot;/tmpfiles/&quot;</span>, <span class="hljs-keyword">http</span>.FileServer(<span class="hljs-keyword">http</span>.Dir(<span class="hljs-string">&quot;/tmp&quot;</span>)))<br></code></pre></td></tr></table></figure><p>的功能就是当访问路由是&#x2F;tmpfiles开头的时候，比如访问了&#x2F;tmpfiles&#x2F;a，那么这个函数将会自动返回目录&#x2F;tmp下a的数据，访问&#x2F;tmpfiles&#x2F;b路由时，将会自动返回目录&#x2F;tmp下b的数据，这个函数在go开启静态服务器的时候很有用。</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>主要问题还在于对前端不熟悉吧，居然没第一时间想到要去看看css和js有没有成功被获取到。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.alexedwards.net/blog/serving-static-sites-with-go">Serving Static Sites with Go</a></p><p><a href="https://www.cnblogs.com/pangxiaox/p/16281197.html">go-zero部署静态资源页</a></p><p><a href="https://stackoverflow.com/questions/27945310/why-do-i-need-to-use-http-stripprefix-to-access-my-static-files">Why do I need to use http.StripPrefix to access my static files?</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse查询实践与进阶</title>
    <link href="/2022/12/13/clickhouse%E6%9F%A5%E8%AF%A2%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/12/13/clickhouse%E6%9F%A5%E8%AF%A2%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<p>table里记录了一些流量详情，流量包括源IP src_ip，目标IP dst_ip，数据包大小pack_size，创建时间create_time</p><p>下面是一些要统计的内容</p><h2 id="一个ip和多少个ip通信了"><a href="#一个ip和多少个ip通信了" class="headerlink" title="一个ip和多少个ip通信了"></a>一个ip和多少个ip通信了</h2><p>查询每个src_ip对应有多少个dst_ip，每个dst_ip对应多少个src_ip，也就是一个ip和多少个ip通信了，SQL语法如下：主要就是union all的两边。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> p, <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span>(q)) <span class="hljs-keyword">from</span> (<br><span class="hljs-keyword">select</span> r<span class="hljs-number">.1</span> <span class="hljs-keyword">as</span> p, r<span class="hljs-number">.2</span> <span class="hljs-keyword">as</span> q <span class="hljs-keyword">from</span> (<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span>(tuple(src_ip,dst_ip)) <span class="hljs-keyword">as</span> r<br><span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span><br><span class="hljs-keyword">where</span> create_time <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2022-12-03 10:00:00&#x27;</span> <span class="hljs-keyword">and</span> create_time <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2022-12-03 10:10:00&#x27;</span><br>)<br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <br><span class="hljs-keyword">select</span> r<span class="hljs-number">.2</span> <span class="hljs-keyword">as</span> p, r<span class="hljs-number">.1</span> <span class="hljs-keyword">as</span> q <span class="hljs-keyword">from</span> (<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span>(tuple(src_ip,dst_ip)) <span class="hljs-keyword">as</span> r<br><span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span><br><span class="hljs-keyword">where</span> create_time <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2022-12-03 10:00:00&#x27;</span> <span class="hljs-keyword">and</span> create_time <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2022-12-03 10:10:00&#x27;</span><br>)<br>)<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> p<br></code></pre></td></tr></table></figure><h2 id="数据包大小分布"><a href="#数据包大小分布" class="headerlink" title="数据包大小分布"></a>数据包大小分布</h2><p>要计算pack_size&lt;100的数据包有多少个，100&lt;&#x3D;pack_size&lt;200的数据包有多少个，200&lt;&#x3D;pack_size&lt;300的数据包有多少个等等</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  multiIf(pack_size <span class="hljs-operator">&lt;</span><span class="hljs-number">100</span>, <span class="hljs-number">1</span>, pack_size <span class="hljs-operator">&lt;</span><span class="hljs-number">200</span>, <span class="hljs-number">2</span>, pack_size <span class="hljs-operator">&lt;</span><span class="hljs-number">300</span>, <span class="hljs-number">3</span>, pack_size <span class="hljs-operator">&lt;</span><span class="hljs-number">400</span>, <span class="hljs-number">4</span>, pack_size <span class="hljs-operator">&lt;</span><span class="hljs-number">500</span>, <span class="hljs-number">5</span>, pack_size <span class="hljs-operator">&lt;</span><span class="hljs-number">600</span>, <span class="hljs-number">6</span>, pack_size <span class="hljs-operator">&lt;</span><span class="hljs-number">700</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>),pack_size <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span><br><span class="hljs-keyword">where</span> create_time <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2022-12-03 10:00:00&#x27;</span> <span class="hljs-keyword">and</span> create_time <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2022-12-03 10:10:00&#x27;</span><br>limit <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>这个是运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">3274<br>3274<br>2138<br>3274<br>160<br>7638<br>160<br>2122<br>2138<br>2198<br></code></pre></td></tr></table></figure><p>改成这样也可以：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  multiIf(pack_size <span class="hljs-operator">&lt;</span><span class="hljs-number">100</span>, <span class="hljs-number">1</span>, pack_size <span class="hljs-operator">&lt;</span><span class="hljs-number">200</span>, <span class="hljs-number">2</span>, pack_size <span class="hljs-operator">&lt;</span><span class="hljs-number">300</span>, <span class="hljs-number">3</span>, pack_size <span class="hljs-operator">&lt;</span><span class="hljs-number">400</span>, <span class="hljs-number">4</span>, pack_size <span class="hljs-operator">&lt;</span><span class="hljs-number">500</span>, <span class="hljs-number">5</span>, pack_size <span class="hljs-operator">&lt;</span><span class="hljs-number">600</span>, <span class="hljs-number">6</span>, pack_size <span class="hljs-operator">&lt;</span><span class="hljs-number">700</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>),<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span><br><span class="hljs-keyword">where</span> create_time <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2022-12-03 10:00:00&#x27;</span> <span class="hljs-keyword">and</span> create_time <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2022-12-03 10:10:00&#x27;</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>主要就是通过<a href="https://clickhouse.com/docs/zh/sql-reference/functions/conditional-functions">multiIf</a>实现的。</p><blockquote><p>下面的内容来自clickhouse官方文档：</p><p>multiIf允许您在查询中更紧凑地编写<a href="https://clickhouse.com/docs/zh/sql-reference/operators/#operator_case">CASE</a>运算符。</p><p><strong>语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">multiIf(cond_1, then_1, cond_2, then_2, ..., <span class="hljs-keyword">else</span>)<br></code></pre></td></tr></table></figure><p>您可以使用<a href="https://clickhouse.com/docs/zh/operations/settings/settings#short-circuit-function-evaluation">short_circuit_function_evaluation</a> 设置，根据短路方案计算 <code>multiIf</code> 函数。如果启用此设置，则 <code>then_i</code> 表达式仅在 <code>((NOT cond_1) AND (NOT cond_2) AND ... AND (NOT cond_&#123;i-1&#125;) AND cond_i)</code> 为真，<code>cond_i </code>将仅对 <code>((NOT cond_1) AND (NOT cond_2) AND ... AND (NOT cond_&#123;i-1&#125;))</code> 为真的行进行执行。例如，执行查询“SELECT multiIf(number &#x3D; 2, intDiv(1, number), number &#x3D; 5) FROM numbers(10)”时不会抛出除以零的异常。</p><p><strong>参数:</strong></p><ul><li><code>cond_N</code> — 函数返回<code>then_N</code>的条件。</li><li><code>then_N</code> — 执行时函数的结果。</li><li><code>else</code> — 如果没有满足任何条件，则为函数的结果。</li></ul><p>该函数接受<code>2N + 1</code>参数。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DNS简介</title>
    <link href="/2022/11/25/DNS%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/11/25/DNS%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>DNS</p><p>域名和与之关联的信息，就构成了一条 <strong>DNS记录</strong> （ <em>DNS record</em> ）。DNS记录可以理解成一个键值对：</p><ul><li>键：域名；</li><li>值：与域名关联的值；</li></ul><p>除了 IP 地址，DNS记录值还可以是 IPv6 地址、别名、文本等等。</p><table><thead><tr><th>类型</th><th>目的</th></tr></thead><tbody><tr><td>A</td><td>地址记录，用来指定域名的 IPv4 地址，如果需要将域名指向一个 IP 地址，就需要添加 A 记录。</td></tr><tr><td>AAAA</td><td>用来指定主机名(或域名)对应的 IPv6 地址记录。</td></tr><tr><td>CNAME</td><td>如果需要将域名指向另一个域名，再由另一个域名提供 ip 地址，就需要添加 CNAME 记录。</td></tr><tr><td>MX</td><td>如果需要设置邮箱，让邮箱能够收到邮件，需要添加 MX 记录。</td></tr><tr><td>NS</td><td>域名服务器记录，如果需要把子域名交给其他 DNS 服务器解析，就需要添加 NS 记录。</td></tr><tr><td>SOASOA</td><td>这种记录是所有区域性文件中的强制性记录。它必须是一个文件中的第一个记录。</td></tr><tr><td>TXT</td><td>可以写任何东西，长度限制为 255。绝大多数的 TXT记录是用来做 SPF 记录(反垃圾邮件)。</td></tr></tbody></table><p>记录类型也就是 DNS 报文中，问题记录和资源记录的类型（ Type ）。</p><p>除此之外，还有一些不太常见的DNS类型：</p><p>AFSDB记录 - 此记录用于由Carnegie Melon开发的Andrew File System（AFS）的客户端。AFSDB记录用于查找其他AFS单元。</p><p>APL记录 - “地址前缀列表”是一个实验记录，用于指定地址范围列表。</p><p>CAA记录 - 这是“证书颁发机构授权”记录，它允许域所有者声明哪个证书颁发机构可以为该域颁发证书。如果不存在CAA记录，则任何人都可以为域颁发证书。这些记录也由子域继承。</p><p>DNSKEY记录 - “DNS密钥记录”包含用于验证域名系统安全扩展（DNSSEC）签名的公钥。</p><p>CDNSKEY记录 - 这是DNSKEY记录的子副本，旨在转移到父级。</p><p>CERT记录 - “证书记录”存储公钥证书。</p><p>DCHID记录 - “DHCP标识符”存储动态主机配置协议（DHCP）的信息，DHCP是IP网络上使用的标准化网络协议。</p><p>DNAME记录 - “委托名称”记录创建域别名，就像CNAME一样，但此别名也将重定向所有子域。例如，如果’example.com’的所有者购买了域名’website.net’并给了它一个指向’example.com’的DNAME记录，那么该指针也将扩展到’blog.website.net’和任何其他子域名。</p><p>HIP记录 - 此记录使用“主机标识协议”，一种分隔IP地址角色的方法; 此记录最常用于移动计算。</p><p>IPSECKEY记录 - “IPSEC密钥”记录与Internet协议安全性（IPSEC）一起使用，这是一种端到端安全协议框架，是Internet协议套件（TCP &#x2F; IP）的一部分。</p><p>LOC记录 - “位置”记录包含经度和纬度坐标形式的域的地理信息。</p><p>NAPTR记录 - “‘name authority pointer”“域名权限指针”记录可以与SRV记录组合，以基于正则表达式动态创建指向的URI。</p><p>NSEC记录 - “next secure record”“下一个安全记录”是DNSSEC的一部分，它用于证明所请求的DNS资源记录不存在。</p><p>RRSIG记录 - “resource record signature”“资源记录签名”是用于存储用于根据DNSSEC验证记录的数字签名的记录。</p><p>RP记录 - 这是“responsible person”“负责人”记录，它存储负责该域的人员的电子邮件地址。</p><p>SSHFP记录 - 此记录存储“SSH公钥指纹”; SSH代表Secure Shell，它是一种加密网络协议，用于通过不安全的网络进行安全通信。</p><h2 id="dig命令"><a href="#dig命令" class="headerlink" title="dig命令"></a>dig命令</h2><p>DNS 查询实用程序。</p><p>dig （域信息搜索器）命令是一个用于询问 DNS 域名服务器的灵活的工具。它执行 DNS 搜索，显示从受请求的域名服务器返回的答复。</p><p>dig 命令最典型的用法就是查询单个主机的信息。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">dig</span> baidu.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure><p><img src="https://images2017.cnblogs.com/blog/952033/201711/952033-20171103133846138-920653866.png" alt="img"></p><p>dig 命令默认的输出信息比较丰富，大概可以分为 5 个部分。<br>第一部分显示 dig 命令的版本和输入的参数。<br>第二部分显示服务返回的一些技术详情，比较重要的是 status。如果 status 的值为 NOERROR 则说明本次查询成功结束。<br>第三部分中的 “QUESTION SECTION” 显示我们要查询的域名。<br>第四部分的 “ANSWER SECTION” 是查询到的结果。<br>第五部分则是本次查询的一些统计信息，比如用了多长时间，查询了哪个 DNS 服务器，在什么时间进行的查询等等。</p><p>默认情况下 dig 命令查询 A 记录，上图中显示的 A 即说明查询的记录类型为 A 记录。</p><p>我们可以在查<strong>询时指定要查询的 DNS 记录类型：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">dig abc.filterinto.com CNAME                                                     <br><br>; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; abc.filterinto.com CNAME<br>;; global options: +cmd<br>;; Got answer:<br>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 45256<br>;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1<br><br>;; OPT PSEUDOSECTION:<br>; EDNS: version: 0, flags:; udp: 1232<br>;; QUESTION SECTION:<br>;abc.filterinto.com.INCNAME<br><br>;; AUTHORITY SECTION:<br>com.900INSOAa.gtld-servers.net. nstld.verisign-grs.com. 1658127436 1800 900 604800 86400<br><br>;; Query time: 1021 msec<br>;; SERVER: 10.50.4.107#53(10.50.4.107)<br>;; WHEN: Mon Jul 18 14:57:25 CST 2022<br>;; MSG SIZE  rcvd: 120<br></code></pre></td></tr></table></figure><p>这样结果中就只有 CNAME 的记录。其实我们可以在查询中指定任何 DNS 记录的类型。</p><p><strong>从指定的 DNS 服务器上查询</strong></p><p>使用@指定DNS服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dig @8.8.8.8 abc.filterinto.com<br></code></pre></td></tr></table></figure><p>如果不指定 DNS 服务器，dig 会依次使用 &#x2F;etc&#x2F;resolv.conf 里的地址作为 DNS 服务器</p><p><strong>反向查询：查询IP地址对应的域名</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">dig -x 8.8.8.8 +short                                                          <br>dns.google.<br></code></pre></td></tr></table></figure><p><strong>查看TTL</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">dig baidu.com                                                                    <br><br>; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; baidu.com<br>;; global options: +cmd<br>;; Got answer:<br>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 49394<br>;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 5, ADDITIONAL: 8<br><br>;; OPT PSEUDOSECTION:<br>; EDNS: version: 0, flags:; udp: 1232<br>;; QUESTION SECTION:<br>;baidu.com.INA<br><br>;; ANSWER SECTION:<br>baidu.com.401INA220.181.38.148<br>baidu.com.401INA220.181.38.251<br></code></pre></td></tr></table></figure><p>ANSWER SECTION:的401 401就是TTL</p><p><strong>跟踪整个查询过程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dig +trace baidu.com<br></code></pre></td></tr></table></figure><h2 id="NS"><a href="#NS" class="headerlink" title="NS"></a>NS</h2><p>上级 DNS 服务器通过 NS 记录，找到下级 DNS 服务器，直到域名查询完毕。</p><h2 id="mDNS"><a href="#mDNS" class="headerlink" title="mDNS"></a>mDNS</h2><p>mdns 即多播dns（Multicast DNS），mDNS主要实现了在没有传统DNS服务器的情况下使局域网内的主机实现相互发现和通信，使用的端口为5353，遵从dns协议，使用现有的DNS信息结构、名语法和资源记录类型。并且没有指定新的操作代码或响应代码。</p><h3 id="mDNS的作用是"><a href="#mDNS的作用是" class="headerlink" title="mDNS的作用是"></a>mDNS的作用是</h3><p>在局域网中，设备和设备之前相互通信需要知道对方的ip地址的，大多数情况，设备的ip不是静态ip地址，而是通过dhcp 协议动态分配的ip 地址，要进行通信，就必须知道对方的ip地址，<br>mDNS的作用就是解决这个问题</p><h2 id="域名查找"><a href="#域名查找" class="headerlink" title="域名查找"></a>域名查找</h2><p>域名体系：</p><p><img src="/../images/image-20230303113424953.png" alt="image-20230303113424953"></p><p><strong>如果本地域名服务器无法对域名进行解析，就首先求助于根域名服务器。</strong></p><p><strong>权威域名服务器：</strong>这就是前面已经讲过的负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告知发出查询请求的DNS客户，下一步应当找哪一个权威域名服务器。</p><p><strong>各个域的分层上都设有各自的域名服务器，各层域名服务器都了解该层以下分层中所有域名服务器的IP地址。因此它们从根域名服务器开始呈树状结构相互连接。</strong></p><p>一个完整的域名解析过程如下图所示：</p><p><img src="/../images/image-20230303113654927.png" alt="image-20230303113654927"></p><p>这个根据资源名称(域名)来查找地址的过程, 就称为DNS, DNS查找通常会经过下面四步:</p><ul><li>询问Resolver</li><li>询问根服务器</li><li>询问顶级域名服务器</li><li>询问次级域名服务器</li></ul><h3 id="Resolver"><a href="#Resolver" class="headerlink" title="Resolver"></a>Resolver</h3><p><code>resolver</code>就是我们常说的DNS服务器,在Linux系统中可以查看 <code>/etc/resolv.conf</code>文件查看resolver地址,</p><p>resolver通常有个 <code>root-hints</code>文件, 其中硬编码了十三个<strong>根域名服务器</strong>的地址. 当我们向resolver发起DNS请求时,<br>resolver会<strong>同时</strong>向所有根域名服务器发出查找请求,并以最快返回的响应为结果执行下一步的操作. 实际上,<br>resolver会根据响应速度获得一个优先查找的根服务器,并将随后的查找都只向此根服务器进行请求.</p><p>这13个根域名服务器在wireshark中抓包可以看到：</p><p><a href="https://imgse.com/i/zEHMa8"><img src="https://s1.ax1x.com/2022/11/15/zEHMa8.png" alt="zEHMa8.png"></a></p><h3 id="询问根服务器"><a href="#询问根服务器" class="headerlink" title="询问根服务器"></a>询问根服务器</h3><p>一般来说,根服务器处理DNS请求,并且告诉resolver下一步应该去询问哪个顶级服务器. 不过如果根服务器识别出了次级服务器的地址,就会把这个地址返回给resolver的.</p><h3 id="询问顶级域名服务器"><a href="#询问顶级域名服务器" class="headerlink" title="询问顶级域名服务器"></a>询问顶级域名服务器</h3><p>如果上一步根服务器没有识别出次级域名服务器的地址,那么就会给resolver返回顶级服务器的地址,从而resolver<br>需要<strong>再次</strong>向顶级域名服务器发起查询.</p><p>顶级域名服务器收到查询请求后,会将可以真正解析此请求的<strong>次级域名服务器</strong>地址返回给resolver.</p><h3 id="询问次级域名服务器"><a href="#询问次级域名服务器" class="headerlink" title="询问次级域名服务器"></a>询问次级域名服务器</h3><p>resolver向次级域名服务器发起DNS查询请求, 次级域名<br>服务器接收到请求后即返回对应次级域名的IP地址.</p><p>值得一提的是,次级域名还有如下的别名:</p><ul><li>用户DNS名称服务器(User DNS name server)</li><li>权威名称服务器(Authoritative name server)</li></ul><p>其中后者更广为人知一些,因为SLD是查询到对应域名IP地址的最后一步(如果有的话), 而且这个域名服务器也负责<br>对应资源的DNS设置,如添加不同主机地址的记录等.</p><p>resolver从次级域名服务器获得了域名的IP地址,并将其返回给用户,只此便完成了一次DNS查询.</p><p><a href="https://www.cnblogs.com/pannengzhi/p/6262076.html">参考1</a></p><p><a href="https://www.cnblogs.com/pannengzhi/p/6262076.html">参考2</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>elasticsearch Lens间隔与时间范围的关系.md</title>
    <link href="/2022/11/25/elasticsearch%E9%97%B4%E9%9A%94%E4%B8%8E%E6%97%B6%E9%97%B4%E8%8C%83%E5%9B%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2022/11/25/elasticsearch%E9%97%B4%E9%9A%94%E4%B8%8E%E6%97%B6%E9%97%B4%E8%8C%83%E5%9B%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>下面的图是一个Lens图，接下来讨论选定时间范围和结果统计使用的时间间隔的关系。</p><p><a href="https://imgse.com/i/zkfDeJ"><img src="https://s1.ax1x.com/2022/11/14/zkfDeJ.png" alt="zkfDeJ.png"></a></p><p>前提：因为要写一些接口，这些接口需要指定一个interval参数，和图上下面的红框里的对应，红框里可以出现的取值就是interval可以取的值，于是测试了一下，上方取不同的时间范围，下方对应的per后面的值是什么，测试结果如下：</p><table><thead><tr><th>上方的时间范围</th><th>per后跟的值</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>更多。。。。</td><td>更多。。。。等</td></tr><tr><td>[50m秒 ,1h]</td><td>30秒</td></tr><tr><td>[2h, 8h]</td><td>1分钟</td></tr><tr><td>[9h, 16h]</td><td>5分钟</td></tr><tr><td>[17h, 49h]</td><td>10分钟</td></tr><tr><td>[50h, 99h]</td><td>30分钟</td></tr><tr><td>[100h,299h]</td><td>1小时</td></tr><tr><td>[300h, 1119h]</td><td>3小时</td></tr><tr><td>[1200h, 2399h]</td><td>12小时</td></tr><tr><td>[2400h, 16799h]</td><td>24小时</td></tr><tr><td>[16800h,一个懒得计算的值]</td><td>1周</td></tr><tr><td>[一个懒得计算的值,一个懒得计算的值]</td><td>30天</td></tr><tr><td>更多。。。。</td><td>更多。。。。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse查询语法</title>
    <link href="/2022/11/25/clickhouse%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/11/25/clickhouse%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="group-by-ID"><a href="#group-by-ID" class="headerlink" title="group by ID"></a>group by ID</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">select</span>  src_ip, dst_ip, SUM(pack_size) AS value, toStartOfInterval(create_time, INTERVAL <span class="hljs-number">15</span> minute) AS time<br><span class="hljs-attribute">from</span> tableA <br><span class="hljs-attribute">where</span> create_time &gt;= &#x27;<span class="hljs-number">2022</span>-<span class="hljs-number">11</span>-<span class="hljs-number">17</span> <span class="hljs-number">16</span>:<span class="hljs-number">15</span>:<span class="hljs-number">00</span>&#x27; and  create_time&lt; &#x27;<span class="hljs-number">2022</span>-<span class="hljs-number">11</span>-<span class="hljs-number">17</span> <span class="hljs-number">17</span>:<span class="hljs-number">20</span>:<span class="hljs-number">00</span>&#x27;<br><span class="hljs-attribute">group</span> by <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-attribute">order</span> by <span class="hljs-number">4</span>, <span class="hljs-number">3</span> desc<br></code></pre></td></tr></table></figure><p>clickhouse的group by和order by可以使用字母，字母代表select后面的第几个元素，比如上面的查询效果等同于</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span>  src_ip, dst_ip, SUM(pack_size) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">value</span>, toStartOfInterval(create_time, <span class="hljs-type">INTERVAL</span> <span class="hljs-number">15</span> minute) <span class="hljs-keyword">AS</span> <span class="hljs-type">time</span><br><span class="hljs-keyword">from</span> tableA <br><span class="hljs-keyword">where</span> create_time &gt;= <span class="hljs-string">&#x27;2022-11-17 16:15:00&#x27;</span> <span class="hljs-keyword">and</span>  create_time&lt; <span class="hljs-string">&#x27;2022-11-17 17:20:00&#x27;</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-type">time</span>, src_ip, dst_ip<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-type">time</span>, <span class="hljs-keyword">value</span> <span class="hljs-keyword">desc</span><br></code></pre></td></tr></table></figure><h2 id="toStartOfInterval"><a href="#toStartOfInterval" class="headerlink" title="toStartOfInterval"></a>toStartOfInterval</h2><p>获得指定时间根据interval划分后的时间，相当于指定时间除以interval后取整然后乘以interval，比如15点12分和10分钟interval后的结果就是15点10分。有一些场景，比如统计每10分钟的平均数量，那么一小时就 有6个平均数量的值的时候，使用toStartOfInterval对时间进行处理就很有用，可以判断这个时间应该算到第几个十分钟里去。比如这里kibana的Lens图像是每10分钟为单位的，对应到CK的查询可以用toStartOfInterval实现聚合，参考上面的SQL语句。</p><p><a href="https://imgse.com/i/zYiWdO"><img src="https://s1.ax1x.com/2022/11/25/zYiWdO.png" alt="zYiWdO.png"></a></p><h2 id="quantileExact"><a href="#quantileExact" class="headerlink" title="quantileExact"></a>quantileExact</h2><p>计算数字序列的<a href="https://en.wikipedia.org/wiki/Quantile">分位数</a>。</p><p>语法：<code>quantileExact(level)(expr)</code></p><p>比如 <code>SELECT quantileExact(number) FROM numbers(10)</code>返回的 <code>numbers(10)</code>默认的分位数5</p><h2 id="round"><a href="#round" class="headerlink" title="round"></a>round</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> round(<span class="hljs-number">1</span>.<span class="hljs-number">1233456789</span>,<span class="hljs-number">6</span>) <br></code></pre></td></tr></table></figure><p>返回了1.123346，就是取1.1233456789到小数点后的6位，不会做四舍五入</p><p>bewtween a and b的范围是[a,b]</p><p>涉及到时间查询，一般写左闭右开，比如t<end_time and t>&#x3D;start_time</end_time></p><h2 id="一个复杂查询的示例与解释"><a href="#一个复杂查询的示例与解释" class="headerlink" title="一个复杂查询的示例与解释"></a>一个复杂查询的示例与解释</h2><h3 id="源语句"><a href="#源语句" class="headerlink" title="源语句"></a>源语句</h3><p>这是工作解决某个问题对应的查询语句</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">SELECT</span> <br>  u.ct, <br>  untuple(<br>    arrayJoi<span class="hljs-meta">n</span>(<br>      arraySlice(<br>        arraySort(<br>          (<span class="hljs-keyword">x</span>, y)-&gt;- y, <br>          arrayMap(<br>            (<span class="hljs-keyword">x</span>, y, z) -&gt; (<span class="hljs-keyword">x</span>, y, z), <br>            groupArray(u.src_ip), <br>            groupArray(u.dst_ip), <br>            groupArray(u.p)<br>          ), <br>          groupArray(u.p)<br>        ), <br>        1, <br>        25<br>      )<br>    )<br>  ) <span class="hljs-keyword">AS</span> res <br><span class="hljs-keyword">FROM</span> <br>  (<br>    <span class="hljs-keyword">SELECT</span> <br>      toStartOfInterval(create_time, INTERVAL 1 minute) <span class="hljs-keyword">AS</span> ct, <br>      src_ip, <br>      dst_ip, <br>      <span class="hljs-meta">SUM</span>(pack_size) <span class="hljs-keyword">AS</span> p <br>    <span class="hljs-keyword">FROM</span> <br>      `tableA` <br>    <span class="hljs-keyword">WHERE</span> <br>      create_time &lt; FROM_UNIX<span class="hljs-meta">TIME</span>(1668700800) <br>      <span class="hljs-keyword">AND</span> create_time &gt;= FROM_UNIX<span class="hljs-meta">TIME</span>(1668672000) <br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <br>      src_ip, <br>      dst_ip, <br>      ct<br>  ) <span class="hljs-keyword">as</span> u <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <br>  `ct` <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <br>  ct<br></code></pre></td></tr></table></figure><p>相关的函数</p><p><strong>untuple</strong></p><p>将元组拆分为列，umtuple(x) as res得到的列分别为res.1 res.2</p><p>例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">SELECT<br>    (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-number">.1</span>,<br>    (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-number">.2</span><br><br>/*<br>┌─tupleElement(<span class="hljs-built_in">tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-number">1</span>)─┬─tupleElement(<span class="hljs-built_in">tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-number">2</span>)─┐<br>│                              <span class="hljs-number">1</span> │ a                              │<br>└────────────────────────────────┴────────────────────────────────┘<br>*/<br></code></pre></td></tr></table></figure><p><strong>arrayJoin</strong></p><p>用于将结果中的数组展开，来自官方的例子</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span> arrayJoin([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">AS</span> src) <span class="hljs-keyword">AS</span> dst, <span class="hljs-string">&#x27;Hello&#x27;</span>, src<br>┌─dst─┬─\<span class="hljs-string">&#x27;Hello\&#x27;</span>─┬─src─────┐<br>│   <span class="hljs-number">1</span> │ Hello     │ [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] │<br>│   <span class="hljs-number">2</span> │ Hello     │ [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] │<br>│   <span class="hljs-number">3</span> │ Hello     │ [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] │<br>└─────┴───────────┴─────────┘<br></code></pre></td></tr></table></figure><p><strong>arraySlice</strong></p><p>返回一个子数组，包含从指定位置的指定长度的元素。arraySlice[arr,1,n]返回arr[1:n]共n个元素的数组</p><p><strong>groupArray</strong></p><p>创建数组，根据某列</p><p><strong>arrayMap</strong></p><p>根据多个数组，创建数组间的映射关系返回映射结果。这里的根据3个数组返回这三个数组拼成的元组。</p><p><strong>arraySort</strong></p><p>返回升序排序 <code>arr1</code>的结果。如果指定了 <code>func</code>函数，则排序顺序由 <code>func</code>的结果决定。</p><p>示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> arraySort((x, y)<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> y,[<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">┌─res────────────────┐<br>│ [&#x27;world&#x27;, &#x27;hello&#x27;] │<br>└────────────────────┘<br></code></pre></td></tr></table></figure><p><strong>toTypeName(x)可以获得数据类型</strong></p><p><code>SELECT toTypeName(arrayMap((x, y) -&gt; (x, y), [1, 2, 3], [4, 5, 6]))</code></p><h3 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h3><p>过了很长时间后，在看将clickhouse的书时发现上面的查询语句可以用一种更简单的写法实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">SELECT <br>     toStartOfInterval(create_time, INTERVAL <span class="hljs-number">1</span> minute) AS ct, <br>     src_ip, <br>     dst_ip, <br>     SUM(pack_size) AS p <br>   FROM <br>     flora.gopacket<br>   WHERE <br>       create_time &lt; FROM_UNIXTIME(<span class="hljs-number">1676455200</span>) <br>       AND create_time &gt;= FROM_UNIXTIME(<span class="hljs-number">1676433600</span>)<br>   GROUP BY <br>     src_ip, <br>     dst_ip, <br>     ct<br>    ORDER BY ct, p DESC <br>    LIMIT <span class="hljs-number">25</span> BY ct<br></code></pre></td></tr></table></figure><p>这个功能就是相当于在排序完成之后，对于每个ct，取前25个值。因为之前已经ORDER BY p DESC了，所以可以获得前25个值最大的p。</p><p>参考</p><p><a href="https://stackoverflow.com/questions/70740482/in-clickhouse-how-to-parse-date-datetime-in-a-given-format">in-clickhouse-how-to-parse-date-datetime-in-a-given-format</a></p><p><a href="https://clickhouse.com/docs/en/sql-reference/functions/date-time-functions/#tostartofhour">tostartofhour</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go zero生成swagger文档与查看</title>
    <link href="/2022/11/24/go%20zero%E7%94%9F%E6%88%90swagger%E6%96%87%E6%A1%A3%E4%B8%8E%E6%9F%A5%E7%9C%8B/"/>
    <url>/2022/11/24/go%20zero%E7%94%9F%E6%88%90swagger%E6%96%87%E6%A1%A3%E4%B8%8E%E6%9F%A5%E7%9C%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="生成json格式的API文档"><a href="#生成json格式的API文档" class="headerlink" title="生成json格式的API文档"></a>生成json格式的API文档</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">goctl api <span class="hljs-keyword">plugin</span> -<span class="hljs-keyword">plugin</span> goctl-swagger=<span class="hljs-string">&quot;swagger -filename example.json&quot;</span> -api example.api -<span class="hljs-keyword">dir</span> .<br></code></pre></td></tr></table></figure><h2 id="本地查看生成的swagger文档"><a href="#本地查看生成的swagger文档" class="headerlink" title="本地查看生成的swagger文档"></a>本地查看生成的swagger文档</h2><p>启动swagger editor编辑器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/swagger-api/swagger-editor.git<br>cd swagger-editor<br>npm install<br>npm run build<br>npm start<br></code></pre></td></tr></table></figure><p>本地启动swagger ui，查看swagger文档</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/swagger-api/</span>swagger-ui.git<br>cd swagger-ui<br>npm run dev<br></code></pre></td></tr></table></figure><p>将json或者yml格式的swagger文档比如example.json复制到dev-helpers目录下</p><p>将dev-helpers&#x2F;dev-helper-initializer.js文件的</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">url:</span> <span class="hljs-string">&quot;https://petstore.swagger.io/v2/swagger.json&quot;</span>,<br></code></pre></td></tr></table></figure><p>替换为</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">url:</span> <span class="hljs-string">&quot;./example.json&quot;</span>,<br></code></pre></td></tr></table></figure><p>打开<a href="http://localhost:3200/%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E6%95%88%E6%9E%9C%E3%80%82">http://localhost:3200/即可看到效果。</a></p><h2 id="PS-本地开启swagger-editor"><a href="#PS-本地开启swagger-editor" class="headerlink" title="PS: 本地开启swagger editor"></a>PS: 本地开启swagger editor</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:swagger-api/swagger-editor.git<br>cd swagger-editor<br>npm <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure><p>可以在<a href="http://localhost:3001/%E7%BC%96%E8%BE%91swagger%E6%96%87%E6%A1%A3">http://localhost:3001/编辑swagger文档</a></p><p>参考</p><p><a href="https://github.com/swagger-api/swagger-ui/blob/master/docs/development/setting-up.md">Setting up a dev environment</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go-zero使用小结</title>
    <link href="/2022/11/24/go-zero%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <url>/2022/11/24/go-zero%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><ul><li>变量命名应尽量描述其内容，而不是类型</li><li>当变量名称在定义和最后一次使用之间的距离很短时，简短的名称看起来会更好。</li><li>在遇到for，if等循环或分支时，推荐单个字母命名来标识参数和返回值</li><li>文件名尽量小写，除unit test外避免下划线(_)</li><li><strong>不可exported的必须首字母小写</strong></li><li><strong>import 按照 <code>官方包</code>，NEW LINE，<code>当前工程包</code>，NEW LINE，<code>第三方依赖包</code>顺序引入</strong></li><li>避免下划线(_)接收error</li><li>建议一个block（比如if是一个block）结束空一行，如if、for等</li><li>return前空一行</li></ul><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>直接执行：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">goctl api <span class="hljs-built_in">new</span> packet<br><span class="hljs-built_in">go</span> <span class="hljs-built_in">mod</span> tidy<br></code></pre></td></tr></table></figure><p>修改packet&#x2F;internal&#x2F;logic&#x2F;packetlogic.go写具体的业务逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">return</span> &amp;types.Response&#123;<br>       Message: <span class="hljs-string">&quot;Hello go-zero&quot;</span>,<br>   &#125;, <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go run packet.go -f etc/packet-api.yaml <br></code></pre></td></tr></table></figure><p>GET <a href="http://localhost:8888/from/me">http://localhost:8888/from/me</a> 或者 GET <a href="http://localhost:8888/from/you">http://localhost:8888/from/you</a> 即可看到效果。</p><p>上面的是单体服务的创建，go-zero还提供了微服务的创建方法，微服务和单体服务最大的不同就是微服务之间会互相调用，即会用一些rpc调用。</p><blockquote><p>微服务的创建暂时没有看</p></blockquote><h2 id="进阶指南"><a href="#进阶指南" class="headerlink" title="进阶指南"></a>进阶指南</h2><h3 id="系统设计的一些建议"><a href="#系统设计的一些建议" class="headerlink" title="系统设计的一些建议"></a>系统设计的一些建议</h3><p>一般我们需要按照业务横向拆分，将一个系统拆分成多个子系统，每个子系统应拥有独立的持久化存储，缓存系统。</p><p>在设计系统时，尽量做到服务之间调用链是单向的，而非循环调用</p><h3 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h3><p>官方提供的demo下载后的目录结构为，下面的操作基于该demo，而不是我自己自定义的服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">├── README.md<br>├── common<br>├── go.mod<br>├── go.sum<br>└── service<br>    ├── search<br>    │   └── api<br>    └── user<br>        ├── api<br>        │   └── user.api<br>        ├── model<br>        │   └── user.sql<br>        └── rpc<br>            └── user.proto<br></code></pre></td></tr></table></figure><h4 id="models生成"><a href="#models生成" class="headerlink" title="models生成"></a>models生成</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> service/user/model</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">goctl model mysql ddl -src user.sql -<span class="hljs-built_in">dir</span> . -c</span><br></code></pre></td></tr></table></figure><h4 id="API编写"><a href="#API编写" class="headerlink" title="API编写"></a>API编写</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim service/user/api/user.api<br></code></pre></td></tr></table></figure><p>补充api的定义</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> service/user/api</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">goctl api go -api user.api -<span class="hljs-built_in">dir</span> .</span> <br></code></pre></td></tr></table></figure><h4 id="业务编码"><a href="#业务编码" class="headerlink" title="业务编码"></a>业务编码</h4><p><strong>添加Mysql配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim service/user/api/internal/config/config.go<br></code></pre></td></tr></table></figure><p>声明Datasource和CacheRedis</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> config<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;github.com/zeromicro/go-zero/rest&quot;</span><br>    <span class="hljs-string">&quot;github.com/zeromicro/go-zero/core/stores/cache&quot;</span><br>    )<br><br><br><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>    rest.RestConf<br>    Mysql <span class="hljs-keyword">struct</span>&#123;<br>        DataSource <span class="hljs-type">string</span><br>    &#125;<br>  <br>    CacheRedis cache.CacheConf<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>完善yaml配置：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim service/user/api/etc/user-api.yaml<br></code></pre></td></tr></table></figure><p>添加和上面对应的Mysql和CacheRedis的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Name:</span> <span class="hljs-string">user-api</span><br><span class="hljs-attr">Host:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><span class="hljs-attr">Port:</span> <span class="hljs-number">8888</span><br><span class="hljs-attr">Mysql:</span><br>  <span class="hljs-attr">DataSource:</span> <span class="hljs-string">root:xxx@tcp(127.0.0.1)/gozero?charset=utf8mb4&amp;parseTime=true&amp;loc=Asia%2FShanghai</span><br><span class="hljs-attr">CacheRedis:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Host:</span> <span class="hljs-string">$host</span><br>    <span class="hljs-attr">Pass:</span> <span class="hljs-string">$pass</span><br>    <span class="hljs-attr">Type:</span> <span class="hljs-string">node</span><br></code></pre></td></tr></table></figure><p><strong>完善服务依赖：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim service/user/api/internal/svc/servicecontext.go</span><br></code></pre></td></tr></table></figure><p>根据上面的Mysql和Cache Redis的配置，初始化需要使用到的UserModel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ServiceContext <span class="hljs-keyword">struct</span> &#123;<br>    Config    config.Config<br>    UserModel model.UserModel<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServiceContext</span><span class="hljs-params">(c config.Config)</span></span> *ServiceContext &#123;<br>    conn:=sqlx.NewMysql(c.Mysql.DataSource)<br>    <span class="hljs-keyword">return</span> &amp;ServiceContext&#123;<br>        Config: c,<br>        UserModel: model.NewUserModel(conn,c.CacheRedis),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>填充登录逻辑：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim service/user/api/internal/logic/loginlogic.go<br></code></pre></td></tr></table></figure><p>其中一段代码涉及到JWT鉴权的操作，需要参考下面的内容</p><h4 id="jwt鉴权"><a href="#jwt鉴权" class="headerlink" title="jwt鉴权"></a>jwt鉴权</h4><blockquote><p>JSON Web令牌（JWT）是一个开放标准（RFC 7519）</p></blockquote><p>go-zero中，jwt鉴权一般在api层使用，一般在登录时生成JWT，请求后续接口时验证JWT。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim service/user/api/internal/config/config.go<br></code></pre></td></tr></table></figure><p>添加JWT的配置：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs diff">type Config struct &#123;<br>    rest.RestConf<br>    Mysql struct&#123;<br>        DataSource string<br>    &#125;<br>    CacheRedis cache.CacheConf<br><span class="hljs-addition">+    Auth      struct &#123;</span><br><span class="hljs-addition">+       AccessSecret string</span><br><span class="hljs-addition">+       AccessExpire int64</span><br><span class="hljs-addition">+   &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim service/user/api/etc/user-api.yaml<br></code></pre></td></tr></table></figure><p>添加对应的yaml配置项：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff">Name: user-api<br>Host: 0.0.0.0<br>Port: 8888<br>...<br><span class="hljs-addition">+Auth:</span><br><span class="hljs-addition">+  AccessSecret: $AccessSecret</span><br><span class="hljs-addition">+  AccessExpire: 1111 # 单位 秒</span><br></code></pre></td></tr></table></figure><p>完善《业务编码》那块的getJwtToken方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LoginLogic)</span></span> getJwtToken(secretKey <span class="hljs-type">string</span>, iat, seconds, userId <span class="hljs-type">int64</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;....&#125;<br></code></pre></td></tr></table></figure><p>下面完善search服务的JWT相关内容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">touch service<span class="hljs-regexp">/search/</span>api/search.api<br></code></pre></td></tr></table></figure><p>添加search API的定义，需要指定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs api">@server(<br>    jwt: Auth<br>)<br></code></pre></td></tr></table></figure><p>创建 service&#x2F;search&#x2F;api&#x2F;etc&#x2F;search-api.yaml 文件，添加相关配置。</p><p>下面验证 jwt token</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> service/user/api</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run user.go -f etc/user-api.yaml</span><br></code></pre></td></tr></table></figure><p>请求POST <a href="http://127.0.0.1:8888/user/login">http://127.0.0.1:8888/user/login</a> 获取JWT。</p><p>然后生成search的代码，启动search服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd service/search/api<br>go run search.go -f etc/search-api.yaml<br></code></pre></td></tr></table></figure><p> GET <a href="http://127.0.0.1:8889/search/do?name=xxx">http://127.0.0.1:8889/search/do?name=xxx</a> 的 headers 加上 Authorization 才可以成功验证通过，否则会报 401Unauthorized。</p><h4 id="中间件使用"><a href="#中间件使用" class="headerlink" title="中间件使用"></a>中间件使用</h4><p><strong>路由中间件</strong></p><p>在search.api添加中间件声明：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff">@server(<br>    jwt: Auth<br><span class="hljs-addition">+   middleware: Example // 路由中间件声明</span><br>)<br></code></pre></td></tr></table></figure><p><code>internal</code>目录下多一个 <code>middleware</code>的目录</p><p>service&#x2F;search&#x2F;api&#x2F;internal&#x2F;svc&#x2F;servicecontext.go添加Middleware</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs diff">type ServiceContext struct &#123;<br>    Config config.Confi<br><span class="hljs-addition">+   Example rest.Middleware</span><br>&#125;<br><br>func NewServiceContext(c config.Config) *ServiceContext &#123;<br>    return &amp;ServiceContext&#123;<br>        Config: c,<br><span class="hljs-addition">+       Example: middleware.NewExampleMiddleware().Handle,</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>service&#x2F;search&#x2F;api&#x2F;internal&#x2F;middleware&#x2F;examplemiddleware.go添加中间件详细功能：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs diff">package middleware<br><br>import &quot;net/http&quot;<br><br>type ExampleMiddleware struct &#123;<br>&#125;<br><br>func NewExampleMiddleware() *ExampleMiddleware &#123;<br>        return &amp;ExampleMiddleware&#123;&#125;<br>&#125;<br><br>func (m *ExampleMiddleware) Handle(next http.HandlerFunc) http.HandlerFunc &#123;<br><span class="hljs-addition">+    logx.Info(&quot;example middle&quot;)</span><br>    return func(w http.ResponseWriter, r *http.Request) &#123;<br>        // TODO generate middleware implement function, delete after code implementation<br>        // Passthrough to next handler if need<br>        next(w, r)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>全局中间件</strong></p><p>通过rest.Server提供的Use方法即可</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs diff">func main() &#123;<br>    flag.Parse()<br><br>    var c config.Config<br>    conf.MustLoad(*configFile, &amp;c)<br><br>    ctx := svc.NewServiceContext(c)<br>    server := rest.MustNewServer(c.RestConf)<br>    defer server.Stop()<br><br>    // 全局中间件<br><span class="hljs-addition">+    server.Use(func(next http.HandlerFunc) http.HandlerFunc &#123;</span><br><span class="hljs-addition">+        return func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="hljs-addition">+            logx.Info(&quot;global middleware&quot;)</span><br><span class="hljs-addition">+            next(w, r)</span><br><span class="hljs-addition">+        &#125;</span><br><span class="hljs-addition">+    &#125;)</span><br>    handler.RegisterHandlers(server, ctx)<br><br>    fmt.Printf(&quot;Starting server at %s:%d...\n&quot;, c.Host, c.Port)<br>    server.Start()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>错误处理模块是将原来以text返回的错误包装了一下，以json返回了</p><p>在平时的业务开发中，我们可以认为http状态码不为 <code>2xx</code>系列的，都可以认为是http请求错误， 并伴随响应的错误信息，但这些错误信息都是以plain text形式返回的。</p><ul><li><p>业务处理正常</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;successful&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    ....<br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>业务处理异常</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10001</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;参数错误&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>之前的错误都是以plain text的格式返回的，如果想以json格式返回，可以在common中添加一个 <code>errorx/baseerror.go</code>文件，<strong>注意go-zero这里给出的例子中的文件名是直接将多个单词连接在一起的。</strong></p><p><strong>注意这个包叫errorx</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> errorx<br><br><span class="hljs-keyword">const</span> defaultCode = <span class="hljs-number">1001</span><br><br><span class="hljs-keyword">type</span> CodeError <span class="hljs-keyword">struct</span> &#123;<br>    Code <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;code&quot;`</span><br>    Msg  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;msg&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> CodeErrorResponse <span class="hljs-keyword">struct</span> &#123;<br>    Code <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;code&quot;`</span><br>    Msg  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;msg&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCodeError</span><span class="hljs-params">(code <span class="hljs-type">int</span>, msg <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> &amp;CodeError&#123;Code: code, Msg: msg&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDefaultError</span><span class="hljs-params">(msg <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> NewCodeError(defaultCode, msg)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *CodeError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> e.Msg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *CodeError)</span></span> Data() *CodeErrorResponse &#123;<br>    <span class="hljs-keyword">return</span> &amp;CodeErrorResponse&#123;<br>        Code: e.Code,<br>        Msg:  e.Msg,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>将service&#x2F;user&#x2F;api&#x2F;internal&#x2F;logic&#x2F;loginlogic.go里的错误返回部分都改成封装的错误：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff">    case model.ErrNotFound:<br><span class="hljs-deletion">-        return nil, error.New(&quot;用户名不存在&quot;)</span><br><span class="hljs-addition">+        return nil, errorx.NewDefaultError(&quot;用户名不存在&quot;)</span><br></code></pre></td></tr></table></figure><p>此时请求后返回的错误内容为：</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h3r6pqndjcj31io07etal.jpg" alt="WX20220701-094754@2x.png"></p><p>然后在service&#x2F;user&#x2F;api&#x2F;user.go的main函数开启自定义错误：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs diff">func main() &#123;<br>    handler.RegisterHandlers(server, ctx)<br><br><span class="hljs-addition">+    // 自定义错误</span><br><span class="hljs-addition">+    httpx.SetErrorHandler(func(err error) (int, interface&#123;&#125;) &#123;</span><br><span class="hljs-addition">+        switch e := err.(type) &#123;</span><br><span class="hljs-addition">+        case *errorx.CodeError:</span><br><span class="hljs-addition">+            return http.StatusOK, e.Data()</span><br><span class="hljs-addition">+        default:</span><br><span class="hljs-addition">+            return http.StatusInternalServerError, nil</span><br><span class="hljs-addition">+        &#125;</span><br><span class="hljs-addition">+    &#125;)</span><br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h3r6szc1u5j31io0aogo2.jpg" alt="WX20220701-095057@2x.png"></p><p>此时Status为200而不是之前的400</p><h4 id="模板修改"><a href="#模板修改" class="headerlink" title="模板修改"></a>模板修改</h4><p>模板修改模块是实现无论是否出错了，都返回统一的模板</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;OK&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>主要是为了实现在正常和错误的情况下返回的数据格式是一样的，《错误处理》那块改完了，在正常情况下返回的数据是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小明&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;gender&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;男&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;accessToken&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NTY2NDYzNjEsImlhdCI6MTY1NjY0MDM2MSwidXNlcklkIjoxfQ.yhiPdecQFnBjjPnRLWEpWIeoI5sZPuDJxaZAQlO2-R0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;accessExpire&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1656646361</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;refreshAfter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1656643361</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>是没有code和msg字段的，正常和错误情况还是不统一。</p><p>现在要统一成如下格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;OK&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">// 实际响应数据</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>下面使用我之前定义的packet服务，创建 <code>packet/response/response.go</code>文件，指定Response包装形式，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> response<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/zeromicro/go-zero/rest/httpx&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Body <span class="hljs-keyword">struct</span> &#123;<br>    Code <span class="hljs-type">int</span>         <span class="hljs-string">`json:&quot;code&quot;`</span><br>    Msg  <span class="hljs-type">string</span>      <span class="hljs-string">`json:&quot;msg&quot;`</span><br>    Data <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-string">`json:&quot;data,omitempty&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Response</span><span class="hljs-params">(w http.ResponseWriter, resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> body Body<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        body.Code = <span class="hljs-number">-1</span><br>        body.Msg = err.Error()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        body.Msg = <span class="hljs-string">&quot;OK&quot;</span><br>        body.Data = resp<br>    &#125;<br>    httpx.OkJson(w, body)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后修改handler模板，我的电脑是这个： <code>~/.goctl/1.3.5/api/handler.tpl</code></p><p>修改之前的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> &#123;&#123;.PkgName&#125;&#125;<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/zeromicro/go-zero/rest/httpx&quot;</span><br>&#123;&#123;.ImportPackages&#125;&#125;<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span></span> &#123;&#123;.HandlerName&#125;&#125;(svcCtx *svc.ServiceContext) http.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>&#123;&#123;<span class="hljs-keyword">if</span> .HasRequest&#125;&#125;<span class="hljs-keyword">var</span> req types.&#123;&#123;.RequestType&#125;&#125;<br><span class="hljs-keyword">if</span> err := httpx.Parse(r, &amp;req); err != <span class="hljs-literal">nil</span> &#123;<br>httpx.Error(w, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>&#123;&#123;end&#125;&#125;l := &#123;&#123;.LogicName&#125;&#125;.New&#123;&#123;.LogicType&#125;&#125;(r.Context(), svcCtx)<br>&#123;&#123;<span class="hljs-keyword">if</span> .HasResp&#125;&#125;resp, &#123;&#123;end&#125;&#125;err := l.&#123;&#123;.Call&#125;&#125;(&#123;&#123;<span class="hljs-keyword">if</span> .HasRequest&#125;&#125;&amp;req&#123;&#123;end&#125;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>httpx.Error(w, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>&#123;&#123;<span class="hljs-keyword">if</span> .HasResp&#125;&#125;httpx.OkJson(w, resp)&#123;&#123;<span class="hljs-keyword">else</span>&#125;&#125;httpx.Ok(w)&#123;&#123;end&#125;&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs tpl">package handler<br><br>import (<br>    &quot;net/http&quot;<br>     &quot;github.com/repo/hello/response&quot;// 这里要写response所在包！！也就是response在项目里的包。。。。。。。。。。。。。<br>     // 这个要看在哪个目录下执行goctl，这里会用到项目hello/response目录里的Response方法<br>    &#123;% raw %&#125;<br>    &#123;&#123;.ImportPackages&#125;&#125;<br>    &#123;% endraw %&#125;<br>)<br><br>&#123;% raw %&#125;<br>func &#123;&#123;.HandlerName&#125;&#125;(ctx *svc.ServiceContext) http.HandlerFunc &#123;<br>    return func(w http.ResponseWriter, r *http.Request) &#123;<br>        &#123;&#123;if .HasRequest&#125;&#125;var req types.&#123;&#123;.RequestType&#125;&#125;<br>        if err := httpx.Parse(r, &amp;req); err != nil &#123;<br>            httpx.Error(w, err)<br>            return<br>        &#125;&#123;&#123;end&#125;&#125;<br><br>        l := logic.New&#123;&#123;.LogicType&#125;&#125;(r.Context(), ctx)<br>        &#123;&#123;if .HasResp&#125;&#125;resp, &#123;&#123;end&#125;&#125;err := l.&#123;&#123;.Call&#125;&#125;(&#123;&#123;if .HasRequest&#125;&#125;req&#123;&#123;end&#125;&#125;)<br>        &#123;&#123;if .HasResp&#125;&#125;response.Response(w, resp, err)&#123;&#123;else&#125;&#125;response.Response(w, nil, err)&#123;&#123;end&#125;&#125;<br>        // 就是这里用到了response.Response方法<br>    &#125;<br>&#125;<br>&#123;% endraw %&#125;<br></code></pre></td></tr></table></figure><p>修改handler</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs diff">func queryHandler(ctx *svc.ServiceContext) http.HandlerFunc &#123;<br>    return func(w http.ResponseWriter, r *http.Request) &#123;<br>        var req types.Request<br>        if err := httpx.Parse(r, &amp;req); err != nil &#123;<br>            httpx.Error(w, err)<br>            return<br>        &#125;<br><br>        l := logic.NewGreetLogic(r.Context(), ctx)<br>        resp, err := l.Greet(req)<br><span class="hljs-deletion">-       if err != nil &#123;</span><br><span class="hljs-deletion">-            httpx.Error(w, err)</span><br><span class="hljs-deletion">-        &#125; else &#123;</span><br><span class="hljs-deletion">-            httpx.OkJson(w, resp)</span><br><span class="hljs-deletion">-        &#125;</span><br><span class="hljs-addition">+        response.Response(w, resp, err)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启服务：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>    &quot;<span class="hljs-selector-tag">code</span>&quot;: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;OK&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>: &#123;<br>        &quot;pagination&quot;: &#123;<br>            &quot;current_page&quot;: <span class="hljs-number">1</span>,<br>            <span class="hljs-string">&quot;page_size&quot;</span>: <span class="hljs-number">100</span>,<br>            <span class="hljs-string">&quot;max_page&quot;</span>: <span class="hljs-number">3</span><br>        &#125;,<br>        &quot;data&quot;: []<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;参数错误&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>修改完毕后，如果修改api文件再次执行goctl，那么就可以直接生成新的已经包装好的代码了。</p><h4 id="日志优化"><a href="#日志优化" class="headerlink" title="日志优化"></a>日志优化</h4><p>默认的日志会在终端打印很多我可能用不到的东西：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@timestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2022-10-21T15:31:47.554+08:00&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;caller&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;stat/usage.go:61&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;content&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;CPU: 0m, MEMORY: Alloc=3.4Mi, TotalAlloc=6.7Mi, Sys=16.1Mi, NumGC=5&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;level&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;stat&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@timestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2022-10-21T15:31:47.620+08:00&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;caller&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;load/sheddingstat.go:61&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;content&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;(api) shedding_stat [1m], cpu: 0, total: 0, pass: 0, drop: 0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;level&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;stat&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@timestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2022-10-21T15:31:56.875+08:00&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;caller&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;stat/metrics.go:210&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;content&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;(screen-api) - qps: 0.0/s, drops: 0, avg time: 0.0ms, med: 0.0ms, 90th: 0.0ms, 99th: 0.0ms, 99.9th: 0.0ms&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;level&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;stat&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>目前需求是不打印这些用不到的信息，把日志输出到文件而不是终端。</p><p>在main函数中执行 <code>logx.DisableStat()</code>，可以不打印这些stat信息。</p><p>在main函数只执行logx.SetLevel(0)，可以打印出Info Error Slow日志，如果手动打印.Error .Info之类的话</p><p>Ps：go-zero里关于level的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// InfoLevel logs everything</span><br>InfoLevel <span class="hljs-type">uint32</span> = <span class="hljs-literal">iota</span><br><span class="hljs-comment">// ErrorLevel includes errors, slows, stacks</span><br>ErrorLevel<br><span class="hljs-comment">// SevereLevel only log severe messages</span><br>SevereLevel<br>)<br></code></pre></td></tr></table></figure><p><a href="https://go-zero.dev/cn/docs/component/logx">参考</a>并总结了更好的写法：</p><p>在main一开始就对logx初始化，如果在之后初始化的话好像配置会被覆盖。我之前在RegisterHandlers之后给logx初始化，发现logx的配置不生效，指定了写到文件里也没有写到文件而是输出到了终端。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br><br>logx.DisableStat()<br>logConf := logx.LogConf&#123;<br>ServiceName: <span class="hljs-string">&quot;screen&quot;</span>,<br>Mode:        <span class="hljs-string">&quot;file&quot;</span>,<br>Path:        <span class="hljs-string">&quot;screen_logs&quot;</span>,<br>Encoding:    <span class="hljs-string">&quot;json&quot;</span>,<br>Level:       <span class="hljs-string">&quot;info&quot;</span>,<br>KeepDays:    <span class="hljs-number">3</span>,<br>&#125;<br>logx.MustSetup(logConf)<br><span class="hljs-keyword">defer</span> logx.Close()<br></code></pre></td></tr></table></figure><p>这里的配置是将日志写到了文件里，screen_logs目录下，screen_logs目录会在运行程序的同级目录下生成</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>服务监控这块基于prometheus，可以看看</p><p>go-zero链路追踪，可以看看</p><hr><p>参考</p><ul><li><a href="https://go-zero.dev/cn/docs/develop/naming-spec">官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gorm子查询的方法</title>
    <link href="/2022/11/23/gorm%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/11/23/gorm%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>可以参考下面的写法</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stata">subQuery := <span class="hljs-keyword">m</span>.<span class="hljs-keyword">db</span>.<span class="hljs-keyword">Table</span>(<span class="hljs-keyword">m</span>.<span class="hljs-keyword">table</span>).Select(fmt.Sprintf(<span class="hljs-string">&quot;%s AS ct, src_ip, dst_ip, SUM(pack_size) AS p&quot;</span>, <span class="hljs-keyword">format</span>)).<br>Where(<span class="hljs-string">&quot;create_time &lt; FROM_UNIXTIME(?) AND create_time &gt;= FROM_UNIXTIME(?)&quot;</span>, endTime, startTime).<br><span class="hljs-built_in">Group</span>(<span class="hljs-string">&quot;src_ip, dst_ip, ct&quot;</span>)<br>res := fmt.Sprintf(<span class="hljs-string">&quot;untuple(arrayJoin(arraySlice(arraySort((x,y)-&gt;-y, arrayMap((x, y, z) -&gt; (x, y,z), groupArray(u.src_ip),groupArray(u.dst_ip), groupArray(u.p)) , groupArray(u.p)),1,%d)))&quot;</span>, topNumber)<br><span class="hljs-keyword">db</span> := <span class="hljs-keyword">m</span>.<span class="hljs-keyword">db</span>.<span class="hljs-keyword">Table</span>(<span class="hljs-string">&quot;(?) as u&quot;</span>, subQuery).<br>Select(fmt.Sprintf(<span class="hljs-string">&quot;u.ct, %s AS res&quot;</span>, res)).<br><span class="hljs-built_in">Group</span>(<span class="hljs-string">&quot;ct&quot;</span>).<span class="hljs-keyword">Order</span>(<span class="hljs-string">&quot;ct&quot;</span>)<br><span class="hljs-keyword">var</span> r []map[string]interface&#123;&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> := <span class="hljs-keyword">db</span>.Find(&amp;r).<span class="hljs-keyword">Error</span>; <span class="hljs-keyword">err</span> != nil &#123;<br><span class="hljs-keyword">return</span> nil, <span class="hljs-keyword">err</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上传到 github打码</p><blockquote><p>PS: 有的时候查询结果是一些预期之外的为止格式，此时可以将结果Scan到一个map中或者map数组中，然后查看内容后通过mapstructure将结果转换结构体，比如：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">ResultByTime</span> struct &#123;<br><span class="hljs-type">Time</span>  time.<span class="hljs-type">Time</span> `mapstructure:&quot;ct&quot;`<br><span class="hljs-type">SrcIP</span> string    `mapstructure:&quot;res.1&quot;`<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">db := m.db.Table(<span class="hljs-string">&quot;(?) as u&quot;</span>, subQuery).<br>Select(fmt.Sprintf(<span class="hljs-string">&quot;u.ct, %s AS res&quot;</span>, res)).<br>Group(<span class="hljs-string">&quot;ct&quot;</span>).Order(<span class="hljs-string">&quot;ct&quot;</span>)<br><span class="hljs-keyword">var</span> r []<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-keyword">if</span> err := db.Find(&amp;r).Error; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>results := <span class="hljs-built_in">make</span>([]ResultByTime, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(r))<br><span class="hljs-keyword">if</span> err := mapstructure.Decode(r, &amp;results); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> results, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gorm打印SQL语句</title>
    <link href="/2022/11/23/gorm%E6%89%93%E5%8D%B0SQL%E8%AF%AD%E5%8F%A5/"/>
    <url>/2022/11/23/gorm%E6%89%93%E5%8D%B0SQL%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newModel</span><span class="hljs-params">(opts ...Option)</span></span> (*defaultDataModel, <span class="hljs-type">error</span>) &#123;<br>e := &amp;Options&#123;<br>Addr:     <span class="hljs-string">&quot;127.0.0.1:9999&quot;</span>,<br>Database: <span class="hljs-string">&quot;database&quot;</span>,<br>&#125;<br><span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> opts &#123;<br>o(e)<br>&#125;<br><br>connStr := fmt.Sprintf(<br><span class="hljs-string">&quot;tcp://%s?database=%s&amp;username=%s&amp;password=%s&amp;read_timeout=10&amp;write_timeout=20&quot;</span>,<br>e.Addr,<br>e.Database,<br>e.Username,<br>e.Password)<br>newLogger := logger.New(<br>log.New(os.Stdout, <span class="hljs-string">&quot;\r\n&quot;</span>, log.LstdFlags), <span class="hljs-comment">// io writer</span><br>logger.Config&#123;<br><span class="hljs-comment">// SlowThreshold: time.Microsecond, // 慢 SQL 阈值</span><br>LogLevel: logger.Info, <span class="hljs-comment">// Log level</span><br>Colorful: <span class="hljs-literal">false</span>,       <span class="hljs-comment">// 禁用彩色打印</span><br>&#125;,<br>)<br><br>db, err := gorm.Open(clickhouse.Open(connStr), &amp;gorm.Config&#123;<br>Logger: newLogger,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;defaultGopacketDataModel&#123;<br>db:    db,<br>table: <span class="hljs-string">&quot;`tableA`&quot;</span>,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里连接的是clickhouse数据库，可以参考这个写法，主要就是newLogger和下面的db, err :&#x3D; gorm.Open里指定的logger。这样就可以在gorm的日志（默认是终端）看到对数据库执行的SQL语句是什么了。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>油猴脚本的使用</title>
    <link href="/2022/11/22/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/11/22/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>油猴实际上是一个加载器，它把用户脚本安插在最开始获取到的HTML文件中，这样浏览器加载网页的时候，也会加载特定的用户脚本，这样我们就能够通过编写用户脚本来修改网页了</p><p>JS可以访问的只有Cookie和LocalStorge，本地存储可以通过window.LocalStorage访问</p><h2 id="简单的添加按钮操作"><a href="#简单的添加按钮操作" class="headerlink" title="简单的添加按钮操作"></a>简单的添加按钮操作</h2><p>HTML5是现行的HTML标准，DOM即文档对象模型，是一用对象表示HTML标签的方法，通过DOM，我们可以简单的修改文档对象的属性，来轻松修改HTML标签的内容</p><p><a href="https://imgse.com/i/pSAuAoQ"><img src="/../images/pSAuAoQ.png" alt="pSAuAoQ.png"></a></p><p>选择这个小箭头，在左侧点击元素的时候，右边就可以显示元素的html和css</p><p><a href="https://blog.chrxw.com/archives/2021/02/08/1449.html/comment-page-1">https://blog.chrxw.com/archives/2021/02/08/1449.html/comment-page-1</a> 看到了 按回车执行，然后可以看到，网页的标题已经被修改了。可以通过 document.querySelector(“#content &gt; main &gt; div &gt; div &gt; header &gt; h1”).textContent&#x3D;’xxx’ 修改，如下</p><p><a href="https://imgse.com/i/pSAQdO0"><img src="/../images/pSAQdO0.png" alt="pSAQdO0.png"></a></p><p><strong>下面这是一个追加按钮的操作：</strong></p><p>document 也是DOM元素，它代表整个网页，其他DOM元素都是它的子集。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">let btn = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);<br>btn.textContent = <span class="hljs-string">&#x27;按钮&#x27;</span>;<br>btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,() =&gt; &#123;<br>    alert(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br>&#125;); <span class="hljs-comment">// 为btn对象添加了事件监听器，addEventListener的第一个参数是事件监听器的名称，第二个参数是接收到指定事件后调用的函数，</span><br><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;#_0&quot;</span>).appendChild(btn); <span class="hljs-comment">// 把B元素插入到A元素的子元素的末尾，也就是把btn对象插到&quot;#_0&quot;中，</span><br></code></pre></td></tr></table></figure><p>html修改前后的内容参考如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//修改前</span><br>&lt;h1 <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;m-n font-thin text-black l-h&quot;</span>&gt;<span class="hljs-title class_">Chr</span>_小屋&lt;/h1&gt;<br><span class="hljs-comment">//修改后</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;m-n font-thin text-black l-h&quot;</span>&gt;</span>Chr_小屋</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> //这是我们新创建的DOM元素</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="获取DOM元素"><a href="#获取DOM元素" class="headerlink" title="获取DOM元素"></a>获取DOM元素</h2><p>总结下来就是使用getElementById或者querySelector。querySelector可以填ID或者class名字。</p><h3 id="使用ID获取"><a href="#使用ID获取" class="headerlink" title="使用ID获取"></a>使用ID获取</h3><p>一些元素有id属性，可以使用<code>getElementById</code>来获取，比如这个id为_2：<br><a href="https://imgse.com/i/pSVPBnJ"><img src="/../images/pSVPBnJ.png" alt="pSVPBnJ.png"></a></p><p>可以<code>document.getElementById(&#39;_2&#39;).textContent=&#39;aaa&#39;</code>这样修改其值。</p><p>根据_id选择也可以这样写</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//两种写法等效，推荐第一种</span><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;_2&#x27;</span>);<br><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#_2&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="使用css选择器"><a href="#使用css选择器" class="headerlink" title="使用css选择器"></a>使用css选择器</h3><p>比如获取标题</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">document.query<span class="hljs-constructor">Selector(&#x27;.<span class="hljs-params">entry</span>-<span class="hljs-params">title</span>.<span class="hljs-params">m</span>-<span class="hljs-params">n</span>.<span class="hljs-params">font</span>-<span class="hljs-params">thin</span>.<span class="hljs-params">text</span>-<span class="hljs-params">black</span>.<span class="hljs-params">l</span>-<span class="hljs-params">h</span>&#x27;)</span>; <span class="hljs-comment">// 因为标题的class是entry-title m-n font-thin text-black l-h，中间需要用.分开</span><br></code></pre></td></tr></table></figure><h3 id="根据元素类型选择"><a href="#根据元素类型选择" class="headerlink" title="根据元素类型选择"></a>根据元素类型选择</h3><p>因为评论框的类型为<code>textarea</code>，而且整个网页只有一个<code>textarea</code>，因此选择器可以直接写成<code>textarea</code>，代码如下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;textarea&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="根据相对关系选择"><a href="#根据相对关系选择" class="headerlink" title="根据相对关系选择"></a>根据相对关系选择</h3><p>有的时候，想要操作的元素可能没有独一无二的属性，那么就可以根据相对关系进行选择，这里A和B都是选择器：</p><p><code>A&gt;B</code>表示在<code>A</code>的一级子元素中查找<code>B</code></p><p><code>A B</code>表示在<code>A</code>的内部查找<code>B</code>（查找范围不仅包括子元素，还包括孙元素等）</p><p><code>A+B</code>表示与<code>A</code>相邻的<code>B</code>元素（平级关系，非父子关系）</p><p><code>A.B</code>，不表示相对关系，它表示类型是<code>A</code>，<code>class</code>名是<code>B</code>的元素，这个要注意。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//以下语句都是等效的</span><br>document.query<span class="hljs-constructor">Selector(&#x27;<span class="hljs-params">main</span>&gt;<span class="hljs-params">div</span>&gt;<span class="hljs-params">div</span>&gt;<span class="hljs-params">header</span>&gt;<span class="hljs-params">h1</span>&#x27;)</span>;<span class="hljs-comment">//一级子元素</span><br>document.query<span class="hljs-constructor">Selector(&#x27;<span class="hljs-params">main</span> <span class="hljs-params">header</span>&gt;<span class="hljs-params">h1</span>&#x27;)</span>;<span class="hljs-comment">//所有子元素</span><br>document.query<span class="hljs-constructor">Selector(&#x27;<span class="hljs-params">main</span> <span class="hljs-params">h1</span>&#x27;)</span>;<span class="hljs-comment">//这样也可以</span><br>document.query<span class="hljs-constructor">Selector(&#x27;<span class="hljs-params">header</span>&gt;<span class="hljs-params">h1</span>&#x27;)</span>;<span class="hljs-comment">//多个方法定位header对象</span><br>document.query<span class="hljs-constructor">Selector(&#x27;#<span class="hljs-params">small_widgets</span>&gt;<span class="hljs-params">h1</span>&#x27;)</span>;<br>document.query<span class="hljs-constructor">Selector(&#x27;.<span class="hljs-params">bg</span>-<span class="hljs-params">light</span>.<span class="hljs-params">lter</span>.<span class="hljs-params">wrapper</span>-<span class="hljs-params">md</span>&gt;<span class="hljs-params">h1</span>&#x27;)</span>;<br>document.query<span class="hljs-constructor">Selector(&#x27;<span class="hljs-params">header</span>.<span class="hljs-params">bg</span>-<span class="hljs-params">light</span>&gt;<span class="hljs-params">h1</span>&#x27;)</span>;<br></code></pre></td></tr></table></figure><h3 id="根据属性名称匹配"><a href="#根据属性名称匹配" class="headerlink" title="根据属性名称匹配"></a>根据属性名称匹配</h3><p><code>[xxx]</code>选择带有<code>xxx</code>属性的元素</p><p><code>[xxx=sss]</code>选择<code>xxx</code>属性等于<code>sss</code>的元素</p><p><code>[xxx~=sss]</code>选择<code>xxx</code>属性包含<code>sss</code>的元素（<code>sss</code>必须是整个单词）</p><p><code>[xxx|=sss]</code>选择<code>xxx</code>属性以<code>sss</code>开头的元素（<code>sss</code>必须是整个单词）</p><p><code>[xxx^=sss]</code>选择<code>xxx</code>属性以<code>sss</code>开头的元素（<code>sss</code>可以是单词的一部分）</p><p><code>[xxx$=sss]</code>选择<code>xxx</code>属性以<code>sss</code>结尾的元素（<code>sss</code>可以是单词的一部分）</p><p><code>[xxx*=sss]</code>选择<code>xxx</code>属性包含<code>sss</code>的元素（<code>sss</code>可以是单词的一部分）</p><h2 id="修改DOM元素"><a href="#修改DOM元素" class="headerlink" title="修改DOM元素"></a>修改DOM元素</h2><h3 id="修改文本内容"><a href="#修改文本内容" class="headerlink" title="修改文本内容"></a>修改文本内容</h3><p>textContent返回值为当前DOM元素内的显示字符（没有被 &lt; &gt; 包起来的所有字符），不仅包括自身，还包括所有子元素</p><p>innerText和textContent两个方法会直接替换掉元素内部的内容，如果元素内部有其他子元素的话，子元素会消失。</p><h3 id="修改样式style"><a href="#修改样式style" class="headerlink" title="修改样式style"></a>修改样式style</h3><p>下面是一些获取css样式的方法：</p><p><code>DOM.style</code>，获取DOM元素的内联CSS样式</p><p><code>DOM.style.[css名称]</code>，获取DOM元素的特定CSS属性，例如<code>textAlign</code></p><p><code>DOM.style.cssText</code>，获取DOM元素的内联CSS样式，纯文本格式</p><p>下面是设置样式的方法</p><p><code>DOM.style.[css名称] = &#39;xxx&#39;</code>，修改DOM元素的特定CSS属性为<code>xxx</code></p><p><code>DOM.style.cssText = &#39;aaa: xxx;&#39;</code>，直接修改DOM元素的内联CSS文本，可以一次设置多个CSS</p><p><strong>如果想隐藏某些元素的话，可以把它的CSS的<code>display</code>属性设置成<code>none</code>，就会被隐藏起来了</strong></p><p>删除对象DOM.remove()</p><p><code>DOM.addEventListener( [事件名称] , [回调函数])</code>添加事件监听器</p><p><code>DOM.removeEventListener( [事件名称] , [回调函数])</code>移除事件监听器</p><p><strong>模拟鼠标点击：DOM.click()</strong></p><h2 id="第一个脚本"><a href="#第一个脚本" class="headerlink" title="第一个脚本"></a>第一个脚本</h2><p><code>&#39;use strict&#39;;</code>是伪代码，它告诉解释器，开启<code>严格模式</code></p><p><code>document.querySelector(&#39;.item-thumb&#39;)</code>代码标识获取class名为item-thumb的元素</p><p>打开这个设置可以方便调试脚本</p><p><a href="https://imgse.com/i/pSVV3BF"><img src="/../images/pSVV3BF.png" alt="pSVV3BF.png"></a></p><p>脚本里的一部分如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 需要在元信息里提前申明，才可以使用<br><span class="hljs-regexp">//</span> @grant        GM_setValue <span class="hljs-regexp">//</span> 申请获取了油猴的GM_setValue函数，可以在函数里调用到GM_setValue函数，是油猴自带的储存空间的设置函数，GM_setValue( 键名 , 键值)，保存某个值<br><span class="hljs-regexp">//</span> @grant        GM_getValue <span class="hljs-regexp">//</span> 油猴自带的储存空间的获取函数，GM_getValue( 键名 )，如果键名不存在，返回null<br><span class="hljs-regexp">//</span> @grant        GM_xmlhttpRequest<br></code></pre></td></tr></table></figure><p>了<code>GM_xmlhttpRequest</code>，这个东西是一个网络请求器，<code>GM_xmlhttpRequest</code>类似于<code>xmlHttpRequest</code>，两者用法几乎一样，只是<code>GM_xmlhttpRequest</code>不存在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">跨域</a>的问题</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>所有参考</p><p><a href="https://blog.chrxw.com/archives/2021/02/08/1449.html/comment-page-1">https://blog.chrxw.com/archives/2021/02/08/1449.html/comment-page-1</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kibana y轴基于时间画不同的范围</title>
    <link href="/2022/11/05/kibana%20y%E8%BD%B4%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%94%BB%E4%B8%8D%E5%90%8C%E7%9A%84%E8%8C%83%E5%9B%B4/"/>
    <url>/2022/11/05/kibana%20y%E8%BD%B4%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%94%BB%E4%B8%8D%E5%90%8C%E7%9A%84%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<p>最终效果</p><p><img src="https://tva2.sinaimg.cn/mw690/006gLprLgy1h7l0i95sjtj323c0p8qfz.jpg" alt="WX20221028-150039@2x"></p><p>画图步骤</p><p>选择TSVB</p><p><img src="https://tvax4.sinaimg.cn/mw690/006gLprLgy1h7l0j9ssh5j318s0wq7bi.jpg" alt="WX20221028-150212@2x"></p><p>选择Time Series，配置如下：</p><p><img src="https://tva4.sinaimg.cn/mw690/006gLprLgy1h7l0kbba69j323w10en7q.jpg" alt="WX20221028-150313@2x"></p><h2 id="y轴画不同的范围"><a href="#y轴画不同的范围" class="headerlink" title="y轴画不同的范围"></a>y轴画不同的范围</h2><p>选择Vertical Bar的Visualization，然后根据不同范围统计的范围限制在filter中，可以添加任意个filter。</p><p><img src="https://tvax4.sinaimg.cn/mw690/006gLprLgy1h7l2ekp52dj323811iwpd.jpg" alt="WX20221028-160632@2x"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>weboscket使用</title>
    <link href="/2022/11/04/websocket%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/11/04/websocket%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>Golang 官方标准库实现的 websocket 在功能上有些欠缺，所以可以用</strong><a href="https://pkg.go.dev/github.com/gorilla/websocket">https://pkg.go.dev/github.com/gorilla/websocket</a>这个包，这个包提供了完整的针对webosocket协议的实现，遵循了<a href="https://rfc-editor.org/rfc/rfc6455.html">RFC 6455</a>。</p><h2 id="postman发送websocket请求"><a href="#postman发送websocket请求" class="headerlink" title="postman发送websocket请求"></a>postman发送websocket请求</h2><p><strong>我使用的Postman的版本是10.0.32，点击左侧的New，选择Websocket Request</strong></p><p><img src="https://tvax3.sinaimg.cn/mw690/006gLprLgy1h7fap98ya6j31sy0l8tga.jpg" alt="WX20221023-161950@2x"></p><h2 id="包分析"><a href="#包分析" class="headerlink" title="包分析"></a>包分析</h2><h3 id="接收到请求时，响应"><a href="#接收到请求时，响应" class="headerlink" title="接收到请求时，响应"></a>接收到请求时，响应</h3><p><strong>一个可用的demo</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> upgrader = websocket.Upgrader&#123;<br>ReadBufferSize:   <span class="hljs-number">1024</span>,<br>WriteBufferSize:  <span class="hljs-number">1024</span>,<br>HandshakeTimeout: <span class="hljs-number">5</span> * time.Second,<br>&#125;<br>http.HandleFunc(<span class="hljs-string">&quot;/websocket&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>conn, _ := upgrader.Upgrade(w, r, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">for</span> &#123;<br>msgType, msg, err := conn.ReadMessage()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s receive: %s\n&quot;</span>, conn.RemoteAddr(), <span class="hljs-type">string</span>(msg))<br><span class="hljs-keyword">if</span> err = conn.WriteMessage(msgType, msg); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> err = conn.WriteMessage(msgType, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;..........&quot;</span>)); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;)<br>http.ListenAndServe(<span class="hljs-string">&quot;:22345&quot;</span>, <span class="hljs-literal">nil</span>)<br>time.Sleep(<span class="hljs-number">30</span> * time.Minute)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>postman对应的请求效果：</strong></p><p><img src="https://tva1.sinaimg.cn/mw690/006gLprLgy1h7fb12radjj31kw0u4q7e.jpg" alt="WX20221023-163149@2x"></p><p><strong>在http.Handle里，调用</strong> <code>conn, _ := upgrader.Upgrade(w, r, nil)</code>，将http Request升级为一个websocket包的Conn对象。</p><p><strong>调用ReadMessage读出消息，WriteMessage写消息。</strong></p><p><strong>也可以改造成使用io.Reader，主要是使用conn.NextReader()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> upgrader = websocket.Upgrader&#123;<br>ReadBufferSize:   <span class="hljs-number">1024</span>,<br>WriteBufferSize:  <span class="hljs-number">1024</span>,<br>HandshakeTimeout: <span class="hljs-number">5</span> * time.Second,<br>&#125;<br><br>http.HandleFunc(<span class="hljs-string">&quot;/websocket&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>conn, _ := upgrader.Upgrade(w, r, <span class="hljs-literal">nil</span>)<br><br><span class="hljs-keyword">for</span> &#123;<br>messageType, r, err := conn.NextReader()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>w, err := conn.NextWriter(messageType)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;......err....&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> _, err := io.Copy(w, r); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;......err..1..&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> err := w.Close(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;......err..2..&quot;</span>, err)<br>&#125;<br>&#125;<br>&#125;)<br><br>http.ListenAndServe(<span class="hljs-string">&quot;:22345&quot;</span>, <span class="hljs-literal">nil</span>)<br>time.Sleep(<span class="hljs-number">30</span> * time.Minute)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这是运行结果：</strong></p><p><img src="https://tva2.sinaimg.cn/mw690/006gLprLgy1h7fbilt65dj31ke0q4tc7.jpg" alt="WX20221023-164846@2x"></p><h3 id="服务端主动推送消息"><a href="#服务端主动推送消息" class="headerlink" title="服务端主动推送消息"></a>服务端主动推送消息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> module<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;github.com/gorilla/websocket&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br><span class="hljs-comment">// 消息通道</span><br>news = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-comment">// websocket客户端链接池</span><br>client = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*websocket.Conn)<br><span class="hljs-comment">// 互斥锁，防止程序对统一资源同时进行读写</span><br>mux sync.Mutex<br>)<br><br><span class="hljs-comment">// api:/getPushNews接口处理函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetPushNews</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>id := context.Query(<span class="hljs-string">&quot;userId&quot;</span>)<br>log.Println(id + <span class="hljs-string">&quot;websocket链接&quot;</span>)<br><span class="hljs-comment">// 升级为websocket长链接</span><br>WsHandler(context.Writer, context.Request, id)<br>&#125;<br><br><span class="hljs-comment">// api:/deleteClient接口处理函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeleteClient</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>id := context.Param(<span class="hljs-string">&quot;id&quot;</span>)<br><span class="hljs-comment">// 关闭websocket链接</span><br>conn, exist := getClient(id)<br><span class="hljs-keyword">if</span> exist &#123;<br>conn.Close()<br>deleteClient(id)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>context.JSON(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;mesg&quot;</span>: <span class="hljs-string">&quot;未找到该客户端&quot;</span>,<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 关闭其消息通道</span><br>_, exist = getNewsChannel(id)<br><span class="hljs-keyword">if</span> exist &#123;<br>deleteNewsChannel(id)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// websocket Upgrader</span><br><span class="hljs-keyword">var</span> wsupgrader = websocket.Upgrader&#123;<br>ReadBufferSize:   <span class="hljs-number">1024</span>,<br>WriteBufferSize:  <span class="hljs-number">1024</span>,<br>HandshakeTimeout: <span class="hljs-number">5</span> * time.Second,<br><span class="hljs-comment">// 取消ws跨域校验</span><br>CheckOrigin: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r *http.Request)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;,<br>&#125;<br><br><span class="hljs-comment">// WsHandler 处理ws请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WsHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request, id <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">var</span> conn *websocket.Conn<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-keyword">var</span> exist <span class="hljs-type">bool</span><br><span class="hljs-comment">// 创建一个定时器用于服务端心跳</span><br>pingTicker := time.NewTicker(time.Second * <span class="hljs-number">10</span>)<br>conn, err = wsupgrader.Upgrade(w, r, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 把与客户端的链接添加到客户端链接池中</span><br>addClient(id, conn)<br><br><span class="hljs-comment">// 获取该客户端的消息通道</span><br>m, exist := getNewsChannel(id)<br><span class="hljs-keyword">if</span> !exist &#123;<br>m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>addNewsChannel(id, m)<br>&#125;<br><br><span class="hljs-comment">// 设置客户端关闭ws链接回调函数</span><br>conn.SetCloseHandler(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(code <span class="hljs-type">int</span>, text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>deleteClient(id)<br>log.Println(code)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> content, _ := &lt;-m:<br><span class="hljs-comment">// 从消息通道接收消息，然后推送给前端</span><br>err = conn.WriteJSON(content)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>conn.Close()<br>deleteClient(id)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">case</span> &lt;-pingTicker.C:<br><span class="hljs-comment">// 服务端心跳:每20秒ping一次客户端，查看其是否在线</span><br>conn.SetWriteDeadline(time.Now().Add(time.Second * <span class="hljs-number">20</span>))<br>err = conn.WriteMessage(websocket.PingMessage, []<span class="hljs-type">byte</span>&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;send ping err:&quot;</span>, err)<br>conn.Close()<br>deleteClient(id)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 将客户端添加到客户端链接池</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addClient</span><span class="hljs-params">(id <span class="hljs-type">string</span>, conn *websocket.Conn)</span></span> &#123;<br>mux.Lock()<br>client[id] = conn<br>mux.Unlock()<br>&#125;<br><br><span class="hljs-comment">// 获取指定客户端链接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getClient</span><span class="hljs-params">(id <span class="hljs-type">string</span>)</span></span> (conn *websocket.Conn, exist <span class="hljs-type">bool</span>) &#123;<br>mux.Lock()<br>conn, exist = client[id]<br>mux.Unlock()<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 删除客户端链接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteClient</span><span class="hljs-params">(id <span class="hljs-type">string</span>)</span></span> &#123;<br>mux.Lock()<br><span class="hljs-built_in">delete</span>(client, id)<br>log.Println(id + <span class="hljs-string">&quot;websocket退出&quot;</span>)<br>mux.Unlock()<br>&#125;<br><br><span class="hljs-comment">// 添加用户消息通道</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addNewsChannel</span><span class="hljs-params">(id <span class="hljs-type">string</span>, m <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>mux.Lock()<br>news[id] = m<br>mux.Unlock()<br>&#125;<br><br><span class="hljs-comment">// 获取指定用户消息通道</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getNewsChannel</span><span class="hljs-params">(id <span class="hljs-type">string</span>)</span></span> (m <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, exist <span class="hljs-type">bool</span>) &#123;<br>mux.Lock()<br>m, exist = news[id]<br>mux.Unlock()<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 删除指定消息通道</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNewsChannel</span><span class="hljs-params">(id <span class="hljs-type">string</span>)</span></span> &#123;<br>mux.Lock()<br><span class="hljs-keyword">if</span> m, ok := news[id]; ok &#123;<br><span class="hljs-built_in">close</span>(m)<br><span class="hljs-built_in">delete</span>(news, id)<br>&#125;<br>mux.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="控制信息"><a href="#控制信息" class="headerlink" title="控制信息"></a>控制信息</h3><p><strong>本包定义了3中控制信息：ping pong close，调用WriteControl, WriteMessage 或者 NextWriter可以发送控制信息</strong></p><h3 id="请求后每隔一段时间给客户端推送消息"><a href="#请求后每隔一段时间给客户端推送消息" class="headerlink" title="请求后每隔一段时间给客户端推送消息"></a>请求后每隔一段时间给客户端推送消息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> upgrader = websocket.Upgrader&#123;<br>ReadBufferSize:   <span class="hljs-number">1024</span>,<br>WriteBufferSize:  <span class="hljs-number">1024</span>,<br>HandshakeTimeout: <span class="hljs-number">5</span> * time.Second,<br>&#125;<br>http.HandleFunc(<span class="hljs-string">&quot;/websocket&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>conn, _ := upgrader.Upgrade(w, r, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(time.Second * <span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span> err := conn.WriteMessage(<span class="hljs-number">1</span>, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;..........&quot;</span>)); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;)<br>http.ListenAndServe(<span class="hljs-string">&quot;:22345&quot;</span>, <span class="hljs-literal">nil</span>)<br>time.Sleep(<span class="hljs-number">30</span> * time.Minute)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一旦点击了Connect，服务端就会每隔2秒给客户端发……….</strong></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kibana的Lens计算原理</title>
    <link href="/2022/11/01/kibana%E7%9A%84Lens%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86/"/>
    <url>/2022/11/01/kibana%E7%9A%84Lens%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>使用kibana的Lens功能画的图，每个采样点的值是如何计算的呢？</p><p>比如这个采样点的值是如何计算出来的？</p><p><img src="https://tvax2.sinaimg.cn/large/006gLprLgy1h7u1uy1ywwj31ic0rkdob.jpg" alt="WX20221105-103709@2x"></p><p><img src="https://tvax1.sinaimg.cn/large/006gLprLgy1h7t4ly6tg0j325k12o17v.jpg" alt="WX20221104-152741@2x"></p><p>可以看到，这里是每30秒一个采样点。后台配置如下：</p><p><img src="https://tva2.sinaimg.cn/large/006gLprLgy1h7t4p5yvnej31qg0vctnw.jpg" alt="WX20221104-153047@2x"></p><p>经过一番研究与测试，过程在这里就不赘述了因为挺繁琐，最终总结得到的计算方法是：</p><p>14:45:30秒的数据的计算方法是：</p><p>14:45:30到14:45:59（不包括14:50:00，即左闭右开）的所有pack_size求和，然后和处以时间间隔即30，就可以得到对应的图上的值，也就是后台配置的per second的值。</p><p>至于采样开始的值，会使用一个基于时间间隔的时间点，比如这里指定的开始时间是37分37秒，最终得到的图的第一个采样点的时间是38秒。</p><p><img src="https://tva3.sinaimg.cn/large/006gLprLgy1h7t4vbrf8lj31s00v0ao5.jpg" alt="WX20221104-153643@2x"></p><p>最后一个采样点不大于指定的结束时间：</p><p><img src="https://tvax1.sinaimg.cn/large/006gLprLgy1h7t4xy12n9j31s60vcqll.jpg" alt="WX20221104-153913@2x"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于go-zero和websocket的聊天室demo</title>
    <link href="/2022/10/28/%E5%9F%BA%E4%BA%8Ego-zero%E5%92%8Cwebsocket%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4demo/"/>
    <url>/2022/10/28/%E5%9F%BA%E4%BA%8Ego-zero%E5%92%8Cwebsocket%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4demo/</url>
    
    <content type="html"><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p><strong>使用go-zero的goctl工具，新建名为chat的api服务：</strong></p><blockquote><p><strong>ps：goctl生成api使用的handler模板使用默认的即可，如果没有修改过tpl文件，可以不用确认tpl文件是否为初始的默认值</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> chat<br><span class="hljs-built_in">cd</span> chat<br><span class="hljs-built_in">touch</span> chat.api<br></code></pre></td></tr></table></figure><p><strong>修改chat.api，修改为：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">type</span> WsConnectRequest &#123;<br>ID <span class="hljs-type">int</span> `<span class="hljs-type">path</span>:&quot;id&quot;`<br>&#125;<br><br><span class="hljs-keyword">type</span> WsRequestItem &#123;<br>Message string `<span class="hljs-type">json</span>:&quot;message&quot;`<br>ToID    []<span class="hljs-type">int</span>  `<span class="hljs-type">json</span>:&quot;to_id,omitempty&quot;`<br>&#125;<br><br><span class="hljs-keyword">type</span> WsResponseItem &#123;<br>Message string `<span class="hljs-type">json</span>:&quot;message&quot;`<br>FromID  <span class="hljs-type">int</span>    `<span class="hljs-type">json</span>:&quot;from_id&quot;`<br><span class="hljs-type">Time</span>    int64  `<span class="hljs-type">json</span>:&quot;time&quot;`<br>&#125;<br><br>service chat-api &#123;<br>@<span class="hljs-keyword">handler</span> WsHandler<br><span class="hljs-keyword">get</span> /:id<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>根据新的api文件重新生成代码：</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">goctl api <span class="hljs-built_in">go</span> -api chat.api -dir .<br><span class="hljs-built_in">go</span> <span class="hljs-built_in">mod</span> tidy<br></code></pre></td></tr></table></figure><p><strong>此时chat目录内容如下：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt; tree chat                          <br>chat<br>├── chat<span class="hljs-selector-class">.api</span><br>├── chat<span class="hljs-selector-class">.go</span><br>├── etc<br>│   └── chat-api<span class="hljs-selector-class">.yaml</span><br>└── internal<br>    ├── config<br>    │   └── config<span class="hljs-selector-class">.go</span><br>    ├── handler<br>    │   ├── routes<span class="hljs-selector-class">.go</span><br>    │   └── wshandler<span class="hljs-selector-class">.go</span><br>    ├── logic<br>    │   └── wslogic<span class="hljs-selector-class">.go</span><br>    ├── svc<br>    │   └── servicecontext<span class="hljs-selector-class">.go</span><br>    └── types<br>        └── types<span class="hljs-selector-class">.go</span><br><br><span class="hljs-number">7</span> directories, <span class="hljs-number">9</span> files<br></code></pre></td></tr></table></figure><p><strong>在chat&#x2F;internal&#x2F;handler新建websocket.go文件，其内容如下：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> handler<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/gorilla/websocket&quot;</span><br><span class="hljs-string">&quot;github.com/zeromicro/go-zero/core/logx&quot;</span><br><br><span class="hljs-string">&quot;github.com/nrbackback/zero-chatroom/chat/internal/types&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Hub <span class="hljs-keyword">struct</span> &#123;<br>clients <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Client<br><br>broadcast <span class="hljs-keyword">chan</span> Msg<br>&#125;<br><br><span class="hljs-keyword">type</span> Msg <span class="hljs-keyword">struct</span> &#123;<br>Msg    <span class="hljs-type">string</span><br>FromID <span class="hljs-type">int</span><br>ToIDs  []<span class="hljs-type">int</span><br>Time   <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Client <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">int</span><br>conn *websocket.Conn<br>send <span class="hljs-keyword">chan</span> Msg<br>&#125;<br><br><span class="hljs-keyword">var</span> h *Hub<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitHub</span><span class="hljs-params">()</span></span> &#123;<br>h = &amp;Hub&#123;<br>broadcast: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Msg),<br>clients:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Client),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RunHub</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> message := &lt;-h.broadcast:<br><span class="hljs-keyword">for</span> _, client := <span class="hljs-keyword">range</span> h.clients &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> client.send &lt;- message:<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">close</span>(client.send)<br><span class="hljs-built_in">delete</span>(h.clients, client.ID)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">register</span><span class="hljs-params">(c *Client)</span></span> &#123;<br>h.clients[c.ID] = c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unregister</span><span class="hljs-params">(c *Client)</span></span> &#123;<br><span class="hljs-built_in">delete</span>(h.clients, c.ID)<br><span class="hljs-built_in">close</span>(c.send)<br>&#125;<br><br><span class="hljs-keyword">var</span> maxMessageSize = <span class="hljs-type">int64</span>(<span class="hljs-number">512</span>)<br><span class="hljs-keyword">var</span> pongWait = <span class="hljs-number">60</span> * time.Second<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span></span> readPump() &#123;<br>logx.Errorw(<span class="hljs-string">&quot;test close writer error&quot;</span>, logx.Field(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;fdfsdfds&quot;</span>))<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>unregister(c)<br>c.conn.Close()<br>&#125;()<br>c.conn.SetReadLimit(maxMessageSize)<br>c.conn.SetReadDeadline(time.Now().Add(pongWait))<br>c.conn.SetPongHandler(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>c.conn.SetReadDeadline(time.Now().Add(pongWait))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><br><span class="hljs-keyword">for</span> &#123;<br>_, message, err := c.conn.ReadMessage()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) &#123;<br>log.Printf(<span class="hljs-string">&quot;error: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">var</span> req types.WsRequestItem<br><span class="hljs-keyword">if</span> err := json.Unmarshal(message, &amp;req); err != <span class="hljs-literal">nil</span> &#123;<br>logx.Errorw(<span class="hljs-string">&quot;unmarshal message when read error&quot;</span>, logx.Field(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-type">string</span>(message)), logx.Field(<span class="hljs-string">&quot;error&quot;</span>, err))<br><span class="hljs-keyword">continue</span><br>&#125;<br>h.broadcast &lt;- Msg&#123;<br>Msg:    req.Message,<br>FromID: c.ID,<br>ToIDs:  req.ToID,<br>Time:   time.Now().Unix(),<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> pingPeriod = (pongWait * <span class="hljs-number">9</span>) / <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> writeWait = <span class="hljs-number">10</span> * time.Second<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span></span> writePump() &#123;<br>ticker := time.NewTicker(pingPeriod)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ticker.Stop()<br>c.conn.Close()<br>&#125;()<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> message, ok := &lt;-c.send:<br>c.conn.SetWriteDeadline(time.Now().Add(writeWait))<br><span class="hljs-keyword">if</span> !ok &#123;<br>c.conn.WriteMessage(websocket.CloseMessage, []<span class="hljs-type">byte</span>&#123;&#125;)<br><span class="hljs-keyword">return</span><br>&#125;<br>w, err := c.conn.NextWriter(websocket.TextMessage)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>logx.Errorw(<span class="hljs-string">&quot;NextWriterd error&quot;</span>, logx.Field(<span class="hljs-string">&quot;error&quot;</span>, err))<br><span class="hljs-keyword">continue</span><br>&#125;<br>resp := types.WsResponseItem&#123;<br>Message: message.Msg,<br>FromID:  message.FromID,<br>Time:    message.Time,<br>&#125;<br>v, _ := json.Marshal(resp)<br>w.Write(v)<br><span class="hljs-keyword">if</span> err := w.Close(); err != <span class="hljs-literal">nil</span> &#123;<br>logx.Errorw(<span class="hljs-string">&quot;close writer error&quot;</span>, logx.Field(<span class="hljs-string">&quot;error&quot;</span>, err))<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">case</span> &lt;-ticker.C:<br>c.conn.SetWriteDeadline(time.Now().Add(writeWait))<br><span class="hljs-keyword">if</span> err := c.conn.WriteMessage(websocket.PingMessage, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>logx.Errorw(<span class="hljs-string">&quot;write ping message error&quot;</span>, logx.Field(<span class="hljs-string">&quot;error&quot;</span>, err))<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>修改chat&#x2F;internal&#x2F;handler&#x2F;wshandler.go，更改为如下内容：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> handler<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/gorilla/websocket&quot;</span><br><span class="hljs-string">&quot;github.com/zeromicro/go-zero/rest/httpx&quot;</span><br><br><span class="hljs-string">&quot;github.com/nrbackback/zero-chatroom/chat/internal/svc&quot;</span><br><span class="hljs-string">&quot;github.com/nrbackback/zero-chatroom/chat/internal/types&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> upgrader = websocket.Upgrader&#123;<br>ReadBufferSize:  <span class="hljs-number">1024</span>,<br>WriteBufferSize: <span class="hljs-number">1024</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WsHandler</span><span class="hljs-params">(svcCtx *svc.ServiceContext)</span></span> http.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-keyword">var</span> req types.WsConnectRequest<br><span class="hljs-keyword">if</span> err := httpx.Parse(r, &amp;req); err != <span class="hljs-literal">nil</span> &#123;<br>httpx.Error(w, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>conn, err := upgrader.Upgrade(w, r, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> err := conn.WriteMessage(<span class="hljs-number">1</span>, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;connected&quot;</span>)); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>c := &amp;Client&#123;<br>ID:   req.ID,<br>conn: conn,<br>send: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Msg),<br>&#125;<br>register(c)<br><br><span class="hljs-keyword">go</span> c.writePump()<br><span class="hljs-keyword">go</span> c.readPump()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>修改chat&#x2F;chat.go，更改为如下内容：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/zeromicro/go-zero/core/conf&quot;</span><br><span class="hljs-string">&quot;github.com/zeromicro/go-zero/rest&quot;</span><br><br><span class="hljs-string">&quot;github.com/nrbackback/zero-chatroom/chat/internal/config&quot;</span><br><span class="hljs-string">&quot;github.com/nrbackback/zero-chatroom/chat/internal/handler&quot;</span><br><span class="hljs-string">&quot;github.com/nrbackback/zero-chatroom/chat/internal/svc&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> configFile = flag.String(<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-string">&quot;etc/chat-api.yaml&quot;</span>, <span class="hljs-string">&quot;the config file&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br><br><span class="hljs-keyword">var</span> c config.Config<br>conf.MustLoad(*configFile, &amp;c)<br><br>ctx := svc.NewServiceContext(c)<br>server := rest.MustNewServer(c.RestConf)<br><span class="hljs-keyword">defer</span> server.Stop()<br><br>handler.InitHub()<br><span class="hljs-keyword">go</span> handler.RunHub()<br><br>handler.RegisterHandlers(server, ctx)<br><br>fmt.Printf(<span class="hljs-string">&quot;Starting server at %s:%d...\n&quot;</span>, c.Host, c.Port)<br>server.Start()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://tva4.sinaimg.cn/mw690/006gLprLgy1h7m6kq0cg2j31l61267b6.jpg" alt="WX20221029-151628@2x"></p><p><img src="https://tvax3.sinaimg.cn/mw690/006gLprLgy1h7m6l7tqe7j31ky0zagro.jpg" alt="WX20221029-151713@2x"></p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>github项目地址 <a href="https://github.com/nrbackback/zero-chatroom">https://github.com/nrbackback/zero-chatroom</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>架构整洁之道--SOLID原则</title>
    <link href="/2022/10/22/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93--SOLID%E5%8E%9F%E5%88%99/"/>
    <url>/2022/10/22/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93--SOLID%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="SRP：单一职责"><a href="#SRP：单一职责" class="headerlink" title="SRP：单一职责"></a>SRP：单一职责</h2><p>不要将不同行为者的代码混在一起。</p><p>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中，即又定义有且仅有一个原因使类变更。</p><h2 id="OCP：开闭"><a href="#OCP：开闭" class="headerlink" title="OCP：开闭"></a>OCP：开闭</h2><p>软件系统想要更容易被改变，那么其设计就必须<strong>允许新增代码</strong>来修改系统行为，<strong>而非只能靠修改原来的代码。</strong></p><p>一个好的软件架构设计师会努力将旧代码的修改需求量降至最小，甚至为 0。但该如何实现这一点呢？我们可以先将满足不同需求的代码分组（即 SRP），然后再来调整这些分组之间的依赖关系（即 DIP）。</p><p>不检查修改的模块被依赖，经常修改的模块依赖别人。</p><p>可以在两个模块之间定义interface，让这两个模块不用直接依赖，有时候可以实现依赖反转的效果。比如数据库层的操作方法的interface，它不依赖业务层和数据库实现层。</p><h2 id="LSP：里氏替换"><a href="#LSP：里氏替换" class="headerlink" title="LSP：里氏替换"></a>LSP：里氏替换</h2><p>如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件可以相互替换。</p><p>对于一些特殊条件判断，可以把条件写到数据库。直接在代码里写if x&#x3D;’else’是不好的，最好改成可配置的。</p><h2 id="ISP：接口隔离"><a href="#ISP：接口隔离" class="headerlink" title="ISP：接口隔离"></a>ISP：接口隔离</h2><p>避免不必要的依赖，依赖不需要的东西是有害的。</p><p>每个接口服务于一个子模块。简单地说，就是使用多个专门的接口比使用单个接口要好很多。</p><h2 id="DIP：依赖反转"><a href="#DIP：依赖反转" class="headerlink" title="DIP：依赖反转"></a>DIP：依赖反转</h2><p>低层实现应该依赖高层，而不是高层依赖低层。</p><p>接口比实现更稳定。各个模块间应该用接口依赖，import等导入操作应该导入抽象定义而非具体实现，可以通过抽象工厂实现。除非具体实现不轻易修改，就可以直接导入具体类了。</p>]]></content>
    
    
    <categories>
      
      <category>设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go zero使用记录</title>
    <link href="/2022/10/22/go%20zero%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/10/22/go%20zero%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="格式化api文件"><a href="#格式化api文件" class="headerlink" title="格式化api文件"></a>格式化api文件</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">goctl api format --dir=.  <br></code></pre></td></tr></table></figure><h2 id="根据-api文件生成swagger"><a href="#根据-api文件生成swagger" class="headerlink" title="根据.api文件生成swagger"></a>根据.api文件生成swagger</h2><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">GOPROXY=https://goproxy.cn/,direct go install github.com/zeromicro/goctl-swagger@latest<br></code></pre></td></tr></table></figure><p>生成文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">~/mylocalfile/aWork/code/flora-gopacket-api &gt;&gt; goctl api plugin -plugin goctl-swagger=&quot;swagger -filename packet.json&quot; -api service/packet/api/packet.api -dir doc<br></code></pre></td></tr></table></figure><p>生成json文件的swagger文档后，Cmd+Shift+P后选择Preview Swagger，可以预览效果</p><h2 id="创建微服务实战"><a href="#创建微服务实战" class="headerlink" title="创建微服务实战"></a>创建微服务实战</h2><h3 id="protoc的使用"><a href="#protoc的使用" class="headerlink" title="protoc的使用"></a>protoc的使用</h3><p>如果使用any类型和value类型，需要类似如下操作，待补充：</p><p>参考了<a href="https://www.liwenzhou.com/posts/Go/protobuf/">https://www.liwenzhou.com/posts/Go/protobuf/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">goctl rpc protoc xx.proto --go_out=./types --go-grpc_out=./types --zrpc_out=.   --proto_path=/Users/rhettnina/go/src/google/protobuf/src/  --proto_path=.<br></code></pre></td></tr></table></figure><p>value类型的使用处转换方法参考如下： <code>count = int(value.GetNumberValue())</code></p><p>如果想把int类型unmarshal到proto定义生成的字段，需要在proto里把字段定义为value类型而不是any类型，使用any类型会报错，value类型对于number string bool list这些单值都可以成功unmarshal。</p><p>proto定义参考如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/any.proto&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/struct.proto&quot;</span>;<br><br><span class="hljs-keyword">package</span> p;<br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;./p&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Edge</span> &#123;<br>  map&lt;<span class="hljs-type">string</span>, google.protobuf.Any&gt; properties = <span class="hljs-number">1</span>;<br>  google.protobuf.Value group_value = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我发现修改proto或者模板之后重新用goctl生成的话，如果新生成的文件和原来生成的文件不同，也不会覆盖掉原来生成的文件，除非把原来生成的文件删掉。</p><h2 id="rpc服务启动太慢，调用rpc经常超时的解决"><a href="#rpc服务启动太慢，调用rpc经常超时的解决" class="headerlink" title="rpc服务启动太慢，调用rpc经常超时的解决"></a>rpc服务启动太慢，调用rpc经常超时的解决</h2><p>发现每次启动rpc服务的时候，都要好几秒才能启动成功。api服务调用rpc服务的接口，还经常超时，即使设置了5秒甚至10秒超时时间的context。</p><p>api服务启动也慢，不知道是不是因为api服务在启动中需要连接rpc服务，因为rpc太慢导致的。</p><p>参考了 <a href="https://github.com/zeromicro/go-zero/issues/1326">issue</a>，发现调用rpc的默认超时时间是2秒，因为我的 rpc服务有时候正常处理的情况下也得花费超过2秒以上的时间，所以需要修改超时时间，需要在调用方修改超时时间也需要在rpc方修改超时时间。</p><h4 id="调用方修改"><a href="#调用方修改" class="headerlink" title="调用方修改"></a>调用方修改</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs diff">Name: api<br>Host: 0.0.0.0<br>Port: 8888<br>XXRpc:<br>  Etcd:<br>    Hosts:<br>    - 127.0.0.1:2379<br>    Key: xx.rpc<br> + Timeout: 10000 # 新增的配置，指定调用XXRpc超时时间为10秒<br></code></pre></td></tr></table></figure><p>调用方的代码：</p><p>internal&#x2F;config&#x2F;config.go里的</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Config</span> struct &#123;<br>rest.<span class="hljs-type">RestConf</span><br><span class="hljs-type">XXRpc</span> zrpc.<span class="hljs-type">RpcClientConf</span><br><span class="hljs-type">Log</span>       logx.<span class="hljs-type">LogConf</span><br>&#125;<br></code></pre></td></tr></table></figure><p>main.go里的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx := svc.NewServiceContext(c)<br>server := rest.MustNewServer(c.RestConf)<br><span class="hljs-keyword">defer</span> server.Stop()<br></code></pre></td></tr></table></figure><p>关于MustNewServer的源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MustNewServer</span><span class="hljs-params">(c RestConf, opts ...RunOption)</span></span> *Server &#123;<br>server, err := NewServer(c, opts...)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-keyword">return</span> server<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">RestConf <span class="hljs-keyword">struct</span> &#123;<br>service.ServiceConf<br>Host     <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;,default=0.0.0.0&quot;`</span><br>Port     <span class="hljs-type">int</span><br>CertFile <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;,optional&quot;`</span><br>KeyFile  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;,optional&quot;`</span><br>Verbose  <span class="hljs-type">bool</span>   <span class="hljs-string">`json:&quot;,optional&quot;`</span><br>MaxConns <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;,default=10000&quot;`</span><br>MaxBytes <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;,default=1048576&quot;`</span><br><span class="hljs-comment">// milliseconds</span><br>Timeout      <span class="hljs-type">int64</span>         <span class="hljs-string">`json:&quot;,default=3000&quot;`</span><br>CpuThreshold <span class="hljs-type">int64</span>         <span class="hljs-string">`json:&quot;,default=900,range=[0:1000]&quot;`</span><br>Signature    SignatureConf <span class="hljs-string">`json:&quot;,optional&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>修改完毕后，调用rpc的部分正常写即可，不用再指定context.WithTimeout了，参考下面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *HostStatusLogic)</span></span> HostStatus() (resp []types.HostStatus, err <span class="hljs-type">error</span>) &#123;<br>instanceGroupResp, err := l.svcCtx.XXRpc.InstanceGroup(l.ctx, &amp;xx.InstanceGroupRequest&#123;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="rpc方修改"><a href="#rpc方修改" class="headerlink" title="rpc方修改"></a>rpc方修改</h4><p>配置文件修改：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff">Name: xx.rpc<br>ListenOn: 127.0.0.1:8080<br>Etcd:<br>  Hosts:<br>  - 127.0.0.1:2379<br>  Key: xx.rpc<br><span class="hljs-addition">+Timeout: 10000</span><br></code></pre></td></tr></table></figure><p>代码部分不需要调整。</p><p>补充和配置文件相关的代码调用：</p><p>internal&#x2F;config.config.go里的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>zrpc.RpcServerConf<br>Log logx.LogConf<br>&#125;<br></code></pre></td></tr></table></figure><p>main.go里的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">s := zrpc.MustNewServer(c.RpcServerConf, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(grpcServer *grpc.Server)</span></span> &#123;<br>youwei.RegisterXXServer(grpcServer, svr)<br><br><span class="hljs-keyword">if</span> c.Mode == service.DevMode || c.Mode == service.TestMode &#123;<br>reflection.Register(grpcServer)<br>&#125;<br>&#125;)<br><span class="hljs-keyword">defer</span> s.Stop()<br><br></code></pre></td></tr></table></figure><p>关于RpcServerConf的源码定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A RpcServerConf is a rpc server config.</span><br>RpcServerConf <span class="hljs-keyword">struct</span> &#123;<br>service.ServiceConf<br>ListenOn      <span class="hljs-type">string</span><br>Etcd          discov.EtcdConf    <span class="hljs-string">`json:&quot;,optional&quot;`</span><br>Auth          <span class="hljs-type">bool</span>               <span class="hljs-string">`json:&quot;,optional&quot;`</span><br>Redis         redis.RedisKeyConf <span class="hljs-string">`json:&quot;,optional&quot;`</span><br>StrictControl <span class="hljs-type">bool</span>               <span class="hljs-string">`json:&quot;,optional&quot;`</span><br><span class="hljs-comment">// setting 0 means no timeout</span><br>Timeout      <span class="hljs-type">int64</span> <span class="hljs-string">`json:&quot;,default=2000&quot;`</span><br>CpuThreshold <span class="hljs-type">int64</span> <span class="hljs-string">`json:&quot;,default=900,range=[0:1000]&quot;`</span><br><span class="hljs-comment">// grpc health check switch</span><br>Health <span class="hljs-type">bool</span> <span class="hljs-string">`json:&quot;,default=true&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go的mapstructure库</title>
    <link href="/2022/09/29/go%E7%9A%84mapstructure%E5%BA%93/"/>
    <url>/2022/09/29/go%E7%9A%84mapstructure%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>github地址：github.com&#x2F;mitchellh&#x2F;mapstructure</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>该库的作用是用于将map转换为结构体，或者将结构体转换为map，该库还做了很多处理时的错误处理。</p><p>比如当你获取到json或者gob数据的时候，不知道其具体结构，只能先将其转换为map[string]interface{}，然后可以用该库将map[string]interface{}转换为方便处理的struct。</p><h2 id="tag的使用"><a href="#tag的使用" class="headerlink" title="tag的使用"></a>tag的使用</h2><p>不定义tag的时候，使用字段名，注意字段名大小写敏感。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Username <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> u User<br>b := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;Username&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>,<br>&#125;<br><span class="hljs-keyword">if</span> err := mapstructure.Decode(b, &amp;u); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;decode Interface config failed&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(u) <span class="hljs-comment">// &#123;Alice&#125;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义tag的话，会使用定义的tag，默认会读mapstructure。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Username <span class="hljs-type">string</span> <span class="hljs-string">`mapstructure:&quot;byby&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> u User<br>b := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;byby&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>,<br>&#125;<br><span class="hljs-keyword">if</span> err := mapstructure.Decode(b, &amp;u); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;decode Interface config failed&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(u) <span class="hljs-comment">// &#123;Alice&#125;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以自定义读什么tag而不是读默认的mapstructure tag。此时需要使用NewDecoder，指定TagName为自定义的tag，Result部分为目标解码对象。</p><p>Decode里传入待解码的值。</p><p><strong>PS：多个tag之间直接用空格分割。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Username <span class="hljs-type">string</span> <span class="hljs-string">`disco:&quot;byby&quot; mapstructure:&quot;hihi&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> <br><span class="hljs-keyword">var</span> u User<br>b := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;byby&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>,<br>&#125;<br>decoder, err := mapstructure.NewDecoder(&amp;mapstructure.DecoderConfig&#123;TagName: <span class="hljs-string">&quot;disco&quot;</span>, Result: &amp;u&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><span class="hljs-keyword">if</span> decoder.Decode(b); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>  fmt.Println(u) <span class="hljs-comment">// &#123;Alice&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="指定结构体非嵌套"><a href="#指定结构体非嵌套" class="headerlink" title="指定结构体非嵌套"></a>指定结构体非嵌套</h2><p>指定非嵌套结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Friend <span class="hljs-keyword">struct</span> &#123;<br>Person Person <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> u Friend<br>b := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;person&quot;</span>: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;alice&quot;</span>&#125;,<br>&#125;<br><span class="hljs-keyword">if</span> err := mapstructure.Decode(b, &amp;u); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;decode Interface config failed&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(u) <span class="hljs-comment">// &#123;&#123;alice&#125;&#125;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想指定Persion为非嵌套的，则在Person后面加上<code>   mapstructure:&quot;,squash&quot;   </code>，此时输入不需要person的那层了，此时mapstructure看到squash标识，会将输入转化到Person struct里。</p><p>运行结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Friend <span class="hljs-keyword">struct</span> &#123;<br>Person <span class="hljs-string">`mapstructure:&quot;,squash&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> u Friend<br>b := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;alice&quot;</span>,<br>&#125;<br><span class="hljs-keyword">if</span> err := mapstructure.Decode(b, &amp;u); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;decode Interface config failed&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(u)<br>&#125;<br>&#125; <span class="hljs-comment">// &#123;&#123;&quot;alice&quot;&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>如果传入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;person&quot;</span>: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;alice&quot;</span>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>则无法decode成功。</p><h2 id="获取struct没有定义的字段"><a href="#获取struct没有定义的字段" class="headerlink" title="获取struct没有定义的字段"></a>获取struct没有定义的字段</h2><p>如果传入的map有某个字段，而struct没有定义这个字段，则默认情况下会忽略这个字段。</p><p>可以加上remain标识，接收一些struct没有定义的字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Friend <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-type">string</span><br>Other <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-string">`mapstructure:&quot;,remain&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> u Friend<br>b := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;name&quot;</span>:    <span class="hljs-string">&quot;bob&quot;</span>,<br><span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;123 Maple St.&quot;</span>,<br>&#125;<br><span class="hljs-keyword">if</span> err := mapstructure.Decode(b, &amp;u); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;decode Interface config failed&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(u)<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>忽略struct的字段，定义 &#96;mapstructure:”,omitempty”&#96;&#96;</p><h3 id="WeakDecode"><a href="#WeakDecode" class="headerlink" title="WeakDecode"></a>WeakDecode</h3><p>WeakDecode允许能够最大兼容性的保证Decode的成功，比如传过来的是bool，使用的时候要改成int，比如有的数据库没有bool类型，只能用int表示，此时需要考虑使用WeakDecode。</p><p>WeakDecode用法示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-type">string</span><br>Age    <span class="hljs-type">int</span><br>Emails []<span class="hljs-type">string</span><br>OK     <span class="hljs-type">int</span><br>Bad    <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// This input can come from anywhere, but typically comes from</span><br><span class="hljs-comment">// something like decoding JSON, generated by a weakly typed language</span><br><span class="hljs-comment">// such as PHP.</span><br>input := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;name&quot;</span>:   <span class="hljs-number">123</span>,                      <span class="hljs-comment">// number =&gt; string</span><br><span class="hljs-string">&quot;age&quot;</span>:    <span class="hljs-string">&quot;42&quot;</span>,                     <span class="hljs-comment">// string =&gt; number</span><br><span class="hljs-string">&quot;emails&quot;</span>: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;&#125;, <span class="hljs-comment">// empty map =&gt; empty array</span><br><span class="hljs-string">&quot;ok&quot;</span>:     <span class="hljs-literal">true</span>,<br><span class="hljs-string">&quot;bad&quot;</span>:    <span class="hljs-literal">false</span>,<br>&#125;<br><br><span class="hljs-keyword">var</span> result Person<br><span class="hljs-keyword">if</span> err := mapstructure.WeakDecode(input, &amp;result); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;......err......&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;........result......&quot;</span>, result)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="逆向转换"><a href="#逆向转换" class="headerlink" title="逆向转换"></a>逆向转换</h3><p>一般都是将map转换为struct，逆向转换就是将struct转换为map，转换的方法和map转struct类似。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-type">string</span><br>Age    <span class="hljs-type">int</span><br>Emails []<span class="hljs-type">string</span><br>OK     <span class="hljs-type">int</span><br>Bad    <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  p := &amp;Person&#123;<br>    Name: <span class="hljs-string">&quot;dj&quot;</span>,<br>    Age:  <span class="hljs-number">18</span>,<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>  mapstructure.Decode(p, &amp;m)<br><br>  data, _ := json.Marshal(m)<br>  fmt.Println(<span class="hljs-type">string</span>(data))<br>&#125;<br></code></pre></td></tr></table></figure><p>参考 </p><ul><li><a href="https://darjun.github.io/2020/07/29/godailylib/mapstructure/">Go 每日一库之 mapstructure</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux命令太长换行</title>
    <link href="/2022/09/28/linux%E5%91%BD%E4%BB%A4%E5%A4%AA%E9%95%BF%E6%8D%A2%E8%A1%8C/"/>
    <url>/2022/09/28/linux%E5%91%BD%E4%BB%A4%E5%A4%AA%E9%95%BF%E6%8D%A2%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>可以在末尾加上<code>  \</code>，然后写第二行，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name=service-test --net=host \<br>-v $PWD/config/config.yml:/usr/local/app/config.yml \<br>-v $PWD/logs:/usr/local/app/logs \<br>service -c=config.yml<br></code></pre></td></tr></table></figure><p>直接把这个命令粘贴到Terminal后，运行效果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@n-test remote]# docker run -d --name=service-test --net=host \<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">-v <span class="hljs-variable">$PWD</span>/config/config.yml:/usr/local/app/config.yml \</span><br><span class="language-bash">&gt; -v <span class="hljs-variable">$PWD</span>/logs:/usr/local/app/logs \</span><br><span class="language-bash">&gt; service -c=config.yml</span><br>a0067d0fa6d98b7d9391fdb1d4bf877f42ba86e53e38befebc6871d9866d2c37<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>struct转为map，并使得未被赋值的字段不出现在map里</title>
    <link href="/2022/09/25/struct%E8%BD%AC%E4%B8%BAmap%EF%BC%8C%E5%B9%B6%E4%BD%BF%E5%BE%97%E6%9C%AA%E8%A2%AB%E8%B5%8B%E5%80%BC%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%8D%E5%87%BA%E7%8E%B0%E5%9C%A8map%E9%87%8C/"/>
    <url>/2022/09/25/struct%E8%BD%AC%E4%B8%BAmap%EF%BC%8C%E5%B9%B6%E4%BD%BF%E5%BE%97%E6%9C%AA%E8%A2%AB%E8%B5%8B%E5%80%BC%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%8D%E5%87%BA%E7%8E%B0%E5%9C%A8map%E9%87%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天写代码遇到了一个函数实现的问题，该函数的功能是根据某个struct的json tag，构建对应的map[string]interface{}。如果struct中某个字段未赋值或者为默认值，那么得到的map中不要出现该字段。比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>s1:=Student&#123;&quot;Alice&quot;, 12&#125;</code>得到的结果是<code>map[string]interface&#123;&#125;&#123;&quot;name&quot;:&quot;Alice&quot;, &quot;age&quot;:12&#125;</code></p><p><code>s2:=Student&#123;Name: &quot;Bob&quot;&#125;</code>得到的结果是<code>map[string]interface&#123;&#125;&#123;&quot;name&quot;:&quot;Bob&quot;&#125;</code></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StructTagDecoder <span class="hljs-keyword">struct</span> &#123;<br>tag <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *StructTagDecoder)</span></span> Decode(i <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>v := reflect.ValueOf(i)<br><span class="hljs-keyword">if</span> v.Kind() == reflect.Ptr &#123;<br>v = v.Elem()<br>&#125;<br><span class="hljs-keyword">if</span> v.Kind() != reflect.Struct &#123;<br><span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">&quot;toMap only accepts structs, got (%T)&quot;</span>, v))<br>&#125;<br>typ := v.Type()<br>out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumField(); i++ &#123;<br>fi := typ.Field(i)<br><span class="hljs-keyword">if</span> tagv := fi.Tag.Get(d.tag); tagv != <span class="hljs-string">&quot;&quot;</span> &#123;<br>field := v.Field(i).Interface()<br><span class="hljs-keyword">if</span> field != reflect.Zero(reflect.TypeOf(field)).Interface() &#123;<br>out[tagv] = v.Field(i).Interface()<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := Student&#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">12</span>&#125;<br>s2 := Student&#123;Name: <span class="hljs-string">&quot;Bob&quot;</span>&#125;<br>s3 := Student&#123;<span class="hljs-string">&quot;Charles&quot;</span>, <span class="hljs-number">0</span>&#125;<br>decoder := StructTagDecoder&#123;tag: <span class="hljs-string">&quot;json&quot;</span>&#125;<br>fmt.Println(decoder.Decode(s1))<br>fmt.Println(decoder.Decode(s2))<br>fmt.Println(decoder.Decode(s3))<br>&#125;<br><span class="hljs-comment">// 运行结果如下</span><br><span class="hljs-comment">// map[age:12 name:Alice]</span><br><span class="hljs-comment">// map[name:Bob]</span><br><span class="hljs-comment">// map[name:Charles]</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *StructTagDecoder)</span></span> Decode(i <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>v := reflect.ValueOf(i)<br><span class="hljs-keyword">if</span> v.Kind() == reflect.Ptr &#123;<br>v = v.Elem()<br>&#125;<br><span class="hljs-keyword">if</span> v.Kind() != reflect.Struct &#123;<br><span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">&quot;toMap only accepts structs, got (%T)&quot;</span>, v))<br>&#125;<br>typ := v.Type()<br>out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumField(); i++ &#123;<br>fi := typ.Field(i)<br><span class="hljs-keyword">if</span> tagv := fi.Tag.Get(d.tag); tagv != <span class="hljs-string">&quot;&quot;</span> &#123;<br>field := v.Field(i).Interface()<br><span class="hljs-keyword">if</span> field != reflect.Zero(reflect.TypeOf(field)).Interface() &#123;<br>out[tagv] = v.Field(i).Interface()<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></td></tr></table></figure><p><code>reflect.ValueOf(i)</code>返回存储于interface{}中的具体值的新的值，ValueOf()返回的是一个Value struct</p><p>判断<code>if v.Kind() == reflect.Ptr</code>，如果原始值是一个指针类型的值，那么获取它的原始值。</p><p>获取类型<code>    typ := v.Type()</code></p><p>v.NumField()获取结构体字段数量，遍历结构体的各个字段：</p><p>fi :&#x3D; typ.Field(i)获取结构体的第i个字段，<code>fi.Tag.Get(d.tag)</code>来获取json tag，获取成功后获取该字段的值<code>field := v.Field(i).Interface()</code>，这里把这个值转换为了interface，为了兼容。</p><p>下面需要判断这个值是否是默认值：</p><p>reflect.TypeOf(field)获取代表field动态类型的反射类型</p><blockquote><p>TypeOf returns the reflection Type that represents the dynamic type of i.</p></blockquote><p>reflect.Zero(reflect.TypeOf(field))返回反射类型reflect.TypeOf(field)的零值</p><blockquote><p>&#x2F;&#x2F; Zero returns a Value representing the zero value for the specified type.</p><p>&#x2F;&#x2F; The result is different from the zero value of the Value struct,</p><p>&#x2F;&#x2F; which represents no value at all.</p><p>&#x2F;&#x2F; For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.</p><p>&#x2F;&#x2F; The returned value is neither addressable nor settable.</p></blockquote><p>如果field !&#x3D; reflect.Zero(reflect.TypeOf(field)).Interface()，则认为field不是零值，则设置map。</p><p>参考</p><p><a href="https://stackoverflow.com/questions/13901819/quick-way-to-detect-empty-values-via-reflection-in-go">Quick way to detect empty values via reflection in Go</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kibana可视化饼状图增加过滤条件</title>
    <link href="/2022/09/18/kibana%E5%8F%AF%E8%A7%86%E5%8C%96%E9%A5%BC%E7%8A%B6%E5%9B%BE%E5%A2%9E%E5%8A%A0%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6/"/>
    <url>/2022/09/18/kibana%E5%8F%AF%E8%A7%86%E5%8C%96%E9%A5%BC%E7%8A%B6%E5%9B%BE%E5%A2%9E%E5%8A%A0%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>前提：在kibana可视化中，需要选择饼图呈现统计结果。</p><p>要求：饼图只统计http_type:response的数据。</p><p>修改前只有这一个Buckets：</p><p><img src="https://tvax1.sinaimg.cn/large/006gLprLgy1h68iklskc7j325c12knan.jpg" alt="WX20220916-161320@2x"></p><p>需要在这个Bucket前面增加一个Split chart，Split chart内增加过滤条件。</p><p>修改后：</p><p><img src="https://tva3.sinaimg.cn/large/006gLprLgy1h68immmfl6j325m12i7h3.jpg" alt="WX20220916-161533@2x"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更改通过docker运行的kibana的显示语言</title>
    <link href="/2022/09/16/%E6%9B%B4%E6%94%B9%E9%80%9A%E8%BF%87docker%E8%BF%90%E8%A1%8C%E7%9A%84kibana%E7%9A%84%E6%98%BE%E7%A4%BA%E8%AF%AD%E8%A8%80/"/>
    <url>/2022/09/16/%E6%9B%B4%E6%94%B9%E9%80%9A%E8%BF%87docker%E8%BF%90%E8%A1%8C%E7%9A%84kibana%E7%9A%84%E6%98%BE%E7%A4%BA%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>因为kibana是通过 docker compose启动的，docker compose通过<code>I18N_LOCALE: &quot;zh-CN&quot;</code>定义了显示语言为中文：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.5&quot;</span><br>  <br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">elasticsearch:</span><br>     <span class="hljs-attr">container_name:</span> <span class="hljs-string">elasticsearch</span><br>     <span class="hljs-attr">image:</span> <span class="hljs-string">elasticsearch:7.6.0</span>           <br>     <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>                        <span class="hljs-comment">#重启方式</span><br>     <span class="hljs-attr">environment:</span><br>       <span class="hljs-attr">discovery.type:</span> <span class="hljs-string">single-node</span>          <span class="hljs-comment">#环境变量：运行模式 单例</span><br>     <span class="hljs-attr">ports:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9200:9200&quot;</span>                        <span class="hljs-comment">#端口映射</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9300:9300&quot;</span><br>  <span class="hljs-attr">kibana:</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">kibana</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">kibana:7.6.0</span>                    <br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>                         <span class="hljs-comment">#重启方式</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">I18N_LOCALE:</span> <span class="hljs-string">&quot;zh-CN&quot;</span>                  <span class="hljs-comment">#指定中文</span><br>    <span class="hljs-attr">ports:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5601:5601&quot;</span>                      <br></code></pre></td></tr></table></figure><p>所以在浏览器查看运行在5601端口的kibana服务，显示语言为中文：</p><p><img src="https://tvax1.sinaimg.cn/large/006gLprLgy1h68ajiev8ej325k0rmh25.jpg" alt="WX20220916-113526@2x"></p><p>因为中文下有些乱码和显示错误，比如：</p><p><img src="https://tvax1.sinaimg.cn/large/006gLprLgy1h68alim2vmj32380qin4h.jpg" alt="WX20220916-113740@2x"></p><p>所以想要改回显示成英文。</p><p>在网上搜寻了“docker kibana更改语言”，根据搜到的结果，试了两个方法：</p><p><strong>方法1</strong></p><p>停止kibana服务，在docker-compose文件中取消指定<code>I18N_LOCALE: &quot;zh-CN&quot;</code>，然后<code>docker-compose restart kibana</code>，发现不生效</p><p><strong>方法2</strong></p><p>:<code>docker exec -it kibana bash</code></p><p><code>cd cd config/</code></p><p><code>vi kibana.yml </code></p><p>添加<code>i18n.locale: &quot;zh-CN&quot;</code></p><p>然后<code>exit</code>退出容器</p><p>最后<code>docker restart kibana</code>，发现也还是不行。</p><p>两个方法都不行，那可能是更改对于docker没有生效，于是搜索“docker配置变更不生效“。</p><p>发现是需要重启docker，停止容器后在docker compose中修改配置，然后<code>systemctl restart docker</code>，重启后执行docker compose up即可。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker学习小记</title>
    <link href="/2022/09/01/docker%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
    <url>/2022/09/01/docker%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>docker学习小记</p><h2 id="Dockerfile命令解析"><a href="#Dockerfile命令解析" class="headerlink" title="Dockerfile命令解析"></a>Dockerfile命令解析</h2><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;<br>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]<br></code></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。</p><p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p><p>###ADD</p><p>在COPY基础上多加了一些命令</p><p>这个功能其实并不实用，而且不推荐使用。</p><p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。此外如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去</p><p>###CMD</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。</p><h3 id="我的使用🌟"><a href="#我的使用🌟" class="headerlink" title="我的使用🌟"></a>我的使用🌟</h3><p>使得docker run支持go flag参数，-c&#x3D;xxx参数也就是程序中的参数，和go run的参数一致。但是在docker run时，-c的路径是容器内的路径，所以如果容器内没有的话，需要挂载，容器内目录必须是绝对路径，宿主机目录不存在时会生成。通过-v挂载，<code>-v 宿主机路径:容器内路径</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -v /home/ftpuser/flora-gopacket-service/config.yml:/usr/src/app/config.yml packet-go2 -c=/usr/src/app/config.yml<br></code></pre></td></tr></table></figure><p>好像只有Dockerfile里运行命令的参数写ENTRYPOINT，-c才有效，上面的镜像对应的Dockerfile如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.18</span><br><span class="hljs-keyword">ENV</span> GO111MODULE=on \<br>    GOPROXY=https://goproxy.cn,direct \<br>PORT=<span class="hljs-number">80</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;y&quot;</span> | apt-get upgrade</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;y&quot;</span> | apt-get install libpcap-dev</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/src/app</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> go.mod go.sum ./</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go mod download &amp;&amp; go mod verify</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build -v -o /usr/local/bin/ ./...</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/usr/local/bin/flora-gopacket-service&quot;</span>] <span class="hljs-comment"># 注意这一行</span></span><br></code></pre></td></tr></table></figure><p>基于alpine，可以构建出可以使用的gopacket服务，对应的镜像是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"> docker images|grep gopacket                                                                                                                2 ↵  10074  15:50:45<br>gopacket                   alpine-ok   6b9e79fe7834   About a minute ago   31.8MB<br></code></pre></td></tr></table></figure><p>这个镜像是我在基于如下Dockerfile的容器的基础上改的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM alpine:3.4<br>RUN mkdir /lib64 &amp;&amp; ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2<br>WORKDIR /usr/local/bin<br></code></pre></td></tr></table></figure><p>改的操作如下：</p><blockquote><p>参考了下<a href="https://github.com/knownsec/ksubdomain/issues/1"> libpcap.so.0.8相关报错</a></p><p>解答：</p><p>我是这样解决的：<br>先直接yum安装libpcap-devel：<br>yum install libpcap-devel<br>然后locate一下，发现了安装的是1.5.3版本，定位出&#x2F;usr&#x2F;lib64目录下的三个文件：<br>locate libpcap<br>&#x2F;usr&#x2F;lib64&#x2F;libpcap.so<br>&#x2F;usr&#x2F;lib64&#x2F;libpcap.so.1<br>&#x2F;usr&#x2F;lib64&#x2F;libpcap.so.1.5.3<br>然后cd到&#x2F;usr&#x2F;lib64目录下，ls看一下那三个文件，发现libpcap.so和libpcap.so.1都是libpcap.so.1.5.3的软链接文件。<br>既然这样，那就再建一个软链接文件就好了：<br>ln -s libpcap.so.1.5.3 libpcap.so.0.8</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it zz    127 ↵  10068  15:20:16<br>/usr/local/bin # apk --help<br>apk-tools 2.12.7, compiled for x86_64.<br><br>usage: apk [&lt;OPTIONS&gt;...] COMMAND [&lt;ARGUMENTS&gt;...]<br><br>Package installation and removal:<br>  add        Add packages to WORLD and commit changes<br>  del        Remove packages from WORLD and commit changes<br><br>System maintenance:<br>  fix        Fix, reinstall or upgrade packages without modifying WORLD<br>  update     Update repository indexes<br>  upgrade    Install upgrades available from repositories<br>  cache      Manage the local package cache<br><br>Querying package information:<br>  info       Give detailed information about packages or repositories<br>  list       List packages matching a pattern or other criteria<br>  dot        Render dependencies as graphviz graphs<br>  policy     Show repository policy for packages<br>  search     Search for packages by name or description<br><br>Repository maintenance:<br>  index      Create repository index file from packages<br>  fetch      Download packages from global repositories to a local directory<br>  manifest   Show checksums of package contents<br>  verify     Verify package integrity and signature<br><br>Miscellaneous:<br>  audit      Audit system for changes<br>  stats      Show statistics about repositories and installations<br>  version    Compare package versions or perform tests on version strings<br><br>This apk has coffee making abilities.<br>For more information: man 8 apk<br>/usr/local/bin # apk add ^C<br>/usr/local/bin # apk^C<br>/usr/local/bin # locate libpcap<br>/bin/sh: locate: not found<br>/usr/local/bin # apk add libpcap libpcap-dev<br>fetch https://dl-cdn.alpinelinux.org/alpine/v3.14/main/x86_64/APKINDEX.tar.gz<br>fetch https://dl-cdn.alpinelinux.org/alpine/v3.14/community/x86_64/APKINDEX.tar.gz<br>(1/3) Installing libpcap (1.10.0-r0)<br>(2/3) Installing pkgconf (1.7.4-r0)<br>(3/3) Installing libpcap-dev (1.10.0-r0)<br>Executing busybox-1.33.1-r8.trigger<br>OK: 7 MiB in 17 packages<br>/usr/local/bin # locate libpcap<br>/bin/sh: locate: not found<br>/usr/local/bin # cd /usr/lib64/<br>/bin/sh: cd: can&#x27;t cd to /usr/lib64/: No such file or directory<br>/usr/local/bin # ls -S /usr/lib64/libpcap.so /usr/lib64/libpcap.so.0.8<br>/usr/local/bin # apk info -a  libpcap<br>libpcap-1.10.0-r0 description:<br>A system-independent interface for user-level packet capture<br><br>libpcap-1.10.0-r0 webpage:<br>https://www.tcpdump.org/<br><br>libpcap-1.10.0-r0 installed size:<br>256 KiB<br><br>libpcap-1.10.0-r0 depends on:<br>so:libc.musl-x86_64.so.1<br><br>libpcap-1.10.0-r0 provides:<br>so:libpcap.so.1=1.10.0<br><br>libpcap-1.10.0-r0 is required by:<br>libpcap-dev-1.10.0-r0<br><br>libpcap-1.10.0-r0 contains:<br>usr/lib/libpcap.so.1<br>usr/lib/libpcap.so.1.10.0<br><br>libpcap-1.10.0-r0 triggers:<br><br>libpcap-1.10.0-r0 has auto-install rule:<br><br>libpcap-1.10.0-r0 affects auto-installation of:<br><br>libpcap-1.10.0-r0 replaces:<br><br>libpcap-1.10.0-r0 license:<br>BSD-3-Clause<br><br>/usr/local/bin # ls<br>unix-flora-gopacket-service<br>/usr/local/bin #  apk info<br>musl<br>busybox<br>alpine-baselayout<br>alpine-keys<br>libcrypto1.1<br>libssl1.1<br>ca-certificates-bundle<br>libretls<br>ssl_client<br>zlib<br>apk-tools<br>scanelf<br>musl-utils<br>libc-utils<br>libpcap<br>pkgconf<br>libpcap-dev<br>/usr/local/bin # ls<br>unix-flora-gopacket-service<br>/usr/local/bin # ./unix-flora-gopacket-service <br>Error loading shared library libpcap.so.0.8: No such file or directory (needed by ./unix-flora-gopacket-service)<br>Error relocating ./unix-flora-gopacket-service: pcap_list_tstamp_types: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_promisc: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_tstamp_type_name_to_val: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_findalldevs: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_sendpacket: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_close: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_tstamp_precision: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_list_datalinks: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_open_live: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_setdirection: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_geterr: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_fopen_offline_with_tstamp_precision: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_statustostr: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_buffer_size: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_compile: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_get_selectable_fd: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_next_ex: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_timeout: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_immediate_mode: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_freealldevs: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_stats: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_snaplen: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_lookupnet: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_datalink: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_free_datalinks: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_create: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_tstamp_type_val_to_name: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_datalink: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_offline_filter: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_activate: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_setfilter: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_tstamp_type: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_datalink_val_to_name: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_free_tstamp_types: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_open_dead: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_setnonblock: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_freecode: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_can_set_rfmon: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_datalink_name_to_val: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_snapshot: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_datalink_val_to_description: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_get_tstamp_precision: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_lib_version: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_rfmon: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_open_offline_with_tstamp_precision: symbol not found<br>/usr/local/bin # locate<br>/bin/sh: locate: not found<br>/usr/local/bin # apk add locate<br>ERROR: unable to select packages:<br>  locate (no such package):<br>    required by: world[locate]<br>/usr/local/bin # cd /usr<br>/usr # ls<br>bin      include  lib      local    sbin     share<br>/usr # cd lib<br>/usr/lib # ls<br>engines-1.1          libpcap.so           libpkgconf.so.3      libtls.so.2          pkgconfig<br>libcrypto.so.1.1     libpcap.so.1         libpkgconf.so.3.0.0  libtls.so.2.0.3<br>libpcap.a            libpcap.so.1.10.0    libssl.so.1.1        modules-load.d<br>/usr/lib # ls|grep libpcap<br>libpcap.a<br>libpcap.so<br>libpcap.so.1<br>libpcap.so.1.10.0<br>/usr/lib # ls -S /usr/lib64/libpcap.so /usr/lib64/libpcap.so.0.8<br>ls: /usr/lib64/libpcap.so: No such file or directory<br>ls: /usr/lib64/libpcap.so.0.8: No such file or directory<br>/usr/lib # ln  -S /usr/lib64/libpcap.so /usr/lib64/libpcap.so.0.8<br>ln: /usr/lib64/libpcap.so.0.8: No such file or directory<br>/usr/lib # l -S /usr/lib64/libpcap.so /usr/lib64/libpcap.so.0.8<br>/bin/sh: l: not found<br>/usr/lib # ln -S /usr/lib64/libpcap.so /usr/lib64/libpcap.so.0.8<br>ln: /usr/lib64/libpcap.so.0.8: No such file or directory<br>/usr/lib # ls<br>engines-1.1          libpcap.so           libpkgconf.so.3      libtls.so.2          pkgconfig<br>libcrypto.so.1.1     libpcap.so.1         libpkgconf.so.3.0.0  libtls.so.2.0.3<br>libpcap.a            libpcap.so.1.10.0    libssl.so.1.1        modules-load.d<br>/usr/lib # touch libpcap.so.0.8<br>/usr/lib # ln -S /usr/lib64/libpcap.so /usr/lib64/libpcap.so.0.8<br>ln: /usr/lib64/libpcap.so.0.8: No such file or directory<br>/usr/lib # ls<br>engines-1.1          libpcap.so           libpcap.so.1.10.0    libssl.so.1.1        modules-load.d<br>libcrypto.so.1.1     libpcap.so.0.8       libpkgconf.so.3      libtls.so.2          pkgconfig<br>libpcap.a            libpcap.so.1         libpkgconf.so.3.0.0  libtls.so.2.0.3<br>/usr/lib # rm libpcap.so.0.8<br>/usr/lib # ls<br>engines-1.1          libpcap.so           libpkgconf.so.3      libtls.so.2          pkgconfig<br>libcrypto.so.1.1     libpcap.so.1         libpkgconf.so.3.0.0  libtls.so.2.0.3<br>libpcap.a            libpcap.so.1.10.0    libssl.so.1.1        modules-load.d<br>/usr/lib # ls<br>engines-1.1          libpcap.so           libpkgconf.so.3      libtls.so.2          pkgconfig<br>libcrypto.so.1.1     libpcap.so.1         libpkgconf.so.3.0.0  libtls.so.2.0.3<br>libpcap.a            libpcap.so.1.10.0    libssl.so.1.1        modules-load.d<br>/usr/lib # cd ..<br>/usr # ls<br>bin      include  lib      local    sbin     share<br>/usr # cd lib/<br>/usr/lib # ls -S /usr/lib/libpcap.so /usr/lib/libpcap.so.0.8<br>ls: /usr/lib/libpcap.so.0.8: No such file or directory<br>/usr/lib/libpcap.so<br>/usr/lib # ln -S /usr/lib/libpcap.so /usr/lib/libpcap.so.0.8<br>ln: /usr/lib/libpcap.so.0.8: No such file or directory<br>/usr/lib # touch libpcap.so.0.8<br>/usr/lib # ln -S /usr/lib/libpcap.so /usr/lib/libpcap.so.0.8<br>ln: libpcap.so.0.8: File exists<br>/usr/lib # touch libpcap.so.0.8^C<br>/usr/lib # cd -<br>/usr<br>/usr # ls<br>bin      include  lib      local    sbin     share<br>/usr # cd /usr/local/bin<br>/usr/local/bin # ls<br>unix-flora-gopacket-service<br>/usr/local/bin # ./unix-flora-gopacket-service <br>Error loading shared library libpcap.so.0.8: Exec format error (needed by ./unix-flora-gopacket-service)<br>Error relocating ./unix-flora-gopacket-service: pcap_list_tstamp_types: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_promisc: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_tstamp_type_name_to_val: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_findalldevs: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_sendpacket: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_close: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_tstamp_precision: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_list_datalinks: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_open_live: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_setdirection: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_geterr: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_fopen_offline_with_tstamp_precision: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_statustostr: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_buffer_size: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_compile: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_get_selectable_fd: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_next_ex: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_timeout: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_immediate_mode: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_freealldevs: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_stats: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_snaplen: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_lookupnet: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_datalink: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_free_datalinks: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_create: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_tstamp_type_val_to_name: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_datalink: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_offline_filter: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_activate: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_setfilter: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_tstamp_type: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_datalink_val_to_name: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_free_tstamp_types: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_open_dead: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_setnonblock: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_freecode: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_can_set_rfmon: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_datalink_name_to_val: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_snapshot: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_datalink_val_to_description: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_get_tstamp_precision: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_lib_version: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_set_rfmon: symbol not found<br>Error relocating ./unix-flora-gopacket-service: pcap_open_offline_with_tstamp_precision: symbol not found<br>/usr/local/bin # cd /usr/lib/<br>/usr/lib # ls<br>engines-1.1          libpcap.so           libpcap.so.1.10.0    libssl.so.1.1        modules-load.d<br>libcrypto.so.1.1     libpcap.so.0.8       libpkgconf.so.3      libtls.so.2          pkgconfig<br>libpcap.a            libpcap.so.1         libpkgconf.so.3.0.0  libtls.so.2.0.3<br>/usr/lib # ls|grep lib<br>libcrypto.so.1.1<br>libpcap.a<br>libpcap.so<br>libpcap.so.0.8<br>libpcap.so.1<br>libpcap.so.1.10.0<br>libpkgconf.so.3<br>libpkgconf.so.3.0.0<br>libssl.so.1.1<br>libtls.so.2<br>libtls.so.2.0.3<br>/usr/lib # ls -l<br>total 796<br>drwxr-xr-x    2 root     root          4096 Jul 19 21:06 engines-1.1<br>lrwxrwxrwx    1 root     root            26 Jul 19 21:06 libcrypto.so.1.1 -&gt; ../../lib/libcrypto.so.1.1<br>-rw-r--r--    1 root     root        413414 Jan  4  2021 libpcap.a<br>lrwxrwxrwx    1 root     root            12 Aug  5 07:29 libpcap.so -&gt; libpcap.so.1<br>-rw-r--r--    1 root     root             0 Aug  5 07:42 libpcap.so.0.8<br>lrwxrwxrwx    1 root     root            17 Aug  5 07:29 libpcap.so.1 -&gt; libpcap.so.1.10.0<br>-rwxr-xr-x    1 root     root        247824 Jan  4  2021 libpcap.so.1.10.0<br>lrwxrwxrwx    1 root     root            19 Aug  5 07:29 libpkgconf.so.3 -&gt; libpkgconf.so.3.0.0<br>-rwxr-xr-x    1 root     root         64544 Mar 18  2021 libpkgconf.so.3.0.0<br>lrwxrwxrwx    1 root     root            23 Jul 19 21:06 libssl.so.1.1 -&gt; ../../lib/libssl.so.1.1<br>lrwxrwxrwx    1 root     root            15 Jul 19 21:06 libtls.so.2 -&gt; libtls.so.2.0.3<br>-rwxr-xr-x    1 root     root         71416 Mar 24 15:38 libtls.so.2.0.3<br>drwxr-xr-x    2 root     root          4096 Jul 19 21:06 modules-load.d<br>drwxr-xr-x    2 root     root          4096 Aug  5 07:29 pkgconfig<br>/usr/lib # ln -s libpcap.so.1.10.0 libpcap.so.0.8<br>ln: libpcap.so.0.8: File exists<br>/usr/lib # rm libpcap.so.0.8<br>/usr/lib # ln -s libpcap.so.1.10.0 libpcap.so.0.8<br>/usr/lib # cd /usr/local/bin<br>/usr/local/bin # ./unix-flora-gopacket-service <br>panic: load config file error: open config.yml: no such file or directory<br><br>goroutine 1 [running]:<br>main.main()<br>        /usr/src/app/main.go:23 +0xf6c<br>/usr/local/bin # <br></code></pre></td></tr></table></figure><p>经过总结，最终完整可用的Dockerfile是</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> alpine:<span class="hljs-number">3.4</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk update</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /lib64 &amp;&amp; <span class="hljs-built_in">ln</span> -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add libpcap=1.7.4-r0 libpcap-dev=1.7.4-r0</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/lib</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">ln</span> -s libpcap.so.1.7.4 libpcap.so.0.8</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/local/bin</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> flora-gopacket-service .</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/local/app</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;flora-gopacket-service&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>那么这个flora-gopacket-service从哪里来呢？可以把项目复制到虚拟机上，然后执行go build，build出来了flora-gopacket-service，然后docker build -t xxx .即完成。</p><p>或者可以在项目下用下面的Dockerfile构建出镜像，再从容器里把flora-gopacket-service复制出来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM golang:1.18<br><br>ENV GO111MODULE=on \<br>    GOPROXY=https://goproxy.cn,direct \<br>PORT=80<br><br>RUN apt-get update &amp;&amp; echo &quot;y&quot; | apt-get upgrade<br>RUN echo &quot;y&quot; | apt-get install libpcap-dev<br>WORKDIR /usr/src/app<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">RUN apt-get install libpcap-dev</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">pre-copy/cache go.mod <span class="hljs-keyword">for</span> pre-downloading dependencies and only redownloading them <span class="hljs-keyword">in</span> subsequent builds <span class="hljs-keyword">if</span> they change</span><br>COPY go.mod go.sum ./<br>RUN go mod download &amp;&amp; go mod verify<br><br>COPY . .<br>RUN go build -v -o /usr/local/bin/ ./...<br><br>CMD [&quot;flora-gopacket-service&quot;]<br></code></pre></td></tr></table></figure><p>基于这个镜像的可用<code>docker run</code>命令，注意要使用$PWD，使用.&#x2F;xxx或者直接xxx都不行，还有使用了host网络模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --net=host -v $PWD/config/config.yml:/usr/local/app/config.yml -v $PWD/logs:/usr/local/app/logs  -v $PWD/pcap_file:/usr/local/app/pcap_file last0 -c=/usr/local/app/config.yml<br></code></pre></td></tr></table></figure><h2 id="构建轻量级的应用"><a href="#构建轻量级的应用" class="headerlink" title="构建轻量级的应用"></a>构建轻量级的应用</h2><p>可以使用alpine镜像，将二进制复制到镜像中。</p><p>参考</p><p><a href="https://yeasy.gitbook.io/docker_practice/">Docker-从入门到实践</a>    未看完，TODO再看看</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>linux查看操作系统版本的命令</strong>，可以在容器内执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /proc/version<br></code></pre></td></tr></table></figure><p>golang条件编译</p><h2 id="go-build使用"><a href="#go-build使用" class="headerlink" title="go build使用"></a>go build使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">GOOS=linux GOARCH=amd64 go build        <br><span class="hljs-meta prompt_"># </span><span class="language-bash">github.com/google/gopacket/pcap</span><br>../../../../go/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap.go:30:22: undefined: pcapErrorNotActivated<br>../../../../go/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap.go:52:17: undefined: pcapTPtr<br>../../../../go/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap.go:64:10: undefined: pcapPkthdr<br>../../../../go/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap.go:103:6: undefined: pcapBpfProgram<br>../../../../go/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap.go:110:7: undefined: pcapPkthdr<br>../../../../go/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap.go:268:33: undefined: pcapErrorActivated<br>../../../../go/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap.go:269:33: undefined: pcapWarningPromisc<br>../../../../go/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap.go:270:33: undefined: pcapErrorNoSuchDevice<br>../../../../go/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap.go:271:33: undefined: pcapErrorDenied<br>../../../../go/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap.go:272:33: undefined: pcapErrorNotUp<br>../../../../go/pkg/mod/github.com/google/gopacket@v1.1.19/pcap/pcap.go:272:33: too many errors<br></code></pre></td></tr></table></figure><p>在Mac上，gopacket交叉编译报错</p><p>查了资料，说需要开启CGO，然后不能指定GOARCH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"> CGO_ENABLED=1 GOOS=linux go build<br><span class="hljs-meta prompt_"># </span><span class="language-bash">runtime/cgo</span><br>linux_syscall.c:67:13: error: implicit declaration of function &#x27;setresgid&#x27; is invalid in C99 [-Werror,-Wimplicit-function-declaration]<br>linux_syscall.c:67:13: note: did you mean &#x27;setregid&#x27;?<br>/Library/Developer/CommandLineTools/SDKs/MacOSX12.3.sdk/usr/include/unistd.h:593:6: note: &#x27;setregid&#x27; declared here<br>linux_syscall.c:73:13: error: implicit declaration of function &#x27;setresuid&#x27; is invalid in C99 [-Werror,-Wimplicit-function-declaration]<br>linux_syscall.c:73:13: note: did you mean &#x27;setreuid&#x27;?<br>/Library/Developer/CommandLineTools/SDKs/MacOSX12.3.sdk/usr/include/unistd.h:595:6: note: &#x27;setreuid&#x27; declared here<br></code></pre></td></tr></table></figure><h2 id="我的小记🌟"><a href="#我的小记🌟" class="headerlink" title="我的小记🌟"></a>我的小记🌟</h2><p>启动docker<code>sudo systemctl start docker</code></p><p>docker-compose重启</p><p><code>docker-compose -f xxx.yml restart</code></p><p>复制容器内的文件到主机：<code>docker cp filebeat:/usr/share/filebeat ./filebeat/</code></p><p>docker run -net&#x3D;host指定网络模式为host只在linux上生效，<a href="https://stackoverflow.com/questions/52555007/docker-mac-alternative-to-net-host">原文</a></p><blockquote><p>The host networking driver only works on Linux hosts, and is not supported on Docker for Mac, Docker for Windows, or Docker EE for Windows Server.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gohangout项目代码阅读总结</title>
    <link href="/2022/08/17/gohangout%E9%98%85%E8%AF%BB/"/>
    <url>/2022/08/17/gohangout%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://studygolang.com/articles/18059">原文</a></p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p><strong>gohangout类似logstash，从输入（ES，Kafka，Stdin等）读取数据，经过一些过滤和加工，将处理好的数据输出到指定输出中（ES，Stdin等）</strong></p><h2 id="代码可学习"><a href="#代码可学习" class="headerlink" title="代码可学习"></a>代码可学习</h2><h3 id="多个flag的结构化"><a href="#多个flag的结构化" class="headerlink" title="多个flag的结构化"></a>多个flag的结构化</h3><p><strong>如果有多个flag参数，可以把参数的读取定义在init()中，这些参数在main所在文件里定义成一个option</strong></p><p><strong>注意option是个指针</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var options = &amp;<span class="hljs-keyword">struct</span> &#123;<br>config     <span class="hljs-built_in">string</span><br>autoReload <span class="hljs-built_in">bool</span> <span class="hljs-comment">// 配置文件更新自动重启</span><br>pprof      <span class="hljs-built_in">bool</span><br>pprofAddr  <span class="hljs-built_in">string</span><br>cpuprofile <span class="hljs-built_in">string</span><br>memprofile <span class="hljs-built_in">string</span><br><br>prometheus <span class="hljs-built_in">string</span><br><br>exitWhenNil <span class="hljs-built_in">bool</span><br>&#125;&#123;&#125;<br><br>func init<span class="hljs-literal">()</span> &#123;<br>flag.<span class="hljs-constructor">StringVar(&amp;<span class="hljs-params">options</span>.<span class="hljs-params">config</span>, <span class="hljs-string">&quot;config&quot;</span>, <span class="hljs-params">options</span>.<span class="hljs-params">config</span>, <span class="hljs-string">&quot;path to configuration file or directory&quot;</span>)</span><br>flag.<span class="hljs-constructor">BoolVar(&amp;<span class="hljs-params">options</span>.<span class="hljs-params">autoReload</span>, <span class="hljs-string">&quot;reload&quot;</span>, <span class="hljs-params">options</span>.<span class="hljs-params">autoReload</span>, <span class="hljs-string">&quot;if auto reload while config file changed&quot;</span>)</span><br><br>flag.<span class="hljs-constructor">BoolVar(&amp;<span class="hljs-params">options</span>.<span class="hljs-params">pprof</span>, <span class="hljs-string">&quot;pprof&quot;</span>, <span class="hljs-params">false</span>, <span class="hljs-string">&quot;pprof or not&quot;</span>)</span><br>flag.<span class="hljs-constructor">StringVar(&amp;<span class="hljs-params">options</span>.<span class="hljs-params">pprofAddr</span>, <span class="hljs-string">&quot;pprof-address&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8899&quot;</span>, <span class="hljs-string">&quot;default: 127.0.0.1:8899&quot;</span>)</span><br>flag.<span class="hljs-constructor">StringVar(&amp;<span class="hljs-params">options</span>.<span class="hljs-params">cpuprofile</span>, <span class="hljs-string">&quot;cpuprofile&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;write cpu profile to `file`&quot;</span>)</span><br>flag.<span class="hljs-constructor">StringVar(&amp;<span class="hljs-params">options</span>.<span class="hljs-params">memprofile</span>, <span class="hljs-string">&quot;memprofile&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;write mem profile to `file`&quot;</span>)</span><br><br>flag.<span class="hljs-constructor">StringVar(&amp;<span class="hljs-params">options</span>.<span class="hljs-params">prometheus</span>, <span class="hljs-string">&quot;prometheus&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;address to expose prometheus metrics&quot;</span>)</span><br><br>flag.<span class="hljs-constructor">BoolVar(&amp;<span class="hljs-params">options</span>.<span class="hljs-params">exitWhenNil</span>, <span class="hljs-string">&quot;exit-when-nil&quot;</span>, <span class="hljs-params">false</span>, <span class="hljs-string">&quot;triger gohangout to exit when receive a nil event&quot;</span>)</span><br><br>flag.<span class="hljs-constructor">Parse()</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p><strong>日志打印小写开头</strong></p><h3 id="配置文件转换"><a href="#配置文件转换" class="headerlink" title="配置文件转换"></a>配置文件转换</h3><p><strong>定义了一个Parser interface</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Parser <span class="hljs-keyword">interface</span> &#123;<br>parse(filename <span class="hljs-type">string</span>) (<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>虽然只有一个YamlParser实现了：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> YamlParser <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(yp *YamlParser)</span></span> parse(filepath <span class="hljs-type">string</span>) (<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>读取配置文件根据文件的大小读取：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">configFile, err := os.Open(filepath)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>fi, _ := configFile.Stat()<br><br><span class="hljs-keyword">if</span> fi.Size() == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;config file (%s) is empty&quot;</span>, filepath)<br>&#125;<br><br>buffer = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, fi.Size())<br>_, err = configFile.Read(buffer)<br></code></pre></td></tr></table></figure><h3 id="小的代码书写注意项"><a href="#小的代码书写注意项" class="headerlink" title="小的代码书写注意项"></a>小的代码书写注意项</h3><ul><li><strong>多个变量声明</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>buffer []<span class="hljs-type">byte</span><br>err    <span class="hljs-type">error</span><br>)<br></code></pre></td></tr></table></figure><ul><li><p><strong>这个项目叫gohangout，main函数被定义在gohangout.go里</strong></p></li><li><p><strong>返回的被包装的错误也是小写字母开头的，错误包装例子</strong> <code>fmt.Errorf(&quot;config file (%s) is empty&quot;, filepath)</code></p></li><li><p><strong>同一个文件中，被调用的函数定义在调用处前面，靠近调用处</strong></p></li><li><p><strong>不用公开访问的函数小写字母开头即可</strong></p></li><li><p><strong>文件名，用下划线分割，http_input.go，tcp_input.go这样</strong></p></li><li><p><strong>可以加上go build flag，这样在一个文件下可以有同名的函数，比如</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> +build linux darwin<br><br><span class="hljs-keyword">func</span> listenSignal() &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> +build linux darwin<br><br><span class="hljs-keyword">func</span> listenSignal() &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>多个返回值命名</strong> <code>func getUserPasswordAndHost(url string) (scheme, user, password, host string)</code></p></li></ul><h2 id="一些工具"><a href="#一些工具" class="headerlink" title="一些工具"></a>一些工具</h2><p><strong>pprof</strong>是golang 官方提供的性能调优分析工具，可以对程序进行性能分析，并可视化数据，看起来相当的直观。 当你的go 程序遇到性能瓶颈时，可以使用这个工具来进行调试并优化程序</p><p><strong>go plugin</strong>：需要 <code>go build -buildmode=plugin -o=plugin_doctor.so plugin_bad_docter.go</code>这样先编译成so文件，然后使用处执行 <code>plugin.Open(&quot;xxx.so&quot;)</code>，Open完毕才会执行插件的init函数，然后调用 <code>plug.Lookup(&quot;Doctor&quot;)</code>，再将结果转换为自己需要定义的interface等再使用。总而言之，如何使用还得自己定义，和使用相关的方法等还得自己定义，虽然被编译的go文件里可能已经定义了。so文件就像一个黑盒子。</p><p><strong>用到了</strong><a href="https://github.com/childe/healer">https://github.com/childe/healer</a>，这是作者写的一个消费者Group Consumer</p><p><strong>Grok</strong>：解析日志数据时最常见的任务是将原始文本行分解为其他工具可以操作的一组结构化字段。 如果你使用 Elastic Stack，则可以利用 Elasticsearch 的聚合和 Kibana 的可视化，从日志中提取的信息（如 IP 地址，时间戳和特定域的数据）解释业务和操作问题。对于 Logstash，这个解构工作由 <a href="https://link.segmentfault.com/?enc=qL2t+D3iTe4xOINVN8omxg==.3vfUTFyLK/HOPhM16wcpIivEyOePYxpfZ6aPYXHss7dXpRZqHHChG3womHjDEFQI/vBjMXm71DO2Wl8vSTY2k0a3AWlt95iOqD4NkBEYtf8=">logstash-filter-grok</a> 来承担，它是一个过滤器插件，可以帮助你描述日志格式的结构。grok 过滤器用于将非结构化数据解析为结构化数据。简而言之，grok是一种将行与正则表达式匹配，将行的特定部分映射到专用字段中以及根据此映射执行操作的方法。简而言之，grok是一种将行与正则表达式匹配，将行的特定部分映射到专用字段中以及根据此映射执行操作的方法。</p><p><strong>map修改是会互相影响的</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>e := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]<span class="hljs-keyword">interface</span>&#123;&#125;)<br>e[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>f(e)<br>fmt.Println(e)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>m[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br>fmt.Println(m)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果为：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">map</span>[<span class="hljs-number">1</span>:<span class="hljs-number">1</span> <span class="hljs-number">2</span>:<span class="hljs-number">2</span>]<br><span class="hljs-attribute">map</span>[<span class="hljs-number">1</span>:<span class="hljs-number">1</span> <span class="hljs-number">2</span>:<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>go的text&#x2F;template包</strong></p><h2 id="每个包里的定义"><a href="#每个包里的定义" class="headerlink" title="每个包里的定义"></a>每个包里的定义</h2><h3 id="codec包"><a href="#codec包" class="headerlink" title="codec包"></a>codec包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Decoder <span class="hljs-keyword">interface</span> &#123;<br>Decode([]<span class="hljs-type">byte</span>) <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="condition-filter包"><a href="#condition-filter包" class="headerlink" title="condition_filter包"></a>condition_filter包</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> Condition interface &#123;<br><span class="hljs-constructor">Pass(<span class="hljs-params">event</span> <span class="hljs-params">map</span>[<span class="hljs-params">string</span>]<span class="hljs-params">interface</span>&#123;&#125;)</span> <span class="hljs-built_in">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="field-deleter包"><a href="#field-deleter包" class="headerlink" title="field_deleter包"></a>field_deleter包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> FieldDeleter <span class="hljs-keyword">interface</span> &#123;<br>Delete(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="field-setter包"><a href="#field-setter包" class="headerlink" title="field_setter包"></a>field_setter包</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> FieldSetter interface &#123;<br><span class="hljs-constructor">SetField(<span class="hljs-params">event</span> <span class="hljs-params">map</span>[<span class="hljs-params">string</span>]<span class="hljs-params">interface</span>&#123;&#125;, <span class="hljs-params">value</span> <span class="hljs-params">interface</span>&#123;&#125;, <span class="hljs-params">fieldName</span> <span class="hljs-params">string</span>, <span class="hljs-params">overwrite</span> <span class="hljs-params">bool</span>)</span> map<span class="hljs-literal">[<span class="hljs-identifier">string</span>]</span>interface&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="filter包"><a href="#filter包" class="headerlink" title="filter包"></a>filter包</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Converter</span> interface &#123;<br>convert(v interface&#123;&#125;) (interface&#123;&#125;, error)<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-type">DateParser</span> interface &#123;<br><span class="hljs-type">Parse</span>(interface&#123;&#125;) (time.<span class="hljs-type">Time</span>, error)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="input包"><a href="#input包" class="headerlink" title="input包"></a>input包</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Converter</span> interface &#123;<br>convert(v interface&#123;&#125;) (interface&#123;&#125;, error)<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-type">DateParser</span> interface &#123;<br><span class="hljs-type">Parse</span>(interface&#123;&#125;) (time.<span class="hljs-type">Time</span>, error)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="output包"><a href="#output包" class="headerlink" title="output包"></a>output包</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type Event interface &#123;<br><span class="hljs-function"><span class="hljs-title">Encode</span><span class="hljs-params">()</span></span> <span class="hljs-selector-attr">[]</span>byte<br>&#125;<br><br>type BulkRequest interface &#123;<br><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(Event)</span></span><br><span class="hljs-function"><span class="hljs-title">bufSizeByte</span><span class="hljs-params">()</span></span> int<br><span class="hljs-function"><span class="hljs-title">eventCount</span><span class="hljs-params">()</span></span> int<br><span class="hljs-function"><span class="hljs-title">readBuf</span><span class="hljs-params">()</span></span> <span class="hljs-selector-attr">[]</span>byte<br>&#125;<br>type NewBulkRequestFunc <span class="hljs-built_in">func</span>() BulkRequest<br><br>type BulkProcessor interface &#123;<br><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(Event)</span></span><br><span class="hljs-function"><span class="hljs-title">bulk</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">awaitclose</span><span class="hljs-params">(time.Duration)</span></span><br>&#125;<br><br>type HostSelector interface &#123;<br><span class="hljs-function"><span class="hljs-title">Next</span><span class="hljs-params">()</span></span> interface&#123;&#125;<br><span class="hljs-function"><span class="hljs-title">ReduceWeight</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">AddWeight</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">Size</span><span class="hljs-params">()</span></span> int<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="simplejson包"><a href="#simplejson包" class="headerlink" title="simplejson包"></a>simplejson包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SimpleJsonDecoder <span class="hljs-keyword">struct</span> &#123;<br>bytes.Buffer<br>scratch [<span class="hljs-number">64</span>]<span class="hljs-type">byte</span><br>&#125;<br><br><span class="hljs-keyword">type</span> JSONMarshaler <span class="hljs-keyword">interface</span> &#123;<br>MarshalJSON() ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *SimpleJsonDecoder)</span></span> <span class="hljs-type">string</span>(s <span class="hljs-type">string</span>) <span class="hljs-type">int</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="topology包（拓扑）"><a href="#topology包（拓扑）" class="headerlink" title="topology包（拓扑）"></a><strong>topology包（拓扑）</strong></h3><p><strong>这个包里定义了：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Filter <span class="hljs-keyword">interface</span> &#123;<br>Filter(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;) (<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">bool</span>)<br>&#125;<br><span class="hljs-keyword">type</span> Input <span class="hljs-keyword">interface</span> &#123;<br>ReadOneEvent() <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>Shutdown()<br>&#125;<br><span class="hljs-keyword">type</span> Output <span class="hljs-keyword">interface</span> &#123;<br>Emit(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br>Shutdown()<br>&#125;<br><span class="hljs-keyword">type</span> Processor <span class="hljs-keyword">interface</span> &#123;<br>Process(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="value-render包"><a href="#value-render包" class="headerlink" title="value_render包"></a>value_render包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ValueRender <span class="hljs-keyword">interface</span> &#123;<br>Render(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构总结"><a href="#结构总结" class="headerlink" title="结构总结"></a>结构总结</h2><p><strong>input包的init函数有</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Register</span><span class="hljs-params">(<span class="hljs-string">&quot;Kafka&quot;</span>, newKafkaInput)</span></span><br><span class="hljs-function"><span class="hljs-title">Register</span><span class="hljs-params">(<span class="hljs-string">&quot;Random&quot;</span>, newRandomInput)</span></span><br><span class="hljs-function"><span class="hljs-title">Register</span><span class="hljs-params">(<span class="hljs-string">&quot;Stdin&quot;</span>, newStdinInput)</span></span><br><span class="hljs-function"><span class="hljs-title">Register</span><span class="hljs-params">(<span class="hljs-string">&quot;TCP&quot;</span>, newTCPInput)</span></span><br><span class="hljs-function"><span class="hljs-title">Register</span><span class="hljs-params">(<span class="hljs-string">&quot;UDP&quot;</span>, newUDPInput)</span></span><br></code></pre></td></tr></table></figure><p><strong>topology没有init函数，</strong></p><h3 id="调用大纲"><a href="#调用大纲" class="headerlink" title="调用大纲"></a>调用大纲</h3><p><strong>main调用buildPluginLink构建input，</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">boxes, err := <span class="hljs-built_in">buildPluginLink</span>(config)<br></code></pre></td></tr></table></figure><blockquote><p><strong>buildPluginLink详情：</strong></p><p><strong>根据配置input中的类型获得对应的topology.Input</strong></p><p><strong>根据topology.Input初始化InputBox struct</strong></p><p><strong>根据配置的****add_fields</strong>，调用field_setter.NewFieldSetter(k)，给InputBox struct增加addFields即b.addFields[fieldSetter] &#x3D; value_render.GetValueRender(v.(string))</p><p><strong>给 InputBox 的shutdownWhenNil &#x3D; shutdownWhenNil赋值</strong></p></blockquote><p><strong>将boxes转换：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">inputs</span> <span class="hljs-operator">=</span> gohangoutInputs(boxes)<br></code></pre></td></tr></table></figure><p><strong>调用</strong> <code>input.start()</code>，其具体逻辑就是将input强制转换为 <code>boxes := ([]*input.InputBox)(inputs)</code>，依次调用boexes的Beat，如下：</p><p><strong>main中使用了InputBox这个struct，通过每个InputBox的Beat启动，Beat调用beat，beat的内容包括：</strong></p><p><strong>buildTopology返回了一个Node</strong></p><blockquote><p><strong>buildTopology详情：</strong></p><p><strong>读取配置中的output，</strong><code>box.outputsInAllWorker[workerIdx] = outputs</code>，根据output获取outputProcessor，</p><p><strong>读取 filter信息，</strong><code>filterBoxes := topology.BuildFilterBoxes(box.config, filter.BuildFilter)</code>，filterBoxes 是 []*FilterBox</p><blockquote><p><strong>BuildFilterBoxes详情</strong></p><p><strong>根据filters的各个类型，获得对应的 topology.Filter interface</strong></p><p><strong>NewFilterBox获得FilterBox struct，这个步骤还包括根据配置中的if设置conditionFilter，根据配置的failTag设置failTag，根据remove_fields，****add_fields</strong>设置等</p></blockquote><p><strong>根据filterBoxes和outputProcessor，构建拓扑，返回拓扑</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">  <span class="hljs-selector-tag">var</span> firstNode *topology<span class="hljs-selector-class">.ProcessorNode</span> <span class="hljs-comment">// ProcessorNode是个struct</span><br><span class="hljs-keyword">for</span> _, <span class="hljs-selector-tag">b</span> := range filterBoxes &#123;<br>firstNode = topology<span class="hljs-selector-class">.AppendProcessorsToLink</span>(firstNode, b)<br>&#125;<br>firstNode = topology<span class="hljs-selector-class">.AppendProcessorsToLink</span>(firstNode, outputProcessor)<br></code></pre></td></tr></table></figure></blockquote><p><strong>对于每个box（一个box对应一个input）。首先获取box.input.ReadOneEvent()，然后对于读取出来的结果，增加addFields</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">for</span> fs, v := range box.addFields &#123;<br><span class="hljs-keyword">event</span> = fs.SetField(<span class="hljs-keyword">event</span>, v.Render(<span class="hljs-keyword">event</span>), <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接下来递归调用Process</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">for</span> fs, v := range box.addFields &#123;<br><span class="hljs-keyword">event</span> = fs.SetField(<span class="hljs-keyword">event</span>, v.Render(<span class="hljs-keyword">event</span>), <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span>)<br>&#125;<br>firstNode.Process(<span class="hljs-keyword">event</span>)<br></code></pre></td></tr></table></figure><p><strong>主要是执行</strong> <code>func (b *FilterBox) Process(event map[string]interface&#123;&#125;) map[string]interface&#123;&#125;</code>和 <code>func (p *OutputBox) Process(event map[string]interface&#123;&#125;) map[string]interface&#123;&#125;</code>或者 <code>func (p OutputsProcessor) Process(event map[string]interface&#123;&#125;) map[string]interface&#123;&#125;</code></p><p><strong>单个****OutputsProcessor</strong>的调用过程（<strong>OutputsProcessor</strong>是在有多个output配置的情况下使用的）：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">type</span> <span class="hljs-type">OutputsProcessor </span>[]*OutputBox<br></code></pre></td></tr></table></figure><p><strong>挨个调用OutputBox，每个OutputBox都会调用Pass和Emit，和上面的类似。</strong></p><p><strong>FilterBox</strong>的调用：</p><p><strong>b.conditionFilter.Pass(event) 后调用</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">event</span>, rst = b.Filter.Filter(<span class="hljs-keyword">event</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">event</span> == nil &#123;<br><span class="hljs-keyword">return</span> nil<br>&#125;<br><span class="hljs-keyword">event</span> = b.PostProcess(<span class="hljs-keyword">event</span>, rst)<br></code></pre></td></tr></table></figure><p><strong>PostProcess会根据FilterBox的conditionFilter，failTag，removeFields等字段，增加或者删除一些字段。也就是过滤完毕后的字段处理。</strong></p><h3 id="函数详情"><a href="#函数详情" class="headerlink" title="函数详情"></a>函数详情</h3><p><strong>topology包的</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type Input interface &#123;<br><span class="hljs-function"><span class="hljs-title">ReadOneEvent</span><span class="hljs-params">()</span></span> map<span class="hljs-selector-attr">[string]</span>interface&#123;&#125;<br><span class="hljs-function"><span class="hljs-title">Shutdown</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现这些接口的地方在input包内。</strong></p><p><strong>一些实现Input的struct在返回前会调用Decode，比如</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func (<span class="hljs-selector-tag">p</span> *RandomInput) <span class="hljs-built_in">ReadOneEvent</span>() map<span class="hljs-selector-attr">[string]</span>interface&#123;&#125; &#123;<br>return <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.decoder</span><span class="hljs-selector-class">.Decode</span>(<span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(strconv<span class="hljs-selector-class">.Itoa</span>(n)))<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关于Decode的定义在codec&#x2F;decoder.go里：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Decoder <span class="hljs-keyword">interface</span> &#123;<br>Decode([]<span class="hljs-type">byte</span>) <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>PlainDecoder，JsonEncoder等都实现了这个interface</strong></p><p><strong>Filter的配置读取是根据类型读取到</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Filter <span class="hljs-keyword">interface</span> &#123;<br>Filter(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;) (<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">bool</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>上的，然后再根据单个filter的配置读取为FilterBox。根据failTag，if，remove_fields等读取到FilterBox的conditionFilter，failTag，removeFields等字段中，之前读取的Filter为FilterBox的Filter字段。</strong></p><p><code>firstNode.Process(event)</code>里单个FilterBox的调用过程：</p><p><strong>先通过conditionFilter查看event是否满足条件，满足条件的情况下才继续执行。接下来调用Filter的Filter方法（其实是个interface）。至于Filter方法的实现，会涉及到field_setter和value_render，</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> FieldSetter <span class="hljs-keyword">interface</span> &#123;<br>SetField(event <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, value <span class="hljs-keyword">interface</span>&#123;&#125;, fieldName <span class="hljs-type">string</span>, overwrite <span class="hljs-type">bool</span>) <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">type</span> ValueRender <span class="hljs-keyword">interface</span> &#123;<br>Render(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中一个Filter的调用处为：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(plugin *AddFilter)</span></span> Filter(event <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;) (<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">for</span> fs, v := <span class="hljs-keyword">range</span> plugin.fields &#123;<br>event = fs.SetField(event, v.Render(event), <span class="hljs-string">&quot;&quot;</span>, plugin.overwrite)<br>&#125;<br><span class="hljs-keyword">return</span> event, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>会修改传入的event，再把修改完毕的event返回。</strong></p><p><strong>将处理完毕的event调用</strong> <code>event = b.PostProcess(event, rst)</code>。rst是Filter返回的布尔值。</p><h3 id="配置更新"><a href="#配置更新" class="headerlink" title="配置更新"></a>配置更新</h3><p><strong>main中开启了线程，该线程序一旦从configChannel接受到了变更，将执行：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">    inputs.stop()<br>boxes, err := buildPluginLink(cfg)<br><span class="hljs-keyword">if</span> err == nil &#123;<br>inputs = gohangoutInputs(boxes)<br>go inputs.start()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>glog.Errorf(<span class="hljs-string">&quot;build plugin link error: %v&quot;</span>, err)<br><span class="hljs-keyword">exit</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过三方viper，监视配置，监听到了配置的变更后，将变更后的配置发送到configChannel这个channel中。这个没有开启单独线程。</strong></p><h3 id="程序停止"><a href="#程序停止" class="headerlink" title="程序停止"></a>程序停止</h3><p><strong>listenSignal中接收到停止信号，调用每个InputBox的Shutdown，Shutdown做了如下操作：</strong></p><p><strong>执行box.input.Shutdown()，然后挨个调用Output的o.Output.Shutdown()</strong></p><h3 id="零碎点整理"><a href="#零碎点整理" class="headerlink" title="零碎点整理"></a>零碎点整理</h3><p><strong>condition_filter的Condition interface被output&#x2F;elasticsearch_output.go使用，condition_filter&#x2F;parse.go使用。</strong></p><p><strong>output包里的struct里用到了codec.Encoder，intput包里的struct里用到了codec.Decoder，codec.Encoder和codec.Decoder似乎也只在这两个地方用。</strong></p><h3 id="一些实现了interface的struct和原生struct"><a href="#一些实现了interface的struct和原生struct" class="headerlink" title="一些实现了interface的struct和原生struct"></a>一些实现了interface的struct和原生struct</h3><p><strong>实现了 topology.Input interface：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> KafkaInput <span class="hljs-keyword">struct</span> &#123;<br>config         <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]<span class="hljs-keyword">interface</span>&#123;&#125;<br>decorateEvents <span class="hljs-type">bool</span><br><br>messages <span class="hljs-keyword">chan</span> *healer.FullMessage<br><br>decoder codec.Decoder<br><br>groupConsumers []*healer.GroupConsumer<br>consumers      []*healer.Consumer<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> InputBox <span class="hljs-keyword">struct</span> &#123;<br>config             <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// whole config</span><br>input              topology.Input<br>outputsInAllWorker [][]*topology.OutputBox<br>stop               <span class="hljs-type">bool</span><br>once               sync.Once<br>shutdownChan       <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br><br>promCounter prometheus.Counter<br><br>shutdownWhenNil    <span class="hljs-type">bool</span><br>mainThreadExitChan <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br>addFields <span class="hljs-keyword">map</span>[field_setter.FieldSetter]value_render.ValueRender<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现了topology.Output interface：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ElasticsearchOutput <span class="hljs-keyword">struct</span> &#123;<br>config <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br>action             <span class="hljs-type">string</span><br>index              value_render.ValueRender<br>index_type         value_render.ValueRender<br>id                 value_render.ValueRender<br>routing            value_render.ValueRender<br>source_field       value_render.ValueRender<br>bytes_source_field value_render.ValueRender<br>es_version         <span class="hljs-type">int</span><br>bulkProcessor      BulkProcessor<br><br>scheme   <span class="hljs-type">string</span><br>user     <span class="hljs-type">string</span><br>password <span class="hljs-type">string</span><br>hosts    []<span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现了 topology.Filter：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> GrokFilter <span class="hljs-keyword">struct</span> &#123;<br>config    <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]<span class="hljs-keyword">interface</span>&#123;&#125;<br>overwrite <span class="hljs-type">bool</span><br>groks     []*Grok<br>target    <span class="hljs-type">string</span><br>src       <span class="hljs-type">string</span><br>vr        value_render.ValueRender<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现了field_setter.FieldSetter：</strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">type</span> MultiLevelFieldSetter <span class="hljs-keyword">struct</span> &#123;<br>preFields []<span class="hljs-keyword">string</span><br>lastField <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="mainThreadExitChan"><a href="#mainThreadExitChan" class="headerlink" title="mainThreadExitChan"></a>mainThreadExitChan</h3><p><strong>加载配置失时，会执行</strong> <code>mainThreadExitChan &lt;- struct&#123;&#125;&#123;&#125;</code>退出</p><p><strong>当启动exitWhenNil选项时，beat会在没有event的时候调用</strong> <code>box.mainThreadExitChan &lt;- struct&#123;&#125;&#123;&#125;</code>退出</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go设计模式</title>
    <link href="/2022/08/15/go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/08/15/go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://studygolang.com/articles/18059">原文</a></p><p>Go语言并非是像C++和Java一样的面向对象语言，但是设计模式同样适用</p><h2 id="创建型Creational-Design-Patterns"><a href="#创建型Creational-Design-Patterns" class="headerlink" title="创建型Creational Design Patterns"></a>创建型Creational Design Patterns</h2><h3 id="单例Singleton"><a href="#单例Singleton" class="headerlink" title="单例Singleton"></a>单例Singleton</h3><p>主要用于<strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点</strong>。</p><p><em>如何判断一个对象是否应该被建模成单例？</em></p><p>通常，被建模成单例的对象都有“<strong>中心点</strong>”的含义，比如线程池就是管理所有线程的中心。所以，在判断一个对象是否适合单例模式时，先思考下，这个对象是一个中心点吗？</p><blockquote><p>需要初始化一次</p><p>mulock   *sync.Mutex 初始化的时候可以通过mulock:   new(sync.Mutex) 赋值</p><p>sync.Once只会执行一次</p></blockquote><h3 id="建造者Builder"><a href="#建造者Builder" class="headerlink" title="建造者Builder"></a>建造者Builder</h3><p>如果某个结构体初始化的时候<strong>有很多字段需要赋值</strong>，一个个赋值字段太多，可以先初始化空的结构体，然后写多个方法，挨个给各字段赋值，类似慢慢建造这个结构体的模式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Message <span class="hljs-keyword">struct</span> &#123;<br>Header *Header<br>Body   *Body<br>&#125;<br><span class="hljs-keyword">type</span> Header <span class="hljs-keyword">struct</span> &#123;<br>SrcAddr  <span class="hljs-type">string</span><br>SrcPort  <span class="hljs-type">uint64</span><br>DestAddr <span class="hljs-type">string</span><br>DestPort <span class="hljs-type">uint64</span><br>Items    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>&#125;<br><span class="hljs-keyword">type</span> Body <span class="hljs-keyword">struct</span> &#123;<br>Items []<span class="hljs-type">string</span><br>&#125;<br><span class="hljs-comment">// 多层的嵌套实例化</span><br>message := msg.Message&#123;<br>Header: &amp;msg.Header&#123;<br>SrcAddr:  <span class="hljs-string">&quot;192.168.0.1&quot;</span>,<br>SrcPort:  <span class="hljs-number">1234</span>,<br>DestAddr: <span class="hljs-string">&quot;192.168.0.2&quot;</span>,<br>DestPort: <span class="hljs-number">8080</span>,<br>Items:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>),<br>&#125;,<br>Body:   &amp;msg.Body&#123;<br>Items: <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>),<br>&#125;,<br>&#125;<br><span class="hljs-comment">// 需要知道对象的实现细节</span><br>message.Header.Items[<span class="hljs-string">&quot;contents&quot;</span>] = <span class="hljs-string">&quot;application/json&quot;</span><br>message.Body.Items = <span class="hljs-built_in">append</span>(message.Body.Items, <span class="hljs-string">&quot;record1&quot;</span>)<br></code></pre></td></tr></table></figure><p>改成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Message对象的Builder对象</span><br> <span class="hljs-keyword">type</span> builder <span class="hljs-keyword">struct</span> &#123;<br> once *sync.Once<br> msg *Message<br> &#125;<br> <span class="hljs-comment">// 返回Builder对象</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span></span> *builder &#123;<br> <span class="hljs-keyword">return</span> &amp;builder&#123;<br> once: &amp;sync.Once&#123;&#125;,<br> msg: &amp;Message&#123;Header: &amp;Header&#123;&#125;, Body: &amp;Body&#123;&#125;&#125;,<br> &#125;<br> &#125;<br> <span class="hljs-comment">// 以下是对Message成员对构建方法</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *builder)</span></span> WithSrcAddr(srcAddr <span class="hljs-type">string</span>) *builder &#123;<br> b.msg.Header.SrcAddr = srcAddr<br> <span class="hljs-keyword">return</span> b<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *builder)</span></span> WithSrcPort(srcPort <span class="hljs-type">uint64</span>) *builder &#123;<br> b.msg.Header.SrcPort = srcPort<br> <span class="hljs-keyword">return</span> b<br> &#125;<br>...<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   message := msg.Builder().<br> WithSrcAddr(<span class="hljs-string">&quot;192.168.0.1&quot;</span>).<br> WithSrcPort(<span class="hljs-number">1234</span>).<br> WithDestAddr(<span class="hljs-string">&quot;192.168.0.2&quot;</span>).<br> WithDestPort(<span class="hljs-number">8080</span>).<br> WithHeaderItem(<span class="hljs-string">&quot;contents&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>).<br> WithBodyItem(<span class="hljs-string">&quot;record1&quot;</span>).<br> WithBodyItem(<span class="hljs-string">&quot;record2&quot;</span>).<br> Build()<br> <span class="hljs-keyword">if</span> message.Header.SrcAddr != <span class="hljs-string">&quot;192.168.0.1&quot;</span> &#123;<br> t.Errorf(<span class="hljs-string">&quot;expect src address 192.168.0.1, but actual %s.&quot;</span>, message.Header.SrcAddr)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="工厂Factory-Design"><a href="#工厂Factory-Design" class="headerlink" title="工厂Factory Design"></a>工厂Factory Design</h3><p>都是<strong>将对象创建的逻辑封装起来，为使用者提供一个简单易用的对象创建接口</strong>。与建造者模式类似，但是建造者模式适用于更多参数的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 这个是创建处，iGun是一个interface</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getGun</span><span class="hljs-params">(gunType <span class="hljs-type">string</span>)</span></span> (iGun, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> gunType == <span class="hljs-string">&quot;ak47&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> newAk47(), <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> gunType == <span class="hljs-string">&quot;maverick&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> newMaverick(), <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;Wrong gun type passed&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象工厂-Abstract-Factory"><a href="#抽象工厂-Abstract-Factory" class="headerlink" title="抽象工厂 Abstract Factory"></a>抽象工厂 Abstract Factory</h3><p>在工厂方法模式中，我们通过一个工厂对象来创建一个产品族，具体创建哪个产品，则通过<code>swtich-case</code>的方式去判断。这也意味着该产品组上，每新增一类产品对象，都必须修改原来工厂对象的代码；而且随着产品的不断增多，工厂对象的职责也越来越重，违反了<strong>单一职责原则</strong>。</p><p>抽象工厂模式通过给工厂类新增一个抽象层解决了该问题，</p><p>该模式让您创建一系列相关对象。</p><p>应该就是实现了某个interface的两个struct都嵌套了一个共同的struct？？？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> adidasShort <span class="hljs-keyword">struct</span> &#123;<br>    short<br>&#125;<br><span class="hljs-keyword">type</span> nikeShort <span class="hljs-keyword">struct</span> &#123;<br>    short<br>&#125;<br><span class="hljs-keyword">type</span> iShort <span class="hljs-keyword">interface</span> &#123;<br>    setLogo(logo <span class="hljs-type">string</span>)<br>    setSize(size <span class="hljs-type">int</span>)<br>    getLogo() <span class="hljs-type">string</span><br>    getSize() <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-keyword">type</span> short <span class="hljs-keyword">struct</span> &#123;<br>    logo <span class="hljs-type">string</span><br>    size <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *short)</span></span> setLogo(logo <span class="hljs-type">string</span>) &#123;<br>    s.logo = logo<br>&#125;<br><span class="hljs-comment">// short实现了iShort的所有接口，adidasShort和nikeShort不需要再实现任何接口了</span><br></code></pre></td></tr></table></figure><h3 id="原型Prototype"><a href="#原型Prototype" class="headerlink" title="原型Prototype"></a>原型Prototype</h3><p>主要解决对象复制的问题，它的核心就是<code>clone()</code>方法，clone返回interface然后对interface强制转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-comment">// 原型复制抽象接口</span><br> <span class="hljs-keyword">type</span> Prototype <span class="hljs-keyword">interface</span> &#123;<br> clone() Prototype<br> &#125;<br> <span class="hljs-keyword">type</span> Message <span class="hljs-keyword">struct</span> &#123;<br> Header *Header<br> Body   *Body<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Message)</span></span> clone() Prototype &#123;<br> msg := *m<br> <span class="hljs-keyword">return</span> &amp;msg<br> &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  newMessage := message.Clone().(*msg.Message)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构模式（Creational-Pattern）"><a href="#结构模式（Creational-Pattern）" class="headerlink" title="结构模式（Creational Pattern）"></a><strong>结构模式</strong>（Creational Pattern）</h2><h3 id="组合-Composite"><a href="#组合-Composite" class="headerlink" title="组合 Composite"></a>组合 Composite</h3><p>适用于文件-目录这种树状结构，比如搜索操作，目录会包括多个文件，会调用文件的search操作。</p><h3 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 Adapter"></a>适配器模式 Adapter</h3><p>适配器模式所做的就是<strong>将一个接口<code>Adaptee</code>，通过适配器<code>Adapter</code>转换成Client所期望的另一个接口<code>Target</code>来使用</strong>，实现原理也很简单，就是<code>Adapter</code>通过实现<code>Target</code>接口，并在对应的方法中调用<code>Adaptee</code>的接口实现。</p><p>不适配的struct命名为xxxAdapter</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> computer <span class="hljs-keyword">interface</span> &#123;<br>    insertInSquarePort()<br>&#125;<br><br><span class="hljs-keyword">type</span> mac <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *mac)</span></span> insertInSquarePort() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Insert square port into mac machine&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> windowsAdapter <span class="hljs-keyword">struct</span> &#123;<br>windowMachine *windows<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *windowsAdapter)</span></span> insertInSquarePort() &#123;<br>w.windowMachine.insertInCirclePort()<br>&#125;<br><br><span class="hljs-keyword">type</span> windowsAdapter <span class="hljs-keyword">struct</span> &#123;<br>windowMachine *windows<br>&#125;<br><span class="hljs-comment">// 增加了windowsAdapter，可以调用insertInSquarePort用于mac和windows的调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *windowsAdapter)</span></span> insertInSquarePort() &#123;<br>w.windowMachine.insertInCirclePort()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="桥接Bridge"><a href="#桥接Bridge" class="headerlink" title="桥接Bridge"></a>桥接Bridge</h3><p>m*n优化为m+n</p><p>举一个例子，一个产品有形状和颜色两个特征（变化方向），其中形状分为方形和圆形，颜色分为红色和蓝色。如果采用继承的设计方案，那么就需要新增4个产品子类：方形红色、圆形红色、方形蓝色、圆形红色。如果形状总共有m种变化，颜色有n种变化，那么就需要新增m*n个产品子类！现在我们使用桥接模式进行优化，将形状和颜色分别设计为一个抽象接口独立出来，这样需要新增2个形状子类：方形和圆形，以及2个颜色子类：红色和蓝色。同样，如果形状总共有m种变化，颜色有n种变化，总共只需要新增m+n个子类！</p><p>类似积木，可以自由的组合和拼接</p><h3 id="装饰器Decorator"><a href="#装饰器Decorator" class="headerlink" title="装饰器Decorator"></a>装饰器Decorator</h3><p>它允许您提供附加功能或装饰对象而不更改该对象</p><p>装饰者也就是附加的部分嵌套了原来的东西 </p><p>这里的例子是披萨的增加调料的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pizza <span class="hljs-keyword">interface</span> &#123;<br>getPrice() <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> cheeseTopping <span class="hljs-keyword">struct</span> &#123;<br>pizza pizza<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cheeseTopping)</span></span> getPrice() <span class="hljs-type">int</span> &#123;<br>pizzaPrice := c.pizza.getPrice()<br><span class="hljs-keyword">return</span> pizzaPrice + <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="正面Facade"><a href="#正面Facade" class="headerlink" title="正面Facade"></a>正面Facade</h3><p>将复杂逻辑封装在被调用端，调用端可以无脑调，两边都不用定义interface就定义方法即可</p><h3 id="蝇量级Flyweight"><a href="#蝇量级Flyweight" class="headerlink" title="蝇量级Flyweight"></a>蝇量级Flyweight</h3><p>当需要创建大量可能导致内存问题的对象时使用</p><h3 id="代理proxy"><a href="#代理proxy" class="headerlink" title="代理proxy"></a>代理proxy</h3><p>为对主要对象的受控和智能访问提供额外的间接层。</p><p>在这种模式中，创建了一个新的代理类，它实现了与主对象相同的接口。 这使您可以在主对象的实际逻辑之前执行一些行为。 比如nginx服务器会在实际处理前做一些处理（比如统计API调用次数等）。</p><p>下面的例子中，实际的nginx是被使用的，它嵌套了业务处理application，也实现了handleRequest，在handleRequest中做了自定义的前置处理checkRateLimiting然后调用application的handleRequest。适用方直接用最外层的nginx的handleRequest即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> server <span class="hljs-keyword">interface</span> &#123;<br>    handleRequest(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">string</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> application <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *application)</span></span> handleRequest(url, method <span class="hljs-type">string</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">string</span>) &#123;<br>    ....<br>&#125;<br><br><span class="hljs-keyword">type</span> nginx <span class="hljs-keyword">struct</span> &#123;<br>    application       *application<br>    maxAllowedRequest <span class="hljs-type">int</span><br>    rateLimiter       <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newNginxServer</span><span class="hljs-params">()</span></span> *nginx &#123;<br>    <span class="hljs-keyword">return</span> &amp;nginx&#123;<br>        application:       &amp;application&#123;&#125;,<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *nginx)</span></span> handleRequest(url, method <span class="hljs-type">string</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">string</span>) &#123;<br>    allowed := n.checkRateLimiting(url)<br>    <span class="hljs-keyword">if</span> !allowed &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">403</span>, <span class="hljs-string">&quot;Not Allowed&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> n.application.handleRequest(url, method)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *nginx)</span></span> checkRateLimiting(url <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    nginxServer := newNginxServer()<br>    appStatusURL := <span class="hljs-string">&quot;/app/status&quot;</span><br>    httpCode, body := nginxServer.handleRequest(appStatusURL, <span class="hljs-string">&quot;GET&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>##行为设计模式Behavioural Design Patterns</p><h3 id="责任链Chain-of-Responsiblity"><a href="#责任链Chain-of-Responsiblity" class="headerlink" title="责任链Chain of Responsiblity"></a>责任链Chain of Responsiblity</h3><p>责任链设计模式是一种行为设计模式。 它允许您创建一系列请求处理程序。 对于每个传入的请求，它都通过链和每个处理程序传递：</p><p>处理请求或跳过处理。<br>决定是否将请求传递给链中的下一个处理程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 以病人去医院看病为例子</span><br><span class="hljs-keyword">type</span> department <span class="hljs-keyword">interface</span> &#123;<br>    execute(*patient)<br>    setNext(department)<br>&#125;<br><br><span class="hljs-keyword">type</span> reception <span class="hljs-keyword">struct</span> &#123;<br>    next department<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *reception)</span></span> execute(p *patient) &#123;<br>m.next.execute(p)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *reception)</span></span> setNext(next department) &#123;<br>    r.next = next<br>&#125;<br><span class="hljs-keyword">type</span> cashier <span class="hljs-keyword">struct</span> &#123;<br>next department<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cashier)</span></span> execute(p *patient) &#123;<br>fmt.Println(<span class="hljs-string">&quot;Cashier getting money from patient patient&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cashier)</span></span> setNext(next department) &#123;<br>c.next = next<br>&#125;<br><br><span class="hljs-keyword">type</span> patient <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    cashier := &amp;cashier&#123;&#125;<br>    medical := &amp;medical&#123;&#125;<br>    medical.setNext(cashier)<br>    doctor := &amp;doctor&#123;&#125;<br>    doctor.setNext(medical)<br>    patient := &amp;patient&#123;name: <span class="hljs-string">&quot;abc&quot;</span>&#125;<br>    <span class="hljs-comment">//Patient visiting</span><br>    reception.execute(patient)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="命令Command"><a href="#命令Command" class="headerlink" title="命令Command"></a>命令Command</h3><h3 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h3><p>迭代器设计模式是一种行为设计模式。 在这种模式中，集合结构提供了一个迭代器，它允许它按顺序遍历集合结构中的每个元素，而不会暴露其底层实现。</p><h3 id="调解员Mediator"><a href="#调解员Mediator" class="headerlink" title="调解员Mediator"></a>调解员Mediator</h3><p>中介者设计模式是一种行为设计模式。 这种模式建议创建一个中介对象来防止对象之间的直接通信，从而避免它们之间的直接依赖关系。</p><h3 id="备忘录Memento"><a href="#备忘录Memento" class="headerlink" title="备忘录Memento"></a>备忘录Memento</h3><p>Memento 设计模式是一种行为设计模式。 它允许我们保存对象的检查点，从而允许对象恢复到之前的状态。 基本上它有助于对对象进行撤消重做操作。</p><h3 id="空对象Null-Object"><a href="#空对象Null-Object" class="headerlink" title="空对象Null Object"></a>空对象Null Object</h3><p>空对象设计模式是一种行为设计模式。 当客户端代码依赖于某些可以为空的依赖项时，它很有用。 使用这种设计模式可以防止客户端对这些依赖项的结果进行空检查。 话虽如此，还应该注意的是，客户端行为也适用于此类空依赖项。</p><h3 id="订阅者Observer"><a href="#订阅者Observer" class="headerlink" title="订阅者Observer"></a>订阅者Observer</h3><p>适用于一个订阅者，多个发布者。订阅者订阅某个主题（subject）。</p><h3 id="状态State"><a href="#状态State" class="headerlink" title="状态State"></a>状态State</h3><p>作用于有限状态机</p><p>###策略Strategy</p><p>改变对象的行为，比如根据实际情况的变化动态的调整缓存策略，所谓的调整缓存策略还是得需要代码里手动set</p><h3 id="模板方法Template-Method"><a href="#模板方法Template-Method" class="headerlink" title="模板方法Template Method"></a>模板方法Template Method</h3><p>定义多个有顺序要求的接口，调用处按顺序调用接口</p><h3 id="访问者Visitor"><a href="#访问者Visitor" class="headerlink" title="访问者Visitor"></a>访问者Visitor</h3><p>给struct增加一些行为，而不用改变struct</p><p>比如给interface多加一些方法，不用修改实现的struct，通过visitor修改。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python入门总结</title>
    <link href="/2022/07/30/python%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/30/python%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>主要来源于菜鸟教程</p><p>Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。</p><p>Python 是交互式语言，面向对象语言</p><p><strong>修改编码格式，支持打印中文</strong></p><p>Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。解决方法为只要在python文件开头加入 <strong># -*- coding: UTF-8 -*-</strong> 或者 <strong># coding&#x3D;utf-8</strong> 就行了</p><p><strong>注意：</strong>Python3.X 源码文件默认使用utf-8编码，所以可以正常解析中文，无需指定 UTF-8 编码。</p><p><strong>注意：</strong>如果你使用编辑器，同时需要设置 py 文件存储的格式为 UTF-8</p><p>以下划线开头的标识符是有特殊意义的。以单下划线开头 <strong>_foo</strong> 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 <strong>from xxx import *</strong> 而导入。</p><p>以双下划线开头的 <strong>__foo</strong> 代表类的私有成员，以双下划线开头和结尾的 <strong><strong>foo</strong></strong> 代表 Python 里特殊方法专用的标识，如 <strong><strong>init</strong>()</strong> 代表类的构造函数。</p><p>可以使用斜杠（ \）将一行的语句分为多行显示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">total = item_one + \<br>        item_two + \<br>        item_three<br></code></pre></td></tr></table></figure><p>三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">paragraph = <span class="hljs-string">&quot;&quot;&quot;这是一个段落。</span><br><span class="hljs-string">包含了多个语句&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>python 中多行注释使用三个单引号 <strong>‘’’</strong> 或三个双引号 **”””**。</p><p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，<strong>注意这里也设计到了python的包引用：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys; x = <span class="hljs-string">&#x27;runoob&#x27;</span>; sys.stdout.write(x + <span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>python2的打印方法是print x，python3的打印方法是print(x)</p></blockquote><p>获取当前时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br> <br>localtime = time.localtime(time.time())<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;本地时间为 :&quot;</span>, localtime<br>localtime = time.asctime( time.localtime(time.time()) ) <span class="hljs-comment"># 这是格式化的时间</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;本地时间为 :&quot;</span>, localtime<br><span class="hljs-built_in">print</span> time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime()) <br></code></pre></td></tr></table></figure><h2 id="python命令行参数"><a href="#python命令行参数" class="headerlink" title="python命令行参数"></a>python命令行参数</h2><p><a href="https://www.runoob.com/python/python-command-line-arguments.html">参考</a></p><p>Python 中可以使用 <strong>sys</strong> 的 <strong>sys.argv</strong> 来获取命令行参数：sys.argv[0] 表示脚本名。使用格式：<code>python test.py arg1 arg2 arg3</code></p><p>也可以使用getopt模块。<code> opts, args = getopt.getopt(argv,&quot;hi:o:&quot;)</code>，h后面没有冒号表示不需要参数，<code>test.py -h</code>即可，而i和o后面有冒号，表示需要参数，即<code>test.py -i inputfile -o outputfile</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/local/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> getopt<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">argv</span>):<br>    inputfile = <span class="hljs-string">&#x27;&#x27;</span><br>    outputfile = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        opts, args = getopt.getopt(argv, <span class="hljs-string">&quot;hi:o:&quot;</span>)<br>        <span class="hljs-built_in">print</span>(opts)<br>        <span class="hljs-built_in">print</span>(args)<br>    <span class="hljs-keyword">except</span> getopt.GetoptError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;</span>)<br>        sys.exit(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> opt, arg <span class="hljs-keyword">in</span> opts:<br>        <span class="hljs-keyword">if</span> opt == <span class="hljs-string">&#x27;-h&#x27;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;</span>)<br>            sys.exit()<br>        <span class="hljs-keyword">elif</span> opt <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;-i&quot;</span>, <span class="hljs-string">&quot;--ifile&quot;</span>):<br>            inputfile = arg<br>        <span class="hljs-keyword">elif</span> opt <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;-o&quot;</span>, <span class="hljs-string">&quot;--ofile&quot;</span>):<br>            outputfile = arg<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;输入的文件为：&#x27;</span>, inputfile)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;输出的文件为：&#x27;</span>, outputfile)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main(sys.argv[<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><hr><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>Python 中的变量赋值不需要类型声明。给变量赋值的时候可以一次性赋值多个：<code>a, b, c = 1, 2, &quot;john&quot;</code></p><p>变量可以理解为是对对象（比如列表等）的引用（一个指针）。</p><p>删除对象的引用：<code>del var1,var2</code>，del之后，使用这个变量会直接报错：’var1’ is not defined</p><p>Python有五个标准的数据类型：</p><ul><li>Numbers（数字）</li><li>String（字符串）</li><li>List（列表）：是有序的对象集合。列表用 <strong>[ ]</strong> 标识，是 python 最通用的复合数据类型。可以对列表进行+或者<em>操作，操作完了会改变list的长度，加号 <strong>+</strong> 是列表连接运算符，星号 ***** 是重复操作。可以用append操作，<code>list.append(&#39;Google&#39;)</code>这样。<code>del list[index]</code>删除某个元素。</em></li><li><em>Tuple（元组）：元组是另一个数据类型，类似于 List（列表）。元组用 <strong>()</strong> 标识。但是元组不能二次赋值，相当于只读列表。但是可以进行进行+或者</em>操作，<code>列表和元组不能放在一起进行+或者*</code>。元组中只包含一个元素时，需要在元素后面添加逗号：<code>tup1 = (50,)</code>。<code>del l</code>删除整个元组。 </li><li>Dictionary（字典）：类似map，字典用”{ }”标识。字典由索引(key)和它对应的值value组成。可以调用<code>map.keys()</code>和<code>.values()</code>来获取所有key和value。<code>d.clear()</code>清除字典的所有条目。<code>del d</code>删除字典。键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行。<code>dict.has_key(key)</code>查看key是否存在。&#96;&#96;str(dict)&#96;输出字典可打印的字符串表示。</li></ul><p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，比如<code>letter[1:2:4]</code></p><p><strong>运算符</strong></p><p>&#x2F;是除号，不是取整。&#x2F;&#x2F;是取整操作。Python2.x 里，&#x2F;操作，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。</p><p>**表示多少次幂，比如<code>x**y    </code></p><p>&amp;按位与运算符，|按位或运算符，^ 按位异或，~按位取反，&lt;&lt;左移，&gt;&gt;右移</p><p>and与操作，布尔值和整型等的与操作，or和not同理</p><p>成员运算符：in和not in，用于看在指定的序列中是否存在某个成员。</p><p>身份运算符：is 判断两个标识符是不是引用自一个对象，相反的是is not，相同值的整型is为true，好像类似go的&#x3D;&#x3D;，<strong>python也有&#x3D;&#x3D;操作</strong></p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p> python 并不支持 switch 语句，可用多个elif判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> 判断条件：<br>    执行语句……<br><span class="hljs-keyword">else</span>：<br>    执行语句……<br> <br><span class="hljs-keyword">if</span> 判断条件<span class="hljs-number">1</span>:<br>    执行语句<span class="hljs-number">1</span>……<br><span class="hljs-keyword">elif</span> 判断条件<span class="hljs-number">2</span>:<br>    执行语句<span class="hljs-number">2</span>……<br><span class="hljs-keyword">elif</span> 判断条件<span class="hljs-number">3</span>:<br>    执行语句<span class="hljs-number">3</span>……<br><span class="hljs-keyword">else</span>:<br>    执行语句<span class="hljs-number">4</span>……<br><br><span class="hljs-keyword">if</span> ( var  == <span class="hljs-number">100</span> ) : <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;变量 var 的值为100&quot;</span> <br></code></pre></td></tr></table></figure><p>也可在循环中加入 continue，break语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> 判断条件(condition)：<br>    执行语句(statements)……<br><br><span class="hljs-comment"># while … else 在循环条件为 false 时执行 else 语句块：</span><br><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">5</span>:<br>   <span class="hljs-built_in">print</span> count, <span class="hljs-string">&quot; is  less than 5&quot;</span><br>   count = count + <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> count, <span class="hljs-string">&quot; is not less than 5&quot;</span><br><br><span class="hljs-keyword">while</span> (flag): <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Given flag is really true!&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> iterating_var <span class="hljs-keyword">in</span> sequence:<br>   statements(s)<br><span class="hljs-comment"># for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。</span><br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>):  <span class="hljs-comment"># 迭代 10 到 20 之间的数字</span><br>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,num): <span class="hljs-comment"># 根据因子迭代</span><br>      <span class="hljs-keyword">if</span> num%i == <span class="hljs-number">0</span>:      <span class="hljs-comment"># 确定第一个因子</span><br>         j=num/i          <span class="hljs-comment"># 计算第二个因子</span><br>         <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;%d 等于 %d * %d&#x27;</span> % (num,i,j))<br>         <span class="hljs-keyword">break</span>            <span class="hljs-comment"># 跳出当前循环</span><br>   <span class="hljs-keyword">else</span>:                  <span class="hljs-comment"># 循环的 else 部分</span><br>      <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;%d 是一个质数&#x27;</span> % num)<br><span class="hljs-comment"># ....</span><br>fruits = [<span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>,  <span class="hljs-string">&#x27;mango&#x27;</span>]<br><span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(fruits)):<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;当前水果 : %s&#x27;</span> % fruits[index])<br><span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;Python&#x27;</span>:     <span class="hljs-comment"># 第一个实例</span><br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前字母: %s&quot;</span> % letter)<br></code></pre></td></tr></table></figure><p><strong>pass</strong> 不做任何事情，一般用做占位语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;Python&#x27;</span>:<br>   <span class="hljs-keyword">if</span> letter == <span class="hljs-string">&#x27;h&#x27;</span>:<br>      <span class="hljs-keyword">pass</span><br>      <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;这是 pass 块&#x27;</span><br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;当前字母 :&#x27;</span>, letter<br></code></pre></td></tr></table></figure><p>格式化打印</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;My name is %s and weight is %d kg!&quot;</span> % (<span class="hljs-string">&#x27;Zara&#x27;</span>, <span class="hljs-number">21</span>)<br></code></pre></td></tr></table></figure><p>三引号，支持换行，所见即所得</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"> hi = <span class="hljs-string">&#x27;&#x27;&#x27;hi </span><br><span class="hljs-string">there&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>unicode字符串，引号前小写的”u”表示这里创建的是一个 Unicode 字符串。：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">u&#x27;Hello\u0020World !)</span><br></code></pre></td></tr></table></figure><p>字符串内建函数：<code>string.capitalize()</code>等</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>定义的格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">functionname</span>(<span class="hljs-params"> parameters </span>):<br>   <span class="hljs-string">&quot;函数_文档字符串&quot;</span><br>   function_suite<br>   <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printme</span>(<span class="hljs-params"> <span class="hljs-built_in">str</span> </span>):<br>   <span class="hljs-string">&quot;打印传入的字符串到标准显示设备上&quot;</span><br>   <span class="hljs-built_in">print</span> <span class="hljs-built_in">str</span><br>   <span class="hljs-keyword">return</span><br>printme( <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;My string&quot;</span>) <span class="hljs-comment"># 一种调用方法，通过关键字参数</span><br>printme(<span class="hljs-string">&quot;My string&quot;</span>) <span class="hljs-comment"># 另一种一种调用方法</span><br></code></pre></td></tr></table></figure><p>函数的参数传递：</p><ul><li><strong>不可变类型：</strong>类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li><li><strong>可变类型：</strong>类似 c++ 的引用传递，如 <strong>列表，字典</strong>。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li></ul><p>默认参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printinfo</span>(<span class="hljs-params"> name, age = <span class="hljs-number">35</span> </span>):<br>   <span class="hljs-string">&quot;打印任何传入的字符串&quot;</span><br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Name: &quot;</span>, name<br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Age &quot;</span>, age<br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-comment">#调用printinfo函数</span><br>printinfo( age=<span class="hljs-number">50</span>, name=<span class="hljs-string">&quot;miki&quot;</span> )<br>printinfo( name=<span class="hljs-string">&quot;miki&quot;</span> )<br></code></pre></td></tr></table></figure><p>不定长参数，加了星号（*）的变量名会存放所有未命名的变量参数。：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printinfo</span>(<span class="hljs-params"> arg1, *vartuple </span>):<br>   <span class="hljs-built_in">print</span> arg1<br>   <span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> vartuple:<br>      <span class="hljs-built_in">print</span> var<br>   <span class="hljs-keyword">return</span><br> <br>printinfo( <span class="hljs-number">10</span> )<br>printinfo( <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span> )<br></code></pre></td></tr></table></figure><p><strong>匿名函数：</strong></p><p>通过lambda创建。语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression<br></code></pre></td></tr></table></figure><p>比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sum</span> = <span class="hljs-keyword">lambda</span> arg1, arg2: arg1 + arg2<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">10</span>, <span class="hljs-number">20</span> )<br></code></pre></td></tr></table></figure><p>返回值，不需要定义返回的参数有哪些，接收处直接使用即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"> arg1, arg2 </span>):<br>   <span class="hljs-keyword">return</span> arg1 + arg2<br> <br><span class="hljs-comment"># 调用sum函数</span><br>total = <span class="hljs-built_in">sum</span>( <span class="hljs-number">10</span>, <span class="hljs-number">20</span> )<br></code></pre></td></tr></table></figure><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">total = <span class="hljs-number">0</span> <span class="hljs-comment"># 这是一个全局变量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"> arg1, arg2 </span>):<br>   <span class="hljs-comment"># global total</span><br>   <span class="hljs-comment"># 如果在使用前指定 global total，那么就会用全局的total变量操作</span><br>   total = arg1 + arg2 <span class="hljs-comment"># total在这里是局部变量，如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。</span><br></code></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。</p><p>模块的引入：<code>import module1[, module2[,... moduleN]]</code></p><p>调用模块的函数的语法为<code>模块名.函数名</code>，同级目录下可以直接引入模块，import xxx或者<code>import .xxx</code>即可。不在同级目录，则搜索在 shell 变量 PYTHONPATH 下的每个目录。如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python&#x2F;。</p><p>xxx.py的文件，xx就是模块名。</p><p>也可以指定引入模块的某个函数：<code>from modname import name1[, name2[, ... nameN]]</code>，然后可以直接调用name1(xxx)来调用函数而不用指定模块名，也可以导入模块的所有内容<code>from modname import *</code></p><p><strong>包的概念</strong></p><p>包下面必须有__init__.py，<strong>init</strong>.py可以为空，也可以写：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;作为主程序运行&#x27;</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;package_runoob 初始化&#x27;</span><br></code></pre></td></tr></table></figure><p>被调用时<code>__name__</code>是模块名，如果直接运行init.py，那么就会打印出<code>作为主程序运行</code>，<code>__name__</code>是<code>__main__</code></p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>异常即是一个事件，捕捉异常可以使用try&#x2F;except语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>&lt;语句&gt;        <span class="hljs-comment">#运行别的代码</span><br><span class="hljs-keyword">except</span> &lt;名字&gt;：<br>&lt;语句&gt;        <span class="hljs-comment">#如果在try部份引发了&#x27;name&#x27;异常</span><br><span class="hljs-keyword">except</span> &lt;名字&gt;，&lt;数据&gt;:<br>&lt;语句&gt;        <span class="hljs-comment">#如果引发了&#x27;name&#x27;异常，获得附加的数据</span><br><span class="hljs-keyword">else</span>:<br>&lt;语句&gt;        <span class="hljs-comment">#如果没有异常发生</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    正常的操作<br>   ......................<br><span class="hljs-keyword">except</span>(Exception1[, Exception2[,...ExceptionN]]):<br>   发生以上多个异常中的一个，执行这块代码<br>   ......................<br><span class="hljs-keyword">else</span>:<br>    如果没有异常执行这块代码<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>&lt;语句&gt;<br><span class="hljs-keyword">finally</span>:<br>&lt;语句&gt;    <span class="hljs-comment">#退出try时总会执行，总是会执行</span><br></code></pre></td></tr></table></figure><p>可以使用raise语句自己触发异常，触发异常后，后面的代码就不会再执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">raise</span> [Exception [, args [, traceback]]]<br></code></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>类的self代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。<strong>self代表类的实例，而非类</strong>。**self.<strong>class</strong>**指向类而不是类的实例。</p><p><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。</p><p>定义类的函数可以指定self参数，self指的是类的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>:<br>   empCount = <span class="hljs-number">0</span><br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, salary</span>):<br>      self.name = name<br>      self.salary = salary<br>      Employee.empCount += <span class="hljs-number">1</span><br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">displayCount</span>(<span class="hljs-params">self</span>):<br>     <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Total Employee %d&quot;</span> % Employee.empCount<br> <br>emp1 = Employee(<span class="hljs-string">&quot;Zara&quot;</span>, <span class="hljs-number">2000</span>)<br>emp1.displayEmployee()<br></code></pre></td></tr></table></figure><p>可以添加，删除（通过del e.xxx)，修改类的属性</p><p>也可以使用以下函数的方式来访问属性：</p><ul><li>getattr(obj, name[, default]) : 访问对象的属性。</li><li>hasattr(obj,name) : 检查是否存在一个属性。</li><li>setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。</li><li>delattr(obj, name) : 删除属性。</li></ul><p><strong>python对象销毁(垃圾回收)</strong></p><p>Python 使用了引用计数这一简单技术来跟踪和回收垃圾。</p><p>Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（即未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">40</span>      <span class="hljs-comment"># 创建对象  &lt;40&gt;</span><br>b = a       <span class="hljs-comment"># 增加引用， &lt;40&gt; 的计数</span><br>c = [b]     <span class="hljs-comment"># 增加引用.  &lt;40&gt; 的计数</span><br><br><span class="hljs-keyword">del</span> a       <span class="hljs-comment"># 减少引用 &lt;40&gt; 的计数</span><br>b = <span class="hljs-number">100</span>     <span class="hljs-comment"># 减少引用 &lt;40&gt; 的计数</span><br>c[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>   <span class="hljs-comment"># 减少引用 &lt;40&gt; 的计数</span><br><span class="hljs-comment"># 4494605328 4494605328 4494605328</span><br><span class="hljs-comment"># Point 销毁</span><br></code></pre></td></tr></table></figure><p>析构函数 <strong>del</strong> ，__del__在对象销毁的时候被调用，当对象（比如一个类）不再被使用时，__del__方法运行：</p><p><strong>类的继承</strong></p><p>通过继承创建的新类称为<strong>子类</strong>或<strong>派生类</strong>，被继承的类称为<strong>基类</strong>、<strong>父类</strong>或<strong>超类</strong>。</p><p>如果在子类中需要父类的构造方法就需要显式地调用父类的构造方法，或者不重写父类的构造方法。</p><p>子类不重写 **<strong>init</strong>**的话，实例化子类时，会自动调用父类定义的 <strong><strong>init</strong><strong>。如果重写了</strong><strong>init</strong></strong> 时，实例化子类，就不会调用父类已经定义的 <strong><strong>init</strong></strong></p><p>如果重写了**<strong>init</strong>** 时，要继承父类的构造方法，可以使用 <strong>super</strong> 关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name=name<br>        <span class="hljs-built_in">print</span> ( <span class="hljs-string">&quot;name: %s&quot;</span> %( self.name))<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Father &#x27;</span> + self.name<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>(<span class="hljs-title class_ inherited__">Father</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-built_in">super</span>(Son, self).__init__(name)<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;hi&quot;</span>)<br>        self.name =  name<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Son &#x27;</span>+self.name<br> <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    son=Son(<span class="hljs-string">&#x27;runoob&#x27;</span>)<br>    <span class="hljs-built_in">print</span> ( son.getName() )<br></code></pre></td></tr></table></figure><p>派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示，这是继承了多个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClassName</span> (ParentClass1[, ParentClass2, ...]):<br></code></pre></td></tr></table></figure><p>Python同样支持运算符重载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a, b</span>):<br>        self.a = a<br>        self.b = b<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Vector (%d, %d)&#x27;</span> % (self.a, self.b)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> Vector(self.a + other.a, self.b + other.b)<br><br><br>v1 = Vector(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>)<br>v2 = Vector(<span class="hljs-number">5</span>, -<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(v1, v2)<br><span class="hljs-built_in">print</span>(v1 + v2)<br><span class="hljs-comment"># Vector (2, 10) Vector (5, -2)</span><br><span class="hljs-comment"># Vector (7, 8)</span><br></code></pre></td></tr></table></figure><p><strong>私有属性</strong>：两个下划线开头，则声明该属性为私有，不能在类的外部被使用或直接访问。Python不允许实例化的类访问私有数据，但你可以使用 <strong>object._className__attrName</strong>（ <strong>对象名._类名__私有属性名</strong> ）访问属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Runoob</span>:<br>    __site = <span class="hljs-string">&quot;www.runoob.com&quot;</span><br><br>runoob = Runoob()<br><span class="hljs-built_in">print</span> runoob._Runoob__site<br></code></pre></td></tr></table></figure><p><strong>类内定义的方法第一个参数必须是self。</strong></p><p>单下划线、双下划线、头尾双下划线说明：</p><ul><li><strong><strong>foo</strong></strong>: 定义的是特殊方法，一般是系统定义名字 ，类似 <strong><strong>init</strong>()</strong> 之类的。</li><li><strong>_foo</strong>: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 <strong>from module import *</strong></li><li><strong>__foo</strong>: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>redis设计与实现（更新中）</title>
    <link href="/2022/07/30/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/07/30/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>redis设计与实现（注意记录的时候要记录每个大小章节而不只括起来的部分）</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>redis内置了<strong>集合数据类型</strong>，并支持对集合执行交集、并集、差集等集合计算操作</p><p>redis可以存储二进制位，使用SETBIT命令</p><h2 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h2><p>redis是用C写的，本书的粘贴的源代码就是C语言代码</p><h2 id="第一部分-数据结构与对象"><a href="#第一部分-数据结构与对象" class="headerlink" title="第一部分 数据结构与对象"></a>第一部分 数据结构与对象</h2><h2 id="第二章-简单动态字符串"><a href="#第二章-简单动态字符串" class="headerlink" title="第二章 简单动态字符串"></a>第二章 简单动态字符串</h2><p>redis没有直接使用C语言传统的字符串表示（以空字符串结尾的字符串数组），而是自己构建了一种名为<strong>简单动态字符串（simple dynamic string，SDS）</strong>的抽象类型。当redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，就会使用SDS表示字符串值。</p><p>比如<code>SET msg &quot;hello world&quot;</code>，执行完成后redis会在数据库创建一个键值对，键和值底层实现都是SDS。</p><h3 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sddshdr</span> &#123;</span><br><span class="hljs-type">int</span> len; <span class="hljs-comment">// 记录 buf 数组中已使用字节的数量，等于SDS所保存字符串的长度</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">free</span>; <span class="hljs-comment">// 记录 buf 数组中未使用字节的数量</span><br><span class="hljs-type">char</span> buf[]; <span class="hljs-comment">// 字节数组，用于保存字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h3><ol><li><p>获取字符串长度的复杂度：SDS有一个len属性，记录了SDS本身的长度，所以获取一个SDS长度的复杂度为O(1)。而C字符串需要遍历整个字符串直到结尾的空字符串，故时间复杂度为O(n)。</p></li><li><p>是否会发生缓冲区溢出：C字符串因为不记录自身的长度容易造成缓冲区溢出。SDS则完全杜绝缓冲区溢出，因为对SDS修改前，API会首先检查SDS的空间是否满足要求，不满足则修改SDS的空间。</p></li><li><p>修改字符串产生的内存重分配次数</p><p>C字符串的增长操作需要程序通过内存重分配来扩展底层数组的空间大小，忘记这一步会发生<strong>缓冲区溢出</strong>。缩短操作则需要程序释放字符串不需要的空间，否则会发生<strong>内存泄露</strong>。</p><p>SDS因为包含了未使用的字节，未使用的字节解除了字符串长度和底层数组长度之间的关联。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>elasticsearch入门</title>
    <link href="/2022/07/16/elasticsearch%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/16/elasticsearch%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，</strong></p><h2 id="补充的docker命令"><a href="#补充的docker命令" class="headerlink" title="补充的docker命令"></a>补充的docker命令</h2><p><strong>删除所有状态为退出的容器：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker rm <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">ps</span> -<span class="hljs-params">a</span> -<span class="hljs-params">f</span> <span class="hljs-params">status</span>=<span class="hljs-params">exited</span> -<span class="hljs-params">q</span>)</span><br></code></pre></td></tr></table></figure><h2 id="启动单节点集群"><a href="#启动单节点集群" class="headerlink" title="启动单节点集群"></a>启动单节点集群</h2><p><strong>为Elasticsearch和Kibana创建docker网络</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker network create elastic</span><br></code></pre></td></tr></table></figure><p><strong>启动</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run --name es01 --net elastic -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> -it docker.elastic.co/elasticsearch/elasticsearch:<span class="hljs-number">8</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>会生成elastic用户的密码和用于注册Kibana的token（有效期30min）</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">-&gt;  Password <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> elastic user (reset <span class="hljs-keyword">with</span> `bin/elasticsearch-reset-password -u elastic`):<br>  xy1JLdqhhLIQemauzxdB<br><br>-&gt;  HTTP CA certificate SHA<span class="hljs-number">-256</span> fingerprint:<br>  fd16b3840cc28a25b8ba950e9bbc68f9a1fe84b538d2b8daf63bad27620041ef<br><br>-&gt;  Configure Kibana <span class="hljs-built_in">to</span> use this cluster:<br>* Run Kibana <span class="hljs-keyword">and</span> click <span class="hljs-keyword">the</span> configuration link <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> terminal when Kibana starts.<br>* Copy <span class="hljs-keyword">the</span> following enrollment <span class="hljs-keyword">token</span> <span class="hljs-keyword">and</span> paste <span class="hljs-keyword">it</span> <span class="hljs-keyword">into</span> Kibana <span class="hljs-keyword">in</span> your browser (valid <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> next <span class="hljs-number">30</span> minutes):<br>  eyJ2ZXIiOiI4LjIuMiIsImFkciI6WyIxNzIuMTguMC4yOjkyMDAiXSwiZmdyIjoiZmQxNmIzODQwY2MyOGEyNWI4YmE5NTBlOWJiYzY4ZjlhMWZlODRiNTM4ZDJiOGRhZjYzYmFkMjc2MjAwNDFlZiIsImtleSI6ImhYNDBSNEVCUmptMkhGc3R6V2NFOmFUbjZURUJfUmhlUXhGYjh4bk9pVFEifQ==<br><br>-&gt; Configure other nodes <span class="hljs-built_in">to</span> join this cluster:<br>* Copy <span class="hljs-keyword">the</span> following enrollment <span class="hljs-keyword">token</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">start</span> <span class="hljs-built_in">new</span> Elasticsearch nodes <span class="hljs-keyword">with</span> `bin/elasticsearch <span class="hljs-comment">--enrollment-token &lt;token&gt;` (valid for the next 30 minutes):</span><br>  eyJ2ZXIiOiI4LjIuMiIsImFkciI6WyIxNzIuMTguMC4yOjkyMDAiXSwiZmdyIjoiZmQxNmIzODQwY2MyOGEyNWI4YmE5NTBlOWJiYzY4ZjlhMWZlODRiNTM4ZDJiOGRhZjYzYmFkMjc2MjAwNDFlZiIsImtleSI6ImgzNDBSNEVCUmptMkhGc3R6V2NfOkw1ZG85U3d5UzN1TUJVd2VLdGtWTXcifQ==<br></code></pre></td></tr></table></figure><p><strong>从docker容器中将http_ca.crt复制到本机上</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker cp es01:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>config<span class="hljs-regexp">/certs/</span>http_ca.crt .<br></code></pre></td></tr></table></figure><p><strong>测试能否连接上ES集群</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">curl <span class="hljs-attr">--cacert</span> http_ca<span class="hljs-selector-class">.crt</span> -u elastic https:<span class="hljs-comment">//localhost:9200</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>Docker 挂载数据卷的默认权限是可读写(rw)，用户也可以通过 ro 标记指定为只读：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo docker run -d -P –-name web -v <span class="hljs-regexp">/var/</span>data:<span class="hljs-regexp">/opt/</span>webdata:ro myimg/webapp python app.py<br></code></pre></td></tr></table></figure><p><strong>加了 :ro 之后，容器内挂载的数据卷内的数据就变成只读的了。</strong></p></blockquote><h2 id="启动kibana"><a href="#启动kibana" class="headerlink" title="启动kibana"></a>启动kibana</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run --name kib-<span class="hljs-number">01</span> --net elastic -p <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span> docker.elastic.co/kibana/kibana:<span class="hljs-number">8</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>会显示一个链接，点击该链接，比如访问</strong><a href="http://localhost:5601/?code=052166">http://localhost:5601/?code=052166</a></p><p><strong>登录的用户就写elastic</strong></p><h3 id="持久化kibana的一些配置"><a href="#持久化kibana的一些配置" class="headerlink" title="持久化kibana的一些配置"></a>持久化kibana的一些配置</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run --name kib-<span class="hljs-number">01</span> --net elastic -p <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span> -v <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/kibana.yml:/u</span>sr<span class="hljs-regexp">/share/</span>kibana<span class="hljs-regexp">/config/</span>kibana.yml docker.elastic.co<span class="hljs-regexp">/kibana/</span>kibana:<span class="hljs-number">8.2</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="如何写入数据"><a href="#如何写入数据" class="headerlink" title="如何写入数据"></a>如何写入数据</h2><p><strong>目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。Beats将数据发送到Logstash或Elasticsearch。</strong></p><h3 id="通过logstash同步文件"><a href="#通过logstash同步文件" class="headerlink" title="通过logstash同步文件"></a>通过logstash同步文件</h3><p><a href="https://zhuanlan.zhihu.com/p/158697278">一个简单的可用的ELK</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker compose <span class="hljs-operator">-f</span> ELK.yml up <span class="hljs-literal">-d</span> <span class="hljs-comment"># 启动</span><br>docker compose <span class="hljs-operator">-f</span> ELK.yml restart <span class="hljs-comment"># 重启</span><br></code></pre></td></tr></table></figure><p><strong>注意logstash.conf中需要指定，否则无法成功上报数据给ES：</strong></p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">input</span> &#123;<br>  beats &#123;<br>    <span class="hljs-attr">port</span> =&gt; <span class="hljs-number">5044</span><br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">elasticsearch</span> &#123;<br>   <span class="hljs-attr">hosts</span> =&gt; [<span class="hljs-string">&quot;http://elasticsearch:9200&quot;</span>]  <span class="hljs-comment">#elasticsearch请求地址</span><br>   <span class="hljs-attr">index</span> =&gt; <span class="hljs-string">&quot;xxx&quot;</span><br></code></pre></td></tr></table></figure><p><strong>指定索引后，需要在kibana上创建索引，才可以成功查看。</strong></p><p><strong>关于 Logstash.conf的一些字段含义（语法），可以参考</strong><a href="https://blog.csdn.net/UbuntuTouch/article/details/114383426">Logstash：解析 JSON 文件并导入到 Elasticsearch 中</a></p><h3 id="直接写ES"><a href="#直接写ES" class="headerlink" title="直接写ES"></a>直接写ES</h3><p><strong>对于go来说，使用官方client即可。</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">es, <span class="hljs-keyword">err</span> := elasticsearch.NewClient(elasticsearch.Config&#123;<br>Addresses: []string&#123;<span class="hljs-string">&quot;http://127.0.0.1:9200&quot;</span>&#125;,<br>&#125;)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &#123;<br><span class="hljs-keyword">log</span>.Fatalf(<span class="hljs-string">&quot;Error creating the client: %s&quot;</span>, <span class="hljs-keyword">err</span>)<br>&#125;<br>res, <span class="hljs-keyword">err</span> := es.Info()<br></code></pre></td></tr></table></figure><p><strong>注意客户端版本需要和服务端的版本一致。我使用的是</strong> <code>github.com/elastic/go-elasticsearch/v7</code></p><h2 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h2><p><strong>是一个数据分析软件，对数据进行聚合和处理，是一个开源的服务器端数据处理管道。</strong></p><p><strong>logstash是controller层，Elasticsearch是一个model层，kibana是view层。</strong></p><p><strong>首先将数据传给logstash，它将数据进行过滤和格式化（转成JSON格式），然后传给</strong><a href="https://so.csdn.net/so/search?q=Elasticsearch&spm=1001.2101.3001.7020">Elasticsearch</a>进行存储、建搜索的索引，kibana提供前端的页面再进行搜索和图表可视化，它是调用Elasticsearch的接口返回的数据进行可视化。</p><h3 id="logstash-conf语法"><a href="#logstash-conf语法" class="headerlink" title="logstash.conf语法"></a>logstash.conf语法</h3><p><strong>在生产环境中，Logstash管道会非常复杂：一般包含一个或多个输入，过滤器，输出插件。</strong></p><p><strong>logstash.conf语法主要就是关于logstash pipeline是如何写的。</strong></p><p><strong>pipeline工作内容： 从input读取事件源 —-&gt; 经过filter解析和处理之后 —-&gt; 从output输出到目标存储库（elasticsearch或其他）。</strong></p><p><a href="https://blog.csdn.net/UbuntuTouch/article/details/114383426">Logstash：解析 JSON 文件并导入到 Elasticsearch 中</a></p><p><strong>使用 json codec中</strong>，<strong>sample.json</strong>可以写多行，会解析成多个结果，也可以叫sample.log，需要在logstash.conf指定 <code>codec   =&gt; &quot;json&quot;</code></p><p><strong>使用 JSON filter，filter里不需要指定</strong> <code>codec   =&gt; &quot;json&quot;</code>了，但是要在filter里写 <code>json&#123;source=&gt;&quot;message&quot;&#125;</code></p><blockquote><p><strong>PS：需要多用，善用Dev Tools</strong></p><p><strong>也可以请求</strong><a href="http://127.0.0.1:9200/">http://127.0.0.1:9200</a>来请求elasticsearch获取一些数据，比如GET <a href="http://127.0.0.1:9200/_search">http://127.0.0.1:9200/_search</a></p></blockquote><h2 id="beats"><a href="#beats" class="headerlink" title="beats"></a>beats</h2><p>** Filebeat 和 Logstash 都是请求ES的API来同步数据的。**</p><h3 id="Filebeat"><a href="#Filebeat" class="headerlink" title="Filebeat"></a>Filebeat</h3><p><strong>可以配置Filebeat发送日志到Logstash</strong></p><p><strong>Filebeat是轻量级，资源占用较低的日志收集工具，****从各服务器上收集日志并将这些日志发送到Logstash实例</strong>中处理。</p><p><strong>Logstash默认安装已含有</strong><a href="https://link.juejin.cn/?target=http://www.elastic.co/guide/en/logstash/6.5/plugins-inputs-beats.html">Beat input</a>插件。<code>Beat</code>输入插件使Logstash可以从 <code>Elastic Beat</code>框架接收事件，这意味者任何编写为与 <code>Beat</code>框架一起工作的Beat(如Packetbeat和Metricbeat)都可以将事件数据发送到Logstash。</p><h3 id="metricbeat"><a href="#metricbeat" class="headerlink" title="metricbeat"></a>metricbeat</h3><p><strong>用于从系统和服务收集指标。Metricbeat 能够以一种轻量型的方式，输送各种系统和服务统计数据，从 CPU 到内存，从 Redis 到 Nginx，不一而足。</strong></p><p><strong>Metricbeat 提供多种内部模块，这些模块可从多项服务（Prometheus，Prometheus等）中收集指标。只需在配置文件中启用您所需的模块即可。除了这些服务，也可以构建自己的模块。</strong></p><h3 id="packetbeat"><a href="#packetbeat" class="headerlink" title="packetbeat"></a>packetbeat</h3><h2 id="映射Mapping"><a href="#映射Mapping" class="headerlink" title="映射Mapping"></a>映射Mapping</h2><p><strong>Mapping是用来定义一个文档（document），以及它所包含的属性（field）是如何存储和索引的。</strong></p><p><strong>比如：可以使用Mapping来定义哪些字符串属性应该被看作全文索引（full text fields），哪些属性包含数字，日期或者地理位置。文档中的所有属性是否都能被索引（_all 配置）。</strong></p><p><strong>在</strong><a href="https://so.csdn.net/so/search?q=ES6&spm=1001.2101.3001.7020">ES6</a>.0.0及更高的版本中，创建的索引只能包含一个映射类型。</p><p><strong>每一个映射类型包含：元标签，字段或属性。</strong></p><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>*<em>在Elasticsearch下，一个文档除了有数据之外，它还包含了</em>***元数据(Metadata)**。每创建一条数据时，都会对元数据进行写入等操作，当然有些元数据是在创建mapping的时候就会设置，元数据在Elasticsearch下起到了非常大的作用。</p><h4 id="身份元数据"><a href="#身份元数据" class="headerlink" title="身份元数据"></a>身份元数据</h4><p><strong>Identity meta-fields</strong></p><p><code>_index</code>：文档所属的index，这个index相当于关系型数据库中的数据库概念，它是存储和索引关联数据的地方；</p><p><code>_uid</code>：其由 <code>_type</code>和 <code>_id</code>组成；</p><p><code>_type</code>：文档所属的mapping type，相当于关系型数据库中的<strong>表</strong>的概念；</p><p><code>_id</code>：文档的id，这个可以由Elasticsearch自动生成，也可以在写入Document的时候由程序指定。它与 <code>_index</code>和 <code>_type</code>组合时，就可以在Elasticsearch中唯一标识一个文档。</p><h4 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h4><p><strong>Document source meta-fields</strong></p><p><code>_source</code>：这个字段标识文档的主体信息，也就是我们写入在<a href="https://www.iteblog.com/archives/tag/elasticsearch/">ElasticSearch</a>中的数据；</p><p><code>_size</code>：这个字段存储着_source字段中信息的大小，单位是byte；不过这需要我们安装mapper-size插件。</p><h4 id="索引元数据"><a href="#索引元数据" class="headerlink" title="索引元数据"></a>索引元数据</h4><p><strong>Indexing meta-fields</strong></p><p><code>_all</code>：这个字段索引了所有其他字段的值；</p><p><code>_field_names</code>：存储着文档中所有值为非空的字段信息，这在快速查找&#x2F;过滤值存在或者值为空的情况下非常有用；</p><p><code>_timestamp</code>：存储着当前文档的时间戳信息，可以由程序指定，也可以由ElasticSearch自动生成，其值会影响文档的删除（如果启用了TTL机制）；</p><p><code>_ttl</code>：标识着当前文档存储的时长，超过了这个时长文档将会被标识为delete，之后会被ElasticSearch删除。</p><h4 id="路由元数据"><a href="#路由元数据" class="headerlink" title="路由元数据"></a>路由元数据</h4><p><strong>Routing meta-fields</strong></p><p><code>_parent</code>：用于创建两个映射的父子之间的关系；</p><p><code>_routing</code>：自定义路由值，可以路由某个文档到具体的分片(shard)。</p><h4 id="其他元数据"><a href="#其他元数据" class="headerlink" title="其他元数据"></a>其他元数据</h4><p><code>_meta</code>：特定于应用程序的元数据。</p><h3 id="映射分类"><a href="#映射分类" class="headerlink" title="映射分类"></a>映射分类</h3><h4 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a><strong>动态映射</strong></h4><p><strong>就是自动创建出来的映射。es 根据存入的文档，自动分析出来文档中字段的类型以及存储方式，这种就是动态映射。</strong></p><p><strong>有的时候，如果希望新增字段时，能够抛出异常来提醒开发者，这个可以通过 mappings 中 dynamic 属性来配置。</strong></p><p><strong>dynamic 属性有三种取值：</strong></p><ul><li><strong>true，默认即此。自动添加新字段。</strong></li><li><strong>false，忽略新字段。</strong></li><li><strong>strict，严格模式，发现新字段会抛出异常。</strong></li></ul><p><strong>映射会根据某个字段插入的值自动判断其字段类型，</strong></p><h4 id="静态映射"><a href="#静态映射" class="headerlink" title="静态映射"></a>静态映射</h4><p><strong>像mysql一样在建表的时候对各个字段的属性进行设置，手动创建映射并指定各个字段类型。如果新增的文档的某个字段和指定的类型不一致，新增就不会成功会报错。</strong></p><h3 id="映射的操作"><a href="#映射的操作" class="headerlink" title="映射的操作"></a>映射的操作</h3><p><strong>查看所有映射</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> _mapping<br></code></pre></td></tr></table></figure><p><strong>查看某个索引下的映射：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> index_name/_mapping<br></code></pre></td></tr></table></figure><p><strong>创建某个索引下的映射</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">POST packet_4/_mapping<br>&#123;<br>  <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;src_ip&quot;</span>:&#123;<br>      <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;ip&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>修改索引，可以添加新字段，不能修改已有字段，如下增加一个email字段到映射里</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">PUT <span class="hljs-regexp">/packet_2/</span>_mapping<br>&#123;<br>  <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;email&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p><strong>这是对ES的数据进行的统计分析的功能，ES的另一个重要功能是搜索。</strong></p><p><strong>聚合有点像mongodb的aggregate。</strong></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="指标"><a href="#指标" class="headerlink" title="指标"></a><strong>指标</strong></h4><p><strong>指标metric聚合</strong></p><h4 id="桶"><a href="#桶" class="headerlink" title="桶"></a><strong>桶</strong></h4><p><strong>bucketing桶聚合</strong></p><p><strong>即分桶操作，类似于关系型数据库的group by</strong></p><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a><strong>矩阵</strong></h4><p><strong>矩阵聚合</strong>（matrix）</p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a><strong>管道</strong></h4><p>** 管道聚合（pipleline）**</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">&quot;aggregations&quot; : &#123;<br>    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">aggregation_name</span>&gt;</span>&quot; : &#123; <span class="hljs-comment">&lt;!--聚合的名字 --&gt;</span><br>        &quot;<span class="hljs-tag">&lt;<span class="hljs-name">aggregation_type</span>&gt;</span>&quot; : &#123; <span class="hljs-comment">&lt;!--聚合的类型 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aggregation_body</span>&gt;</span> <span class="hljs-comment">&lt;!--聚合体：对哪些字段进行聚合 --&gt;</span><br>        &#125;<br>        [,&quot;meta&quot; : &#123;  [<span class="hljs-tag">&lt;<span class="hljs-name">meta_data_body</span>&gt;</span>] &#125; ]? <span class="hljs-comment">&lt;!--元 --&gt;</span><br>        [,&quot;aggregations&quot; : &#123; [<span class="hljs-tag">&lt;<span class="hljs-name">sub_aggregation</span>&gt;</span>]+ &#125; ]? <span class="hljs-comment">&lt;!--在聚合里面在定义子聚合 --&gt;</span><br>    &#125;<br>    [,&quot;<span class="hljs-tag">&lt;<span class="hljs-name">aggregation_name_2</span>&gt;</span>&quot; : &#123; ... &#125; ]*<span class="hljs-comment">&lt;!--聚合的名字 --&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>aggregations 也可简写为 aggs</strong></p><p><strong>比如：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST <span class="hljs-regexp">/packet_4/</span>_search?<br>&#123;<br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">0</span>, <br>  <span class="hljs-string">&quot;aggs&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;masssbalance&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;max&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;field&quot;</span>: <span class="hljs-string">&quot;dst_port&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在&#x2F;packet_4&#x2F;_search?追加size&#x3D;0可以让返回结果中的hits字段长度为0，否则的话会返回所有命中的文档影响查看。</strong></p><p><strong>下面是一些简单的例子：</strong></p><p><strong>统计数量</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST <span class="hljs-regexp">/bank/</span>_doc/_count<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;age&quot;</span> : <span class="hljs-number">24</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Value count 统计某字段有值的文档数</strong></p><p><strong>cardinality 值去重计数</strong></p><p><strong>stats 统计 count max min avg sum 5个值</strong></p><p><strong>Extended stats，在stats基础上统计平方和、方差、标准差、平均值加&#x2F;减两个标准差的区间</strong></p><p><strong>Percentiles 占比百分位对应的值统计</strong></p><p><strong>Percentiles rank 统计值小于等于指定值的文档占比</strong></p><p><strong>PS:我写的一些：</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs gradle">POST <span class="hljs-regexp">/packet_4/</span>_search?<br>&#123;<br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">0</span>, <br>  <span class="hljs-string">&quot;aggs&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;masssbalance&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;max&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;field&quot;</span>: <span class="hljs-string">&quot;dst_port&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br>POST <span class="hljs-regexp">/packet_4/</span>_search?<br>&#123;<br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">3</span>, <br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;dst_port&quot;</span>: <span class="hljs-number">9200</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;src_port&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span><br>      &#125;<br>    &#125;<br>  ],<br>  <span class="hljs-string">&quot;aggs&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;max_balance&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;max&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;field&quot;</span>: <span class="hljs-string">&quot;src_port&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br>POST <span class="hljs-regexp">/packet_4/</span>_search?<span class="hljs-keyword">size</span>=<span class="hljs-number">0</span><br>&#123;<br>  <span class="hljs-string">&quot;aggs&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;avg_port&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;avg&quot;</span>: &#123; <span class="hljs-string">&quot;field&quot;</span> : <span class="hljs-string">&quot;src_port&quot;</span> &#125; <br>    &#125;,<br>     <span class="hljs-string">&quot;avg_port+10&quot;</span>: &#123;<br>       <br>      <span class="hljs-string">&quot;avg&quot;</span>: &#123;  <br>        <span class="hljs-string">&quot;field&quot;</span>: <span class="hljs-string">&quot;src_port&quot;</span>,<br>        <span class="hljs-string">&quot;script&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;source&quot;</span>: <span class="hljs-string">&quot;_value + 10&quot;</span><br>        &#125;&#125; <br>    &#125;<br>  &#125;<br>&#125;<br><br>POST <span class="hljs-regexp">/packet_4/</span>_search?<span class="hljs-keyword">size</span>=<span class="hljs-number">0</span><br>&#123;<br>  <span class="hljs-string">&quot;aggs&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;sum_balance&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;sum&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;field&quot;</span>: <span class="hljs-string">&quot;src_port&quot;</span>,<br>        <span class="hljs-string">&quot;script&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;source&quot;</span>: <span class="hljs-string">&quot;_value * 2.03&quot;</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>详细的语法可以参考第三个参考文档</strong></p><h2 id="ES字段类型"><a href="#ES字段类型" class="headerlink" title="ES字段类型"></a>ES字段类型</h2><p><strong>字符串类型</strong>： text（字段要被全文检索的话，可以使用该类型，用了 text 之后，字段内容会被分析，在生成倒排索引之前，字符串会被分词器分成一个个词项。text 类型的字段不用于排序，很少用于聚合。这种字符串也被称为 analyzed 字段）keyword（适用于结构化的字段，用作过滤、排序、聚合等。这种字符串也称之为 not-analyzed 字段。）</p><p><strong>数字类型</strong>：long，integer，short，byte，double，float，half_float，scaled_float</p><p><strong>日期类型</strong>：由于 JSON 中没有日期类型，所以 es 中的日期类型形式就比较多样，es 内部存储的是毫秒计时的长整型数。</p><p><strong>布尔类型</strong>boolean：ES解析字段是根据json格式的文档解析的，对于布尔值，可以解析json中的true,false,”true”,”false”</p><p><strong>二进制类型</strong>binary</p><p><strong>范围类型</strong>：integer_range，float_range，long_range，double_range，date_range，ip_range</p><p><strong>复合类型</strong>：数组，对象object，嵌套类型nested</p><p><strong>地理类型</strong>：geo_point，geo_shape</p><p><strong>特殊类型： IP，token_count</strong></p><h3 id="IP类型的使用"><a href="#IP类型的使用" class="headerlink" title="IP类型的使用"></a>IP类型的使用</h3><p><a href="https://blog.csdn.net/ubuntutouch/article/details/108517735">原文</a></p><p><strong>在使用 Elasticsearch 搜索 IP 地址时，我们可以把数据类型定义为 IP  数据类型。这样我们可以针对 IP 地址进行搜索。这种 IP 地址可以是 IPv4 或者是 IPv6 的形式。</strong></p><p><strong>现在假设我们导入一个如下的数据到 Elasticsearch 中：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">PUT my-index<span class="hljs-regexp">/_doc/</span><span class="hljs-number">1</span><br>&#123;<br>  <span class="hljs-string">&quot;ip_addr&quot;</span>: <span class="hljs-string">&quot;192.168.1.1&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在没有定义数据类型的情况下， Elasticsearch 会把上面的字段 ip_add 映射到一个 text  及 keyword 的类型的数据上：</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">GET <span class="hljs-keyword">my</span>-<span class="hljs-keyword">index</span>/_mapping<br></code></pre></td></tr></table></figure><p><strong>上面命令显示的结果为：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ada">&#123;<br>  <span class="hljs-string">&quot;my-index&quot;</span> : &#123;<br>    <span class="hljs-string">&quot;mappings&quot;</span> : &#123;<br>      <span class="hljs-string">&quot;properties&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;ip_addr&quot;</span> : &#123;<br>          <span class="hljs-string">&quot;type&quot;</span> : &quot;<span class="hljs-type">text</span><span class="hljs-string">&quot;,</span><br><span class="hljs-string">          &quot;</span>fields<span class="hljs-string">&quot; : &#123;</span><br><span class="hljs-string">            &quot;</span>keyword<span class="hljs-string">&quot; : &#123;</span><br><span class="hljs-string">              &quot;</span><span class="hljs-keyword">type</span><span class="hljs-string">&quot; : &quot;</span>keyword<span class="hljs-string">&quot;,</span><br><span class="hljs-string">              &quot;</span>ignore_above<span class="hljs-string">&quot; : 256</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">          &#125;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>假如我们想对上面的数据进行如下的搜索：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">GET my-<span class="hljs-built_in">index</span>/_<span class="hljs-built_in">search</span><br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span><span class="hljs-symbol">:</span> &#123;<br>    <span class="hljs-string">&quot;term&quot;</span><span class="hljs-symbol">:</span> &#123;<br>      <span class="hljs-string">&quot;ip_addr&quot;</span><span class="hljs-symbol">:</span> <span class="hljs-string">&quot;192.168.0.0/16&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>针对上面的搜索，我稍微做一下解释：对于上面的 IPv4 的 IP 地址含有4个 bytes，而每个 byte 含有8个 digits。****在上面的 &#x2F;16 即表示前面的 16 位的 digits，也即 192.168。我们可以这么说任何一个 IP 地址位于 192.168.0.0 至 192.168.255.255 都在这个范围内。</strong></p><p><strong>上面的搜索的结果是：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ada">&#123;<br>  <span class="hljs-string">&quot;took&quot;</span> : 0,<br>  <span class="hljs-string">&quot;timed_out&quot;</span> : <span class="hljs-type">false</span>,<br>  <span class="hljs-string">&quot;_shards&quot;</span> : &#123;<br>    <span class="hljs-string">&quot;total&quot;</span> : 1,<br>    <span class="hljs-string">&quot;successful&quot;</span> : 1,<br>    <span class="hljs-string">&quot;skipped&quot;</span> : 0,<br>    <span class="hljs-string">&quot;failed&quot;</span> : 0<br>  &#125;,<br>  <span class="hljs-string">&quot;hits&quot;</span> : &#123;<br>    <span class="hljs-string">&quot;total&quot;</span> : &#123;<br>      <span class="hljs-string">&quot;value&quot;</span> : 0,<br>      <span class="hljs-string">&quot;relation&quot;</span> : &quot;<span class="hljs-type">eq</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &quot;</span>max_score<span class="hljs-string">&quot; : null,</span><br><span class="hljs-string">    &quot;</span>hits<span class="hljs-string">&quot; : [ ]</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>也就是找不到任何的结果。这是什么原因呢？</strong></p><p><strong>就其原因，是因为我们没有正确地把 IP 的数据类型定义为 IP 数据类型。我们重新来定义这个索引的 mapping：</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs perl">DELETE <span class="hljs-keyword">my</span>-<span class="hljs-keyword">index</span><br><br>PUT <span class="hljs-keyword">my</span>-<span class="hljs-keyword">index</span><br>&#123;<br>  <span class="hljs-string">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;ip_addr&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;ip&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br>PUT <span class="hljs-keyword">my</span>-<span class="hljs-keyword">index</span>/_doc/<span class="hljs-number">1</span><br>&#123;<br>  <span class="hljs-string">&quot;ip_addr&quot;</span>: <span class="hljs-string">&quot;192.168.1.1&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我们按照上面的步骤来重新建立索引，并导入文档。我们在按照如下的方法来进行搜索：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">GET my-<span class="hljs-built_in">index</span>/_<span class="hljs-built_in">search</span><br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span><span class="hljs-symbol">:</span> &#123;<br>    <span class="hljs-string">&quot;term&quot;</span><span class="hljs-symbol">:</span> &#123;<br>      <span class="hljs-string">&quot;ip_addr&quot;</span><span class="hljs-symbol">:</span> <span class="hljs-string">&quot;192.168.0.0/16&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>上面的命令显示的结果为：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ada">&#123;<br>  <span class="hljs-string">&quot;took&quot;</span> : 0,<br>  <span class="hljs-string">&quot;timed_out&quot;</span> : <span class="hljs-type">false</span>,<br>  <span class="hljs-string">&quot;_shards&quot;</span> : &#123;<br>    <span class="hljs-string">&quot;total&quot;</span> : 1,<br>    <span class="hljs-string">&quot;successful&quot;</span> : 1,<br>    <span class="hljs-string">&quot;skipped&quot;</span> : 0,<br>    <span class="hljs-string">&quot;failed&quot;</span> : 0<br>  &#125;,<br>  <span class="hljs-string">&quot;hits&quot;</span> : &#123;<br>    <span class="hljs-string">&quot;total&quot;</span> : &#123;<br>      <span class="hljs-string">&quot;value&quot;</span> : 1,<br>      <span class="hljs-string">&quot;relation&quot;</span> : &quot;<span class="hljs-type">eq</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &quot;</span>max_score<span class="hljs-string">&quot; : 1.0,</span><br><span class="hljs-string">    &quot;</span>hits<span class="hljs-string">&quot; : [</span><br><span class="hljs-string">      &#123;</span><br><span class="hljs-string">        &quot;</span>_index<span class="hljs-string">&quot; : &quot;</span>my-index<span class="hljs-string">&quot;,</span><br><span class="hljs-string">        &quot;</span>_type<span class="hljs-string">&quot; : &quot;</span>_doc<span class="hljs-string">&quot;,</span><br><span class="hljs-string">        &quot;</span>_id<span class="hljs-string">&quot; : &quot;</span><span class="hljs-number">1</span><span class="hljs-string">&quot;,</span><br><span class="hljs-string">        &quot;</span>_score<span class="hljs-string">&quot; : 1.0,</span><br><span class="hljs-string">        &quot;</span>_source<span class="hljs-string">&quot; : &#123;</span><br><span class="hljs-string">          &quot;</span>ip_addr<span class="hljs-string">&quot; : &quot;</span><span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">    ]</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p><strong>这次，显然我们搜索到我们需要的文档了，这是因为 192.168.1.1 是属于 IP 地址范围 192.168.0.0&#x2F;16 的。我们可以通过这样的方法搜索属于一个 IP 范围的日志文件供我们查询。</strong></p><h2 id="一些补充的命令"><a href="#一些补充的命令" class="headerlink" title="一些补充的命令"></a>一些补充的命令</h2><p><strong>token_count用于统计字符串分词后的词项个数。</strong></p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">PUT <span class="hljs-keyword">blog</span><br>&#123;<br>  <span class="hljs-string">&quot;mappings&quot;</span><span class="hljs-operator">:</span> &#123;<br>    <span class="hljs-string">&quot;properties&quot;</span><span class="hljs-operator">:</span> &#123;<br>      <span class="hljs-string">&quot;title&quot;</span><span class="hljs-operator">:</span>&#123;<br>        <span class="hljs-string">&quot;type&quot;</span><span class="hljs-operator">:</span> <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;fields&quot;</span><span class="hljs-operator">:</span> &#123;<br>          <span class="hljs-string">&quot;length&quot;</span><span class="hljs-operator">:</span>&#123;<br>            <span class="hljs-string">&quot;type&quot;</span><span class="hljs-operator">:</span><span class="hljs-string">&quot;token_count&quot;</span>,<br>            <span class="hljs-string">&quot;analyzer&quot;</span><span class="hljs-operator">:</span><span class="hljs-string">&quot;standard&quot;</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>相当于新增了 title.length 字段用来统计分词后词项的个数。</strong></p><p><strong>添加文档：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">PUT blog<span class="hljs-regexp">/_doc/</span><span class="hljs-number">1</span><br>&#123;<br>  <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;zhang san&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以通过 token_count 去查询：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> blog/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;term&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;title.length&quot;</span>: 2<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建索引</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">PUT index_name</span><br></code></pre></td></tr></table></figure><p><strong>更新_id为1的文档：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">PUT user<span class="hljs-regexp">/_doc/</span><span class="hljs-number">1</span><br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-string">&quot;loginCount&quot;</span>: <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>新建文档：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">POST test_index2/_doc<br>&#123;<br>  <span class="hljs-string">&quot;user&quot;</span>:&#123;<br>      <span class="hljs-string">&quot;first&quot;</span>:<span class="hljs-string">&quot;Zhang121&quot;</span>,<br>      <span class="hljs-string">&quot;last&quot;</span>:<span class="hljs-string">&quot;san1121&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>查询索引下的文档</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> index_name/_search<br></code></pre></td></tr></table></figure><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p><a href="https://blog.csdn.net/weixin_43859729/article/details/108134329#:~:text=%E5%9C%A8Elasticsearch%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5,%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6%E5%AE%9A%E4%B9%89%E8%B7%9D%E7%A6%BB%E3%80%82">原文</a></p><p><strong>我们使用关系型数据库时，模糊查询使用的就是like，加上通配符</strong></p><p><strong>通配符</strong>    **    说明**<br><strong>%</strong>    **             包含0个或多个字符的任意字符**<br><strong>_（下划线）任意1个字符</strong><br><strong>那ElasticSearch中模糊查询是什么呢，我们知道term是精确查询，有的地方说match是模糊，有的地方说wildcard是模糊，甚至还有fuzzy等，字面意思就是‘模糊’的语句，他们有什么区别呢</strong></p><p><strong>ElasticSearch中的模糊查询</strong><br><strong>举个例子，我们有个人物名单索引listofhistoricalfigures</strong><br><strong>里面name字段内容如下</strong></p><p><strong>张三</strong><br><strong>张三丰</strong><br><strong>张飞</strong><br><strong>三德子</strong><br><strong>张二丰</strong><br><strong>孙权</strong><br><strong>马三丰</strong><br><strong>结构是下面这样，text支持分词查询，keyword支持精确查询</strong><br><strong>详情可参考这一篇 ElasticSearch 使用term时.keyword加不加的区别</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>           <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>           <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>             <span class="hljs-attr">&quot;keyword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>               <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>             <span class="hljs-punctuation">&#125;</span><br>           <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>match 分词匹配检索</strong><br><strong>match</strong><br><strong>英 [mætʃ] 美 [mætʃ]</strong><br><strong>n. 火柴;比赛;竞赛;敌手;旗鼓相当的人</strong><br><strong>v.般配;相配;相同;相似;相一致;找相称(或相关)的人(或物);配对</strong></p><p><strong>match字面意思是 相似;相一致;找相称(或相关)的人(或物);配对</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">GET listofhistoricalfigures/_<span class="hljs-built_in">search</span> <br>&#x27;&#123;<br>    <span class="hljs-string">&quot;query&quot;</span><span class="hljs-symbol">:</span> &#123;<br>        <span class="hljs-string">&quot;match&quot;</span><span class="hljs-symbol">:</span> &#123;<br>            <span class="hljs-string">&quot;name&quot;</span><span class="hljs-symbol">:</span> <span class="hljs-string">&quot;张三&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我们使用match和默认分词器，会把张三进行分词，分成张、三、张三进行检索</strong><br><strong>会匹配到的结果有</strong></p><p><strong>张三</strong><br><strong>张三丰</strong><br><strong>张飞</strong><br><strong>三德子</strong><br><strong>张二丰</strong><br><strong>马三丰</strong><br><strong>wildcard 通配符检索</strong><br><strong>wildcard</strong><br><strong>美 [ˈwaɪldˌkɑrd]</strong><br><strong>n.未知数;未知因素;(给予没有正常参赛资格的选手准其参加比赛的)“外卡”;“外卡”选手;</strong><br><strong>(用于代替任何字符或字符串的)通配符</strong></p><p><strong>wildcard字面意思是 通配符</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">GET listofhistoricalfigures/_<span class="hljs-built_in">search</span> <br>&#x27;&#123;<br>    <span class="hljs-string">&quot;query&quot;</span><span class="hljs-symbol">:</span> &#123;<br>        <span class="hljs-string">&quot;wildcard&quot;</span><span class="hljs-symbol">:</span> &#123;<br>            <span class="hljs-string">&quot;name.keyword&quot;</span><span class="hljs-symbol">:</span> <span class="hljs-string">&quot;张三*&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>表示匹配0到多个任意字符</strong><br><strong>加.keyword是要匹配完整的词</strong><br><strong>会匹配到的结果有</strong></p><p><strong>张三</strong><br><strong>张三丰</strong><br><strong>1</strong><br><strong>2</strong><br><strong>fuzzy 模糊&#x2F;纠错检索</strong><br><strong>fuzzy</strong><br><strong>英 [ˈfʌzi] 美 [ˈfʌzi]</strong><br><strong>adj. 覆有绒毛的;毛茸茸的;紧鬈的;拳曲的;(形状或声音)模糊不清的</strong></p><p><strong>fuzzy字面意思是 模糊</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">GET listofhistoricalfigures/_<span class="hljs-built_in">search</span> <br>&#x27;&#123;<br>    <span class="hljs-string">&quot;query&quot;</span><span class="hljs-symbol">:</span> &#123;<br>        <span class="hljs-string">&quot;fuzzy&quot;</span><span class="hljs-symbol">:</span> &#123;<br>            <span class="hljs-string">&quot;name.keyword&quot;</span><span class="hljs-symbol">:</span> <span class="hljs-string">&quot;张三&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用fuzzy就行百度一样，你输入个“邓子棋”，也能把“邓紫棋”查出来，有一定的纠错能力</strong><br><strong>加.keyword是要匹配完整的词</strong><br><strong>会匹配到的结果有</strong></p><p><strong>张三</strong><br><strong>张三丰</strong><br><strong>张飞</strong><br><strong>张二丰</strong><br><strong>马三丰</strong><br><strong>结论</strong><br><strong>1.match 分词匹配检索，可以对查询条件分词，查到更多匹配的内容，结合不同的分词器，可以得到不同的效果</strong></p><p><strong>2.wildcard 通配符检索功能就像传统的SQL like一样，如果数据在es，你又想得到传统的“模糊查询”结构时，用wildcard</strong></p><p><strong>3.fuzzy 纠错检索，让输入条件有容错</strong></p><h2 id="ES查询语法"><a href="#ES查询语法" class="headerlink" title="ES查询语法"></a>ES查询语法</h2><p><strong>这部分指的是ES的“开发工具”那块的语法。</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ada">GET /cars/transactions/_search<br>&#123;<br>    <span class="hljs-string">&quot;query&quot;</span> : &#123;<br>        <span class="hljs-string">&quot;match&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;make&quot;</span> : &quot;<span class="hljs-type">ford</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &quot;</span>aggs<span class="hljs-string">&quot; : &#123;</span><br><span class="hljs-string">        &quot;</span>colors<span class="hljs-string">&quot; : &#123;</span><br><span class="hljs-string">            &quot;</span>terms<span class="hljs-string">&quot; : &#123;</span><br><span class="hljs-string">              &quot;</span>field<span class="hljs-string">&quot; : &quot;</span>color<span class="hljs-string">&quot;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>可以在query里指定查询条件</strong></p><h2 id="kibana的时区设置"><a href="#kibana的时区设置" class="headerlink" title="kibana的时区设置"></a>kibana的时区设置</h2><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h445dz1qzuj325w11eh66.jpg" alt="WX20220712-145321@2x.png"></p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h445erz2ecj31f408ggo7.jpg" alt="WX20220712-145331@2x.png"></p><p><strong>之前ES没有设置用户登录，访问</strong><a href="http://127.0.0.1:9200/">http://127.0.0.1:9200</a>就会直接返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;40414b8f8139&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;cluster_name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;docker-cluster&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;cluster_uuid&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;e9pDFxOIQ2yhNvwJB9153A&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;number&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;7.6.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build_flavor&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build_type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;docker&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build_hash&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;7f634e9f44834fbc12724506cc1da681b0c3b1e3&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build_date&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2020-02-06T00:09:00.449973Z&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build_snapshot&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;lucene_version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;8.4.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;minimum_wire_compatibility_version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;6.8.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;minimum_index_compatibility_version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;6.0.0-beta1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;tagline&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;You Know, for Search&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>不指定用户名和密码也可以直接往ES写数据，不太安全。可以在需要的时候设置用户名和密码。</strong></p><p><strong>参考文档</strong></p><p><a href="https://segmentfault.com/a/1190000038323706">ElasticSearch 动态映射和静态映射，以及四种字段类型</a></p><p><a href="https://blog.csdn.net/qq_36918149/article/details/104456820#:~:text=Elasticsearch%20%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%8F%AB,BY%60%20%E7%B1%BB%E4%BC%BC%E4%BD%86%E6%9B%B4%E5%BC%BA%E5%A4%A7%E3%80%82&text=%E8%81%9A%E5%90%88%E6%A1%86%E6%9E%B6%E6%9C%89%E5%8A%A9%E4%BA%8E,%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%81%9A%E5%90%88%E5%88%86%E6%9E%90%E8%83%BD%E5%8A%9B%E3%80%82">Elasticsearch聚合分析简介</a></p><p><a href="https://www.cnblogs.com/leeSmall/p/9215909.html">elasticsearch系列六：聚合分析（聚合分析简介、指标聚合、桶聚合） </a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse入门</title>
    <link href="/2022/07/16/clickhouse%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/16/clickhouse%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="和其他数据库相比"><a href="#和其他数据库相比" class="headerlink" title="和其他数据库相比"></a>和其他数据库相比</h2><p><strong>它也是一种关系型数据库。</strong></p><p><strong>传统的关系型数据库是</strong><em>行式存储</em>，而clickHouse是<strong>列式存储</strong>。</p><p><strong>关于clickHouse和mysql的对比，但空间唯独上可以抽象为行（横轴）列（纵轴），行式存储位于一行的数据总是被物理存储在一起。</strong></p><p><strong>列式存储</strong>的优势：更适合OLAP（是仓库型数据库，<strong>主要是读取数据，做复杂数据分析，侧重技术决策支持</strong>，提供直观简单的结果。和OLAP相对的是OLTP，是传统的关系型数据库，主要操作增删改查，<strong>强调事务一致性</strong>）</p><p><strong>缺点：</strong></p><ol><li><strong>不支持事务</strong>。不要把clickHouse直接当做像mysql这样的关系型数据库。clickHouse本身的定位就是用于联机分析(OLAP)的列式数据库管理系统(DBMS)。</li><li><strong>关于实时性</strong>。缺少高频率，低延迟的修改或删除已存在数据的能力。仅能用于批量删除或修改数据，但这符合 <a href="https://gdpr-info.eu/">GDPR</a>。就像elasticsearch搜索引擎，它也是近实时的。如果对实时性有钱强烈要求的，应该避免使用clickHouse，或者通过业务上的设计，合理避免实时性问题。</li><li><strong>稀疏索引使得ClickHouse不适合通过其键检索单行的点查询。</strong></li></ol><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p><strong>使用 docker</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --name clickhouse-server --ulimit nofile=<span class="hljs-number">262144</span>:<span class="hljs-number">262144</span> -p <span class="hljs-number">9000</span>:<span class="hljs-number">9000</span> yandex/clickhouse-server:<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>或者读取自定义配置运行：</strong></p><p><strong>注意，需要在$PWD&#x2F;etc&#x2F;clickhouse-server&#x2F;config.xml指定时区</strong> <code>&lt;timezone&gt;Asia/Shanghai&lt;/timezone&gt;</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -d --name some-clickhouse-server --ulimit nofile=<span class="hljs-number">262144</span>:<span class="hljs-number">262144</span> -p <span class="hljs-number">8123</span>:<span class="hljs-number">8123</span> -p <span class="hljs-number">9000</span>:<span class="hljs-number">9000</span> --volume=<span class="hljs-variable">$PWD</span><span class="hljs-regexp">/some_clickhouse_database:/</span>var<span class="hljs-regexp">/lib/</span>clickhouse --volume=<span class="hljs-variable">$PWD</span><span class="hljs-regexp">/etc/</span>clickhouse-server:<span class="hljs-regexp">/etc/</span>clickhouse-server yandex/clickhouse-server:latest<br></code></pre></td></tr></table></figure><blockquote><p><strong>ps：对于clickhouse-server:1.1（但是实际上运行时用的不是1.1），我打开了<listen_host>::</listen_host>，这个配置是限制来源主机的请求，<listen_host>::</listen_host>的意思是允许IP4和IP6源主机远程访问。具体可以参见config.xml的注释。</strong></p></blockquote><p><strong>启动客户端：</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">docker run -it --rm --link some-clickhouse-<span class="hljs-keyword">server</span>:clickhouse-<span class="hljs-keyword">server</span> yandex/clickhouse-<span class="hljs-keyword">client</span> --host clickhouse-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>补充的一些命令：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> db_1;<br><span class="hljs-keyword">show</span> databases;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test02( id UInt16,col1 String,col2 String,create_date <span class="hljs-type">date</span> ) ENGINE = MergeTree(create_date, (id), <span class="hljs-number">8192</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test02 <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;tank&#x27;</span>,<span class="hljs-string">&#x27;tank&#x27;</span>,  <span class="hljs-string">&#x27;2021-08-19 14:21:30&#x27;</span>);  <br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker exec -i -t xxx <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong>与常用的SQL一致，需要注意的是创建表的时候需要指定Engine。</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> (<span class="hljs-keyword">temporary</span>) <span class="hljs-keyword">table</span> (<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>) test.m1 (<br> id UInt16<br>,<span class="hljs-type">name</span> String<br>) ENGINE = Memory<br>;<br></code></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>整型：UInt8,UInt16,UInt32,UInt64,Int8,Int16,Int32,Int64</strong></p><p><strong>枚举类型：Enum8,Enum16，存储为Int8或Int16的一组枚举字符串值。Enum8（’hello’&#x3D; 1，’world’&#x3D; 2）， 这个数据类型有两个值  ‘hello’和’world’。</strong></p><p><strong>字符串(String、FixedString 和 UUID，FixedString 固定了长度，UUID为32位</strong></p><p><strong>数组类型：Array(T)表示T类型的数组</strong></p><p><strong>元组：Tuple，由多个元素组成，允许不同类型</strong></p><p><strong>嵌套（Nested(Name1 Type1, Name2 Type2, …)），MergeTree 引擎中不支持存储这样的列。不能对整个嵌套数据结构执行 SELECT。只能明确列出属于它一部分列</strong></p><p><strong>定点数 Decimal32、Decimal64 和Decimal128，Decimal(P, S)：P代表精度，决定总位数（整数部分+小数部分）</strong></p><p><strong>缺失值（Nullable(TypeName)），</strong><code>Nullable(Int8)</code> 类型的列可以存储 <code>Int8</code> 类型值，而没有值的行将存储 <code>NULL</code>。使用 Nullable 几乎总是对性能产生负面影响。例子：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_null(x <span class="hljs-type">Int8</span>, y Nullable(<span class="hljs-type">Int8</span>)) ENGINE TinyLog<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_null <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-keyword">NULL</span>)<br></code></pre></td></tr></table></figure><h3 id="物化列"><a href="#物化列" class="headerlink" title="物化列"></a>物化列</h3><p><strong>指定 MATERIALIZED 表达式，即将一个列作为</strong> <code>物化列</code>处理了，这意味着这个列的值不能从 <code>insert</code> 语句获取，只能是自己计算出来的。同时，物化列也不会出现在 <code>select *</code> 的结果中：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> test.m2;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.m2 (<br> a <span class="hljs-keyword">MATERIALIZED</span> (b+<span class="hljs-number">1</span>)<br>,b UInt16<br>) ENGINE = Memory;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.m2 (b) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>);<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.m2;<br><span class="hljs-keyword">select</span> a, b <span class="hljs-keyword">from</span> test.m2; <span class="hljs-comment">--这个可以查出来</span><br></code></pre></td></tr></table></figure><h3 id="表达式列"><a href="#表达式列" class="headerlink" title="表达式列"></a>表达式列</h3><p><strong>ALIAS 表达式列某方面跟物化列相同，就是它的值不能从 insert 语句获取。不同的是， 物化列 是会真正保存数据（这样查询时不需要再计算），</strong></p><p><strong>而表达式列不会保存数据（这样查询时总是需要计算），只是在查询时返回表达式的结果。</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test.m3 (a <span class="hljs-keyword">ALIAS</span> (b+<span class="hljs-number">1</span>), b UInt16) ENGINE = Memory;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test.m3(b) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>);<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test.m3;<br><span class="hljs-keyword">select</span> a, b <span class="hljs-keyword">from</span> test.m3;<br></code></pre></td></tr></table></figure><h2 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h2><h3 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h3><p><strong>Atomic</strong>：它支持非阻塞 DROP 和 RENAME TABLE 查询以及原子 EXCHANGE TABLES t1 AND t2 查询。</p><p><strong>Mysql</strong> MySQL引擎用于将远程的MySQL服务器中的表映射到ClickHouse中，并允许您对表进行 <code>INSERT</code>和 <code>SELECT</code>查询，以方便您在ClickHouse与MySQL之间进行数据交换。创建数据库时需要指定原始Mysql数据源。</p><p><code>MySQL</code>数据库引擎会将对其的查询转换为MySQL语法并发送到MySQL服务器中，因此您可以执行诸如 <code>SHOW TABLES</code>或 <code>SHOW CREATE TABLE</code>之类的操作。</p><p><strong>示例：</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> [<span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] db_name [<span class="hljs-keyword">ON</span> <span class="hljs-keyword">CLUSTER</span> <span class="hljs-keyword">cluster</span>]<br>ENGINE = MySQL(<span class="hljs-string">&#x27;host:port&#x27;</span>, [<span class="hljs-string">&#x27;database&#x27;</span> | <span class="hljs-keyword">database</span>], <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>)<br><br>MySQL数据库引擎参数<br>host:port — 链接的MySQL地址。<br><span class="hljs-keyword">database</span> — 链接的MySQL数据库。<br><span class="hljs-keyword">user</span> — 链接的MySQL用户。<br><span class="hljs-keyword">password</span> — 链接的MySQL用户密码。<br></code></pre></td></tr></table></figure><p><strong>Lazy</strong></p><p><strong>在距最近一次访问间隔</strong> <code>expiration_time_in_seconds</code>时间段内，将表保存在内存中，仅适用于 Log引擎表</p><p><em>由于针对这类表的访问间隔较长，对保存大量小的 <em>Log引擎表进行了优化。</em></em></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CREATE DATABASE testlazy ENGINE <span class="hljs-operator">=</span> Lazy(expiration_time_in_seconds)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="表引擎"><a href="#表引擎" class="headerlink" title="表引擎"></a>表引擎</h3><h4 id="Log系列"><a href="#Log系列" class="headerlink" title="Log系列"></a>Log系列</h4><p><strong>主要用于快速写入小表（1百万行左右），然后全读出来的场景。当需要快速写入和整体读的时候，最有效。</strong></p><p><strong>Log系列表引擎的共性是：</strong></p><ol><li><strong>数据顺序append写到磁盘</strong></li><li><strong>不支持delete和update</strong></li><li><strong>不支持索引</strong></li><li><strong>不支持原子写</strong></li><li><strong>Insert的操作会阻塞select操作</strong></li></ol><p><strong>主要的特点是：</strong></p><ol><li><strong>数据存储磁盘</strong></li><li><strong>写入时追加数据到文件末尾</strong></li><li><strong>不支持突变的操作</strong></li><li><strong>不支持索引，所以select效率比较低</strong></li><li><strong>非原子性写入数据</strong></li></ol><p><strong>其中的tinylog一般用于测试，存储少量数据的小表：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_tinylog(<br>id Int64,<br>  <span class="hljs-type">name</span> String<br>)<br>ENGINE = TinyLog;<br></code></pre></td></tr></table></figure><h4 id="Integration系列"><a href="#Integration系列" class="headerlink" title="Integration系列"></a>Integration系列</h4><p><strong>该系统表引擎主要用于对接外部数据源</strong></p><p><strong>Kafka：可以将kafka Topic中的数据直接导入到clickhouse</strong></p><p><strong>Mysql：将Mysql作为存储引擎，直接可以在Clickhouse中对mysql表进行select等操作</strong></p><p><strong>HDFS：直接读取HDFS的特定格式的数据文件</strong></p><h4 id="Specal系列"><a href="#Specal系列" class="headerlink" title="Specal系列"></a>Specal系列</h4><p><strong>Memory引擎，数据以未压缩的原始形式存在内存中，服务器重启数据就会消失。读写操作不会相互阻塞，不支持索引。简单查询下有非常高的性能表现。一般仅用来测试，适用于非常高的性能，同事数据量不大的场景。</strong></p><p><strong>Merge引擎本身不存储数据，但同时从任意多个其他的表中读取数据。读取时自动并行，支持写入。</strong></p><p><strong>Distributed引擎，本身不存储数据，但是可以从多个服务器进行分布式查询。读是自动并行的</strong></p><p><strong>关于整合：</strong></p><ol><li><strong>Merge引擎：在同一个服务器上的，多个相同结构的物理表，可以被整合成一张大的逻辑表，这张表的数据包含了物理表中的所有数据</strong></li><li><strong>Distributed：在不同的server上，多个相同结构的物理表，可以被整合成一张大的逻辑表，这张逻辑表的数据，就是包含了物理表的所有数据</strong></li></ol><h4 id="MergeTree"><a href="#MergeTree" class="headerlink" title="MergeTree"></a>MergeTree</h4><p><strong>绝大数场景会使用MergeTree</strong></p><p><strong>只有MergeTree系列的表引擎才支持</strong><a href="https://so.csdn.net/so/search?q=%E4%B8%BB%E9%94%AE&spm=1001.2101.3001.7020">主键</a>索引，数据分区，数据副本，数据采样这些特性，只有此系列的表引擎才支持ALTER操作。</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>**click house支持聚合操作，有一些标准聚合函数:**8</p><p><strong>count，min，max等</strong></p><p><strong>ClickHouse 特有的聚合函数:</strong></p><p><strong>anyHeavy，anyLast，argMin等</strong></p><p><strong>参考</strong><a href="https://clickhouse.com/docs/zh/sql-reference/aggregate-functions/parametric-functions">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>prometheus exporter的总结</title>
    <link href="/2022/05/26/prometheus%20exporter%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/26/prometheus%20exporter%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Go-Application"><a href="#Go-Application" class="headerlink" title="Go Application"></a>Go Application</h2><p>例子来源于<a href="https://prometheus.io/docs/guides/go-application/%EF%BC%8C%E7%94%A8%E5%88%B0%E4%BA%86%E5%AE%98%E6%96%B9client%EF%BC%9Ahttps://github.com/prometheus/client_golang">https://prometheus.io/docs/guides/go-application/，用到了官方client：https://github.com/prometheus/client_golang</a></p><p>prometheus有一个官方Go客户端库，可以用它来检测Go程序。下面这个例子中，会创建一个go应用，该应用将指标数据通过HTTP传送给prometheus。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;net/http&quot;</span><br><br>        <span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        http.Handle(<span class="hljs-string">&quot;/metrics&quot;</span>, promhttp.Handler())<br>        http.ListenAndServe(<span class="hljs-string">&quot;:2112&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>增加自定义指标myapp_processed_ops_total：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;net/http&quot;</span><br>        <span class="hljs-string">&quot;time&quot;</span><br><br>        <span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus&quot;</span><br>        <span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus/promauto&quot;</span><br>        <span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recordMetrics</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                <span class="hljs-keyword">for</span> &#123;<br>                        opsProcessed.Inc()<br>                        time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>                &#125;<br>        &#125;()<br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>        opsProcessed = promauto.NewCounter(prometheus.CounterOpts&#123;<br>                Name: <span class="hljs-string">&quot;myapp_processed_ops_total&quot;</span>,<br>                Help: <span class="hljs-string">&quot;The total number of processed events&quot;</span>,<br>               <span class="hljs-comment">// ConstLabels: prometheus.Labels(map[string]string&#123;&quot;date&quot;: &quot;Thursday&quot;&#125;),</span><br>        &#125;)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        recordMetrics()<br><br>        http.Handle(<span class="hljs-string">&quot;/metrics&quot;</span>, promhttp.Handler())<br>        http.ListenAndServe(<span class="hljs-string">&quot;:2112&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="我写的exporter"><a href="#我写的exporter" class="headerlink" title="我写的exporter"></a>我写的exporter</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br> <span class="hljs-string">&quot;fmt&quot;</span><br> <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> http.HandleFunc(<span class="hljs-string">&quot;/metrics&quot;</span>, HelloServer)<br> http.ListenAndServe(<span class="hljs-string">&quot;:7777&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> t = <span class="hljs-string">`# HELP myapp_processed_ops_total1 The total number of processed events</span><br><span class="hljs-string"># TYPE myapp_processed_ops_total1 counter</span><br><span class="hljs-string">myapp_processed_ops_total1&#123;date=&quot;Thursday&quot;&#125; 1622`</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HelloServer</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br> fmt.Fprintf(w, t)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个demo的metrics数据可以被prometheus成功获取。</p><p>似乎只要实现metrics，返回结构化的数据就可以了。</p><p>PS：返回数据</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h2lxrjsnwwj31iu0oadmi.jpg" alt="WX20220526-173011@2x.png"></p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h2lxqws4xxj31ko0q6dll.jpg" alt="WX20220526-172920@2x.png"></p><h2 id="exporter规范"><a href="#exporter规范" class="headerlink" title="exporter规范"></a>exporter规范</h2><p>一个 Prometheus exporter 应该提供以下 API：</p><ol><li>Metrics API：返回需要被暴露的指标(metrics)数据，格式可以是纯文本格式或者是 protobuf。</li><li>Health Check API：检查 exporter 的健康状态，应该返回 HTTP 200 表示正常，非 200 表示异常。</li><li>Metadata API（可选）：返回关于 exporter 的元数据，例如 exporter 版本、数据源等信息。</li></ol><p>其中，Metrics API 是一个必须提供的 API，它应该以 HTTP 接口的形式暴露指标数据，供 Prometheus 采集器进行数据采集和存储。Health Check API 是一个可选的 API，用于检测 exporter 的健康状况，可以让用户知道 exporter 是否正常工作。Metadata API 也是一个可选的 API，提供关于 exporter 的元数据信息，便于用户了解 exporter 的基本情况。</p><p><strong>除了上述三个标准API外，Prometheus exporter并没有其他固定的API要求。但是，Exporter可以提供其他自定义的API，以便用户可以通过这些API获取更多的监控指标数据。</strong></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>prometheus入门</title>
    <link href="/2022/05/26/prometheus%E5%85%A5%E9%97%A8/"/>
    <url>/2022/05/26/prometheus%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">prometheus --config.<span class="hljs-attribute">file</span>=prometheus.yml<br></code></pre></td></tr></table></figure><p>可以在 <a href="http://localhost:9090/metrics">http://localhost:9090/metrics</a> 查看prometheus的指标</p><p><a href="http://localhost:9090/">http://localhost:9090</a> 查看prometheus的状态</p><h2 id="在浏览器中查询指标"><a href="#在浏览器中查询指标" class="headerlink" title="在浏览器中查询指标"></a>在浏览器中查询指标</h2><p>在<a href="http://localhost:9090/metrics">http://localhost:9090/metrics</a>中操作</p><h3 id="选择Table"><a href="#选择Table" class="headerlink" title="选择Table"></a>选择Table</h3><p>选择Table，输入查询条件，可以查看<a href="http://localhost:9090/metrics">http://localhost:9090/metrics</a>返回的数据（当然也可以查看这个接口之外的数据，这部分没介绍暂时？？？？？？），查询条件可以为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">promhttp_metric_handler_requests_total<br>promhttp_metric_handler_requests_total&#123;code=<span class="hljs-string">&quot;200&quot;</span>&#125;<br><span class="hljs-function"><span class="hljs-title">count</span><span class="hljs-params">(promhttp_metric_handler_requests_total)</span></span><br></code></pre></td></tr></table></figure><p>关于查询条件的编写，可以参考<a href="https://prometheus.io/docs/prometheus/latest/querying/basics/">querying&#x2F;basics</a></p><h3 id="选择Grafana"><a href="#选择Grafana" class="headerlink" title="选择Grafana"></a>选择Grafana</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">rate</span><span class="hljs-params">(promhttp_metric_handler_requests_total&#123;code=<span class="hljs-string">&quot;200&quot;</span>&#125;[<span class="hljs-number">1</span>m])</span></span><br></code></pre></td></tr></table></figure><p>可以看到每秒返回状态码 200 的 HTTP 请求率（过去一分钟内每秒返回状态码 200 的 HTTP 请求率（以秒为单位））</p><h2 id="原理相关"><a href="#原理相关" class="headerlink" title="原理相关"></a>原理相关</h2><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h2lrcor0vpj31j80qkwmb.jpg" alt="WX20220526-134751@2x.png"></p><h3 id="prometheus如何获取数据"><a href="#prometheus如何获取数据" class="headerlink" title="prometheus如何获取数据"></a>prometheus如何获取数据</h3><p>通过Pull的方式或者Push</p><p>Pull：通过exporter暴露的接口，prometheus定期调用该接口<strong>Pull</strong>数据</p><p>Push：可以将数据<strong>Push</strong>到Push Gateway，prometheus再通过<strong>Pull</strong>的方式从Push Gateway获取数据。可以把Push Gateway理解为一种特殊的exporter。</p><h3 id="prometheus的工作流程"><a href="#prometheus的工作流程" class="headerlink" title="prometheus的工作流程"></a>prometheus的工作流程</h3><ol><li><p>Prometheus server 定期从静态配置的主机或服务发现的 targets 拉取数据（zookeeper，consul，DNS SRV Lookup等方式）</p></li><li><p>当新拉取的数据大于配置内存缓存区的时候，Prometheus会将数据持久化到磁盘，也可以远程持久化到云端。</p></li><li><p>Prometheus通过PromQL、API、Console和其他可视化组件如Grafana、Promdash展示数据。</p></li><li><p>Prometheus 可以配置rules，然后定时查询数据，当条件触发的时候，会将告警推送到配置的Alertmanager。</p></li><li><p>Alertmanager收到告警的时候，会根据配置，聚合，去重，降噪，最后发出警告。</p></li></ol><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>prometheus采集的数据需要为如下的格式，即键值对</p><p>key{metadata}value （metadata也可以称为labels）</p><p>比如<code>node_disk_reads_completed_total&#123;device=&quot;disk0&quot;, key2=&quot;2&quot;&#125; 3.0556147e+07</code></p><blockquote><p>可以看出，普罗米修斯的指标包括以下几个部分组成：</p><p><strong>名称（Name）：</strong> 指标的名称是一个字符串，用于唯一标识该指标。</p><p><strong>标签（Labels）：</strong> 标签是用于对指标进行分类和标记的键值对。</p><p><strong>值（Value）：</strong> 指标的值是一个浮点数，表示监控数据的具体数值。</p><p><strong>指标类型（Type）：</strong> 指标类型表示指标的性质</p><p><strong>帮助文本（Help）：</strong> 帮助文本是对指标的描述信息，用于帮助用户理解该指标的含义和用途。帮助文本通常提供了更详细的描述和解释。例如：<code>cpu_usage&#123;instance=&quot;web_server_1&quot;, cpu=&quot;cpu0&quot;&#125;</code> 对应的帮助文本可以是 “CPU使用率（0到1之间）”。</p></blockquote><h4 id="指标类型"><a href="#指标类型" class="headerlink" title="指标类型"></a>指标类型</h4><p><strong>Counter(计数器)</strong></p><p><strong>Gauges</strong>：处理随时间变化而变化的一些指标，比如内存变化。</p><p><strong>Histogram(直方图</strong>) 可以看<a href="https://prometheus.io/docs/tutorials/understanding_metric_types/">官方</a>给的例子，推荐使用</p><p><strong>Summary(摘要)</strong></p><p><strong>Gauges</strong>：记录某个时刻对应的数值，类似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">myapp_data&#123;time=&quot;2023-06-07 11:35:57&quot;&#125; 0.6046602879796196<br>myapp_data&#123;time=&quot;2023-06-07 11:36:57&quot;&#125; 0.9405090880450124<br></code></pre></td></tr></table></figure><p>可以根据时间time绘图，横坐标为时间，纵坐标为时间对应的指标值</p><h4 id="PromQL"><a href="#PromQL" class="headerlink" title="PromQL"></a>PromQL</h4><p>这是prometheus自己内置的SQL查询语言</p><p>PromQL会处理两种向量：</p><p>即时向量：当前时间某个指标的数据向量。</p><p>时间范围向量：某个时间段内，某个指标的数据向量。</p><h4 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h4><p>一般用grafana</p><h2 id="exporter"><a href="#exporter" class="headerlink" title="exporter"></a>exporter</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>exporter是用于采集数据的组件，被安装在采集目标上。</p><p>exporter采集数据后，传递数据给prometheus。主要传递方式是exporter会暴露一个HTTP接口，prometheus通过<strong>Pull</strong>的方式周期性的拉取数据。</p><p>server需要知道各种exporter的api地址且api返回的数据需要是规范化的。只要遵循规范， 可以根据需求开发出各种 exporter (比如专门采集redis数据的exporter需要在被调用的时候采集redis各项数据作为返回值， 同样采集mysql、linux、docker的exporter也是一样的工作原理， 还有其他的各种汇报数据的exporter，例如汇报机器数据的node_exporter，汇报MondogDB信息的 MongoDB_exporter 等等)。</p><p>prometheus的yml配置文件可以指定多个scrape_configs的targets</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="Node-Exporter"><a href="#Node-Exporter" class="headerlink" title="Node Exporter"></a>Node Exporter</h4><p>启动Node Exporter<code>node_exporter</code>，node_exporter在9100</p><p><code>prometheus_node.yml</code>内容如下：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">global</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">scrape_interval</span><span class="hljs-punctuation">:</span> <span class="hljs-string">15s</span><br><br><span class="hljs-attribute">scrape_configs</span><span class="hljs-punctuation">:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">job_name: node</span><br>  <span class="hljs-attribute">static_configs</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">targets: [&#x27;localhost:9100&#x27;]</span><br></code></pre></td></tr></table></figure><p>启动prometheus  <code>prometheus --config.file=./prometheus_node.yml</code></p><p>可以在localhost:9090&#x2F;graph查询到node_exporter的一些指标，比如node_exporter_build_info。node_exporter的指标可以通过<a href="http://localhost:9100/metrics">http://localhost:9100/metrics</a>查看</p><h4 id="mysql-exporter"><a href="#mysql-exporter" class="headerlink" title="mysql exporter"></a>mysql exporter</h4><p>通过<code>mysqld_exporter --config.my-cnf=&quot;mysql_exporter.cnf&quot;</code>启动，启动后的部分日志为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">ts</span>=2022-05-26T06:58:58.408Z <span class="hljs-attribute">caller</span>=mysqld_exporter.go:303 <span class="hljs-attribute">level</span>=info <span class="hljs-attribute">msg</span>=<span class="hljs-string">&quot;Listening on address&quot;</span> <span class="hljs-attribute">address</span>=:9104<br></code></pre></td></tr></table></figure><p>可以看到端口号。</p><p>修改prometheus配置文件，在static_configs添加<code>[&#39;localhost:9104&#39;]</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff">    static_configs:<br><span class="hljs-addition">+      - targets: [&#x27;localhost:9104&#x27;]</span><br></code></pre></td></tr></table></figure><p>重启prometheus</p><h4 id="redis-exporter"><a href="#redis-exporter" class="headerlink" title="redis exporter"></a>redis exporter</h4><p>启动<code>redis_exporter redis/localhost:6379 &amp; -web.listenaddress localhost:9121</code></p><p>修改prometheus配置文件，在static_configs添加<code>[&#39;localhost:9121&#39;]</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff">    static_configs:<br><span class="hljs-addition">+      - targets: [&#x27;localhost:9121&#x27;]</span><br></code></pre></td></tr></table></figure><p>重启prometheus</p><h2 id="grafana"><a href="#grafana" class="headerlink" title="grafana"></a>grafana</h2><p>普罗米修斯默认的页面没有很直观，安装grafana可以看起来更直观。</p><p>启动<code>brew services start grafana</code></p><p>打开 <a href="http://localhost:3000/">http://localhost:3000</a> 即可访问grafana</p><p>可以在<a href="http://localhost:3000/d/UDdpyzz7z/prometheus-2-0-stats?orgId=1&amp;refresh=1m%E7%9C%8B%E5%88%B0prometheus">http://localhost:3000/d/UDdpyzz7z/prometheus-2-0-stats?orgId=1&amp;refresh=1m看到prometheus</a>的整个监控信息</p><p>如果发现grafana一些面板需要插件才可以显示，使用<code>grafana-cli plugins install &lt;plugin&gt;</code>安装插件然后重启grafana查看面板。</p><hr><h2 id="linux部署"><a href="#linux部署" class="headerlink" title="linux部署"></a>linux部署</h2><p>下面的操作基于我的虚拟机，一切都是实际操作</p><p>首先根据<a href="https://jingsam.github.io/2018/10/16/host-in-docker.html">参考</a>查看ifconfig，找到docker0的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255<br>        inet6 fe80::42:8aff:fe25:4455  prefixlen 64  scopeid 0x20&lt;link&gt;<br>        ether 02:42:8a:25:44:55  txqueuelen 0  (Ethernet)<br>        RX packets 78747  bytes 103664790 (98.8 MiB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 103397  bytes 72780700 (69.4 MiB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br></code></pre></td></tr></table></figure><p>记住其IP地址172.17.0.1，下面会用。</p><blockquote><p>因为在Linux下安装Docker的时候，会在宿主机安装一个虚拟网卡<code>docker0</code>，我们可以使用宿主机在<code>docker0</code>上的IP地址来代替<code>localhost</code>。</p><p><strong>但是，在Windows和macOS平台下并没有<code>docker0</code>虚拟网卡，这时候可以使用<code>host.docker.internal</code>这个特殊的DNS名称来解析宿主机IP。</strong></p></blockquote><h3 id="Prometheus部署"><a href="#Prometheus部署" class="headerlink" title="Prometheus部署"></a><strong>Prometheus部署</strong></h3><p>prometheus.yml文件示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span>     <span class="hljs-string">60s</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">60s</span><br><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">prometheus</span><br>    <span class="hljs-attr">static_configs:</span><br>        <span class="hljs-comment">#本地服务器加端口</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;localhost:9090&#x27;</span>]<br>        <span class="hljs-attr">labels:</span><br>          <span class="hljs-attr">instance:</span> <span class="hljs-string">prometheus</span><br></code></pre></td></tr></table></figure><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run  -d \<br>  -p 9090:9090 \<br>  -v $PWD/prometheus.yml:/etc/prometheus/prometheus.yml  \<br>  --name prometheus \<br>  prom/prometheus<br></code></pre></td></tr></table></figure><p>访问 <a href="http://localhost:9090/">http://localhost:9090</a> 即可看到页面。</p><p><img src="/../images/image-20230328154547280.png" alt="image-20230328154547280"></p><h3 id="grafana部署"><a href="#grafana部署" class="headerlink" title="grafana部署"></a><strong>grafana部署</strong></h3><p>新建一个存储grafana数据的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir grafana<br></code></pre></td></tr></table></figure><p>运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>  -p 3000:3000 \<br>  --name=grafana \<br>  -v $PWD/grafana:/var/lib/grafana \<br>  --name grafana \<br>  grafana/grafana<br></code></pre></td></tr></table></figure><p>运行的时候发现服务没有成功启动，根据容器ID查看日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect --format &#x27;&#123;&#123;.LogPath&#125;&#125;&#x27;  00000docker_id0000<br></code></pre></td></tr></table></figure><p>根据输出结果，查看容器日志：</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">&#123;<span class="hljs-comment">&quot;log&quot;</span>:<span class="hljs-comment">&quot;GF_PATHS_DATA=&#x27;/var/lib/grafana&#x27; is not writable.\n&quot;</span>,<span class="hljs-comment">&quot;stream&quot;</span>:<span class="hljs-comment">&quot;stdout&quot;</span>,<span class="hljs-comment">&quot;time&quot;</span>:<span class="hljs-comment">&quot;2023-03-28T07:55:02.969473242Z&quot;</span>&#125;<br>&#123;<span class="hljs-comment">&quot;log&quot;</span>:<span class="hljs-comment">&quot;You may have issues with file permissions, more information here: http://docs.grafana.org/installation/docker/#migrate-to-v51-or-later\n&quot;</span>,<span class="hljs-comment">&quot;stream&quot;</span>:<span class="hljs-comment">&quot;stdout&quot;</span>,<span class="hljs-comment">&quot;time&quot;</span>:<span class="hljs-comment">&quot;2023-03-28T07:55:02.969536557Z&quot;</span>&#125;<br>&#123;<span class="hljs-comment">&quot;log&quot;</span>:<span class="hljs-comment">&quot;mkdir: can&#x27;t create directory &#x27;/var/lib/grafana/plugins&#x27;: Permission denied\n&quot;</span>,<span class="hljs-comment">&quot;stream&quot;</span>:<span class="hljs-comment">&quot;stderr&quot;</span>,<span class="hljs-comment">&quot;time&quot;</span>:<span class="hljs-comment">&quot;2023-03-28T07:55:02.969907168Z&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>根据<a href="https://www.edureka.co/community/83970/cannot-create-directory-grafana-plugins-permission-denied#:~:text=You%20are%20getting%20this%20error,changes%20and%20rerun%20your%20command.">文档</a>，发现报错是因为Grafana 需要具有 472 用户 ID 的用户。 但是还没有为用户&#x2F;组 472 设置权限。执行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> chown -R <span class="hljs-number">472</span>:<span class="hljs-number">472</span> grafana/<br></code></pre></td></tr></table></figure><p>再次重新启动docker，可以成功启动了。访问 <a href="http://localhost:3000/">http://localhost:3000</a> ，默认的用户名和密码都是admin。</p><p>登录后设置数据源，HTTP部分的URL写<a href="http://172.17.0.1:9090，设置完毕后点击页面最下面的save&amp;test测试是否可以顺利连接。">http://172.17.0.1:9090，设置完毕后点击页面最下面的save&amp;test测试是否可以顺利连接。</a></p><h3 id="添加Prometheus-exporter"><a href="#添加Prometheus-exporter" class="headerlink" title="添加Prometheus exporter"></a><strong>添加Prometheus exporter</strong></h3><p>这里选择node-exporter，这个exporter可以导出系统指标。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 9100:9100 \<br>  -v &quot;$PWD/node-exporter/proc:/host/proc:ro&quot; \<br>  -v &quot;$PWD/node-exporter/sys:/host/sys:ro&quot; \<br>  -v &quot;$PWD/node-exporter/:/rootfs:ro&quot; \<br>  --name node-exporter \<br>  prom/node-exporter<br></code></pre></td></tr></table></figure><p>查看验证是否有数据</p><p>修改配置文件prometheus.yml</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs diff">global:<br>  scrape_interval:     60s<br>  evaluation_interval: 60s<br><br>scrape_configs:<br>  - job_name: prometheus<br>    static_configs:<br>        #本地服务器加端口<br>      - targets: [&#x27;localhost:9090&#x27;]<br>        labels:<br>          instance: prometheus<br><br><span class="hljs-addition">+  - job_name: localhost-node-exporter</span><br><span class="hljs-addition">+    static_configs:</span><br><span class="hljs-addition">+      - targets: [&#x27;172.17.0.1:9100&#x27;]</span><br><span class="hljs-addition">+        labels:</span><br><span class="hljs-addition">+          instance: localhost-node-exporter</span><br><span class="hljs-addition">+。   scrape_interval: 30s # 采样频率，普罗米修斯从exporter采集指标的时间间隔</span><br></code></pre></td></tr></table></figure><p>通过<code>docker restart prometheus</code>重启prometheus。</p><p>查看 <a href="http://127.0.0.1:9090/targets">http://127.0.0.1:9090/targets</a> 确认exporter的数据是否上传成功</p><blockquote><p>这里的配置instance: localhost-node-exporter作用的效果是普罗米修斯会给node-exporter的所有指标加上一个label</p><p>比如直接查看<a href="http://127.0.0.1:9100/metrics">http://127.0.0.1:9100/metrics</a> 可以看到这样一个指标</p><p><img src="/../images/image-20230606180151248.png" alt="image-20230606180151248"></p><p>如果在<a href="http://127.0.0.1:9090/graph">http://127.0.0.1:9090/graph</a> 查询这个指标，就会发现这个指标多了一个叫instance的label</p><p><img src="/../images/image-20230606180351293.png" alt="image-20230606180351293"></p><p>这个label的key和value对应配置文件<code>instance: localhost-node-exporter</code>指定的label</p><p>此外普罗米修斯还加了一个job的label，这个label的值就是配置文件<code>job_name: localhost-node-exporter</code>对应的值localhost-node-exporter</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些和高并发相关的概念</title>
    <link href="/2022/03/05/%E4%B8%80%E4%BA%9B%E5%92%8C%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/03/05/%E4%B8%80%E4%BA%9B%E5%92%8C%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TPS"><a href="#1-TPS" class="headerlink" title="1. TPS"></a>1. TPS</h2><p>TPS：Transaction Per Second，也就是服务器每秒的事务处理数量，所谓事务，就是一个客户端向服务器发出请求然后服务器作出响应的过程。</p><p>TPS计算方法：</p><p>可以计算kibana的请求数量，例如服务器处理的请求的host是test1或者test2，可以用如下查询方法：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">nginx<span class="hljs-selector-class">.access</span><span class="hljs-selector-class">.host</span>:(test1<span class="hljs-selector-class">.com</span> OR test2.com)<br></code></pre></td></tr></table></figure><p>然后在grafana（一款用go语言开发的数据可视化工具，用来做数据监控和统计，也可以配置报警）等地方显示出来就可以看出每秒的数值是多少。</p><blockquote><p>TPS 2k出头，在早上10:00</p><p>TPS 2k出头，在晚上9:00</p></blockquote><h2 id="2-QPS"><a href="#2-QPS" class="headerlink" title="2. QPS"></a>2. QPS</h2><p>可以设置QPS报警，当QPS达到指定值时通过nginx配置限流，被限流的用户请求会返回503 code。</p><p>QPS：Query Per Second，也就是服务器每秒的查询数量</p><p>TPS和QPS区别：</p><p>如果一个事务只涉及到了一个查询，且这个接口不会请求其他的接口，那么TPS&#x3D;QPS</p><h2 id="3-PV-Page-View"><a href="#3-PV-Page-View" class="headerlink" title="3. PV(Page View)"></a>3. PV(Page View)</h2><p>页面浏览量，用户每刷新一次就加一次</p><h2 id="4-RT-Response-Time"><a href="#4-RT-Response-Time" class="headerlink" title="4. RT(Response Time)"></a>4. RT(Response Time)</h2><p>客户端发起请求到服务器给出响应的这段时间间隔。</p><p>RT尽量控制在100ms（0.1s)内，实在不行300ms也可以</p><h2 id="5-UV-Unique-Visitor"><a href="#5-UV-Unique-Visitor" class="headerlink" title="5. UV(Unique Visitor)"></a>5. UV(Unique Visitor)</h2><p>独立访客数，需要统计每天访问的所有用户，然后去重</p><p><a href="https://blog.csdn.net/zhangkaixuan456/article/details/108760562">参考1</a></p>]]></content>
    
    
    <categories>
      
      <category>服务端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go语言学习-iota和左移右移的用法</title>
    <link href="/2022/02/15/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-iota%E5%92%8C%E5%B7%A6%E7%A7%BB%E5%8F%B3%E7%A7%BB%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2022/02/15/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-iota%E5%92%8C%E5%B7%A6%E7%A7%BB%E5%8F%B3%E7%A7%BB%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><a href="https://studygolang.com/articles/18059">原文</a></p><p>在go语言中iota比较特殊，是一个被编译器修改的常量，在每一个const关键字出现时被重置为0，然后在下一个const出现之前，每出现一次iota，其所代表的数字就会自动加1</p><p>左移运算符”&lt;&lt;“是双目运算符。<strong>左移n位就是乘以2的n次方</strong>。 其功能把”&lt;&lt;“左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</p><p>右移运算符”&gt;&gt;“是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;“左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。</p><p>注意：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span>(<br> c1 = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//c1=0</span><br> c2 = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//c2=1</span><br> c3 = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//c3=2</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> <span class="hljs-literal">iota</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>  &#123;<br><br> <span class="hljs-keyword">const</span>(<br>  c1 = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//c1=0</span><br>  c2 = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//c2=1</span><br>  c3 = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//c3=2</span><br> )<br><br> fmt.Println(<span class="hljs-string">&quot;c1 = &quot;</span>,c1,<span class="hljs-string">&quot; c2 = &quot;</span>,c2,<span class="hljs-string">&quot; c3 = &quot;</span>,c3,<span class="hljs-string">&quot;\n&quot;</span>)<br><br> <span class="hljs-keyword">const</span>(<br>  a = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">//a = 1</span><br>  b = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">//b = 2</span><br>  c = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">//c = 4</span><br> )<br> fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>,a,<span class="hljs-string">&quot; b = &quot;</span>,b,<span class="hljs-string">&quot; c = &quot;</span>,c,<span class="hljs-string">&quot;\n&quot;</span>)<br><br> <span class="hljs-keyword">const</span>(<br>  v1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//v1 = 0</span><br>  v2        <span class="hljs-comment">//v2 = 1</span><br>  v3        <span class="hljs-comment">//v3 = 2</span><br> )<br> fmt.Println(<span class="hljs-string">&quot;v1 = &quot;</span>,v1,<span class="hljs-string">&quot; v2 = &quot;</span>,v2,<span class="hljs-string">&quot; v3 = &quot;</span>,v3,<span class="hljs-string">&quot;\n&quot;</span>)<br><br> <span class="hljs-keyword">const</span>(<br>  x = <span class="hljs-number">1</span> &lt;&lt;<span class="hljs-literal">iota</span> <span class="hljs-comment">//x = 1</span><br>  y     <span class="hljs-comment">//y = 2</span><br>  z             <span class="hljs-comment">//z = 4</span><br> )<br> fmt.Println(<span class="hljs-string">&quot;x = &quot;</span>,x,<span class="hljs-string">&quot; y = &quot;</span>,y,<span class="hljs-string">&quot; z = &quot;</span>,z)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jsoniter简介</title>
    <link href="/2022/02/07/jsoniter%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/02/07/jsoniter%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要研究这玩意？"><a href="#为什么要研究这玩意？" class="headerlink" title="为什么要研究这玩意？"></a>为什么要研究这玩意？</h2><p>发现的一些代码是这样写的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 通知连接成功</span><br><span class="hljs-keyword">var</span> successReq <span class="hljs-keyword">struct</span> &#123;<br> Type  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;type&quot;`</span><br> Event <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;event&quot;`</span><br> User  <span class="hljs-keyword">struct</span> &#123;<br>  UserID <span class="hljs-type">int64</span> <span class="hljs-string">`json:&quot;user_id&quot;`</span><br> &#125; <span class="hljs-string">`json:&quot;user&quot;`</span><br>&#125;<br>successReq.Type = typeUser<br>successReq.Event = eventConnect<br>successReq.User.UserID = wsConn.User.ID()<br><br>reqContext, err := json2.Marshal(successReq)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br> <span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> im<br><br><span class="hljs-keyword">import</span> (<br> <span class="hljs-string">&quot;encoding/json&quot;</span><br> <span class="hljs-string">&quot;fmt&quot;</span><br> <span class="hljs-string">&quot;net&quot;</span><br> <span class="hljs-string">&quot;sync/atomic&quot;</span><br> <span class="hljs-string">&quot;time&quot;</span><br><br> <span class="hljs-string">&quot;github.com/google/uuid&quot;</span><br> <span class="hljs-string">&quot;github.com/gorilla/websocket&quot;</span><br> jsoniter <span class="hljs-string">&quot;github.com/json-iterator/go&quot;</span><br> <span class="hljs-string">&quot;github.com/json-iterator/go/extra&quot;</span><br> <span class="hljs-string">&quot;go.mongodb.org/mongo-driver/bson&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br> extra.RegisterFuzzyDecoders()<br>&#125;<br><br><span class="hljs-keyword">var</span> json2 = jsoniter.ConfigCompatibleWithStandardLibrary<br></code></pre></td></tr></table></figure><p>可以看到<code>github.com/json-iterator</code>里的包在这里的两个用处：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">extra.RegisterFuzzyDecoders()<br><span class="hljs-keyword">var</span> json2 = jsoniter.ConfigCompatibleWithStandardLibrary<br></code></pre></td></tr></table></figure><h2 id="jsoniter简介"><a href="#jsoniter简介" class="headerlink" title="jsoniter简介"></a>jsoniter简介</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>一个高性能 100% 兼容的“encoding&#x2F;json”替代品</p><p>性能测试结果如下</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0f8pue5vzj30uu0h6gmh.jpg" alt="Xnip2022-03-19_15-40-48.jpg"></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>Replace</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> &quot;encoding/json&quot;<br><span class="hljs-title">json</span>.<span class="hljs-type">Marshal</span>(&amp;<span class="hljs-class"><span class="hljs-keyword">data</span>)</span><br></code></pre></td></tr></table></figure><p>with</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> &quot;github.com/json-iterator/go&quot;<br><br><span class="hljs-title">var</span> json = jsoniter.<span class="hljs-type">ConfigCompatibleWithStandardLibrary</span><br><span class="hljs-title">json</span>.<span class="hljs-type">Marshal</span>(&amp;<span class="hljs-class"><span class="hljs-keyword">data</span>)</span><br></code></pre></td></tr></table></figure><p>Replace</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> &quot;encoding/json&quot;<br><span class="hljs-title">json</span>.<span class="hljs-type">Unmarshal</span>(input, &amp;<span class="hljs-class"><span class="hljs-keyword">data</span>)</span><br></code></pre></td></tr></table></figure><p>with</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> &quot;github.com/json-iterator/go&quot;<br><br>var <span class="hljs-type">json</span> = jsoniter.ConfigCompatibleWithStandardLibrary<br><span class="hljs-type">json</span>.Unmarshal(<span class="hljs-keyword">input</span>, &amp;data)<br></code></pre></td></tr></table></figure><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>包 jsoniter 实现了 RFC 4627 中定义的 JSON 的编码和解码，并提供了与标准 lib encoding&#x2F;json 语法相同的接口。 从 encoding&#x2F;json 转换为 jsoniter 只不过是将包替换为 jsoniter 和变量类型声明（如果有的话）。 jsoniter 接口与使用标准库的代码提供 100% 的兼容性。</p><p>“JSON and Go”（<a href="https://golang.org/doc/articles/json_and_go.html">https://golang.org/doc/articles/json_and_go.html</a>）描述了 Marshal&#x2F;Unmarshal 如何在任意或预定义的 json 对象和字节之间进行操作，它适用于 jsoniter.Marshal&#x2F;Unmarshal。</p><p>此外， jsoniter.Iterator 提供了一组不同的接口迭代给定的字节&#x2F;字符串&#x2F;读取器并一个一个地产生解析的元素。 这组接口根据需要读取输入并提供更好的性能。</p><p>此外：RegisterFuzzyDecoders的作用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RegisterFuzzyDecoders decode input from PHP with tolerance.</span><br><span class="hljs-comment">// It will handle string/number auto conversation, and treat empty [] as empty struct.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterFuzzyDecoders</span><span class="hljs-params">()</span></span> <br></code></pre></td></tr></table></figure><p>详见单元测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_any_to_string</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br> should := require.New(t)<br> <span class="hljs-keyword">var</span> val <span class="hljs-type">string</span><br> should.Nil(jsoniter.UnmarshalFromString(<span class="hljs-string">`&quot;100&quot;`</span>, &amp;val))<br> should.Equal(<span class="hljs-string">&quot;100&quot;</span>, val)<br> should.Nil(jsoniter.UnmarshalFromString(<span class="hljs-string">&quot;10&quot;</span>, &amp;val))<br> should.Equal(<span class="hljs-string">&quot;10&quot;</span>, val)<br> should.Nil(jsoniter.UnmarshalFromString(<span class="hljs-string">&quot;10.1&quot;</span>, &amp;val))<br> should.Equal(<span class="hljs-string">&quot;10.1&quot;</span>, val)<br> should.Nil(jsoniter.UnmarshalFromString(<span class="hljs-string">`&quot;10.1&quot;`</span>, &amp;val))<br> should.Equal(<span class="hljs-string">&quot;10.1&quot;</span>, val)<br> should.NotNil(jsoniter.UnmarshalFromString(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;val))<br> should.NotNil(jsoniter.UnmarshalFromString(<span class="hljs-string">&quot;[]&quot;</span>, &amp;val))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_any_to_int64</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br> should := require.New(t)<br> <span class="hljs-keyword">var</span> val <span class="hljs-type">int64</span><br><br> should.Nil(jsoniter.UnmarshalFromString(<span class="hljs-string">`&quot;100&quot;`</span>, &amp;val))<br> should.Equal(<span class="hljs-type">int64</span>(<span class="hljs-number">100</span>), val)<br> should.Nil(jsoniter.UnmarshalFromString(<span class="hljs-string">`&quot;10.1&quot;`</span>, &amp;val))<br> should.Equal(<span class="hljs-type">int64</span>(<span class="hljs-number">10</span>), val)<br> should.Nil(jsoniter.UnmarshalFromString(<span class="hljs-string">`10.1`</span>, &amp;val))<br> should.Equal(<span class="hljs-type">int64</span>(<span class="hljs-number">10</span>), val)<br> should.Nil(jsoniter.UnmarshalFromString(<span class="hljs-string">`10`</span>, &amp;val))<br> should.Equal(<span class="hljs-type">int64</span>(<span class="hljs-number">10</span>), val)<br> should.Nil(jsoniter.UnmarshalFromString(<span class="hljs-string">`&quot;&quot;`</span>, &amp;val))<br> should.Equal(<span class="hljs-type">int64</span>(<span class="hljs-number">0</span>), val)<br><br> <span class="hljs-comment">// bool part</span><br> should.Nil(jsoniter.UnmarshalFromString(<span class="hljs-string">`false`</span>, &amp;val))<br> should.Equal(<span class="hljs-type">int64</span>(<span class="hljs-number">0</span>), val)<br> should.Nil(jsoniter.UnmarshalFromString(<span class="hljs-string">`true`</span>, &amp;val))<br> should.Equal(<span class="hljs-type">int64</span>(<span class="hljs-number">1</span>), val)<br><br> should.Nil(jsoniter.UnmarshalFromString(<span class="hljs-string">`-10`</span>, &amp;val))<br> should.Equal(<span class="hljs-type">int64</span>(<span class="hljs-number">-10</span>), val)<br> should.NotNil(jsoniter.UnmarshalFromString(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;val))<br> should.NotNil(jsoniter.UnmarshalFromString(<span class="hljs-string">&quot;[]&quot;</span>, &amp;val))<br> <span class="hljs-comment">// large float to int</span><br> should.NotNil(jsoniter.UnmarshalFromString(<span class="hljs-string">`1234512345123451234512345.0`</span>, &amp;val))<br>&#125;<br></code></pre></td></tr></table></figure><p>重点是下面这个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestRRR</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br> should := require.New(t)<br> <span class="hljs-keyword">var</span> val <span class="hljs-keyword">struct</span>&#123;&#125;<br> should.Nil(jsoniter.UnmarshalFromString(<span class="hljs-string">`[]`</span>, &amp;val))<br> should.Equal(<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;, val)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有调用RegisterFuzzyDecoders会报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">--- FAIL: TestRRR (0.00s)<br>    /Users/rhettnina/mylocalfile/同步（坚果云）/code/work/live-service/controllers/im/conn_test.go:582: <br>         Error Trace: conn_test.go:582<br>         Error:       Expected nil, but got: &amp;errors.errorString&#123;s:&quot;skipObjectDecoder: expect object or null, error found in #0 byte of ...|[]|..., bigger context ...|[]|...&quot;&#125;<br>         Test:        TestRRR<br>FAIL<br></code></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br> <span class="hljs-string">&quot;encoding/json&quot;</span><br> <span class="hljs-string">&quot;fmt&quot;</span><br><br> jsoniter <span class="hljs-string">&quot;github.com/json-iterator/go&quot;</span><br> <span class="hljs-string">&quot;github.com/json-iterator/go/extra&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> json2 = jsoniter.ConfigCompatibleWithStandardLibrary<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br> extra.RegisterFuzzyDecoders()<br>&#125;<br><br><span class="hljs-keyword">type</span> input <span class="hljs-keyword">struct</span> &#123;<br> Code <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;code&quot;`</span><br> Xa   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;xa&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> i := input&#123;<br>  Code: <span class="hljs-string">&quot;123&quot;</span>,<br>  Xa:   <span class="hljs-string">&quot;456&quot;</span>,<br> &#125;<br> v, err := json.Marshal(i)<br> fmt.Println(<span class="hljs-string">&quot;-------string(v)---&quot;</span>, <span class="hljs-type">string</span>(v))<br> <span class="hljs-keyword">var</span> result <span class="hljs-keyword">struct</span> &#123;<br>  Code <span class="hljs-type">int</span>   <span class="hljs-string">`json:&quot;code&quot;`</span><br>  Xa   <span class="hljs-type">int64</span> <span class="hljs-string">`json:&quot;xa&quot;`</span><br> &#125;<br> err = json2.Unmarshal([]<span class="hljs-type">byte</span>(<span class="hljs-type">string</span>(v)), &amp;result)<br> fmt.Println(<span class="hljs-string">&quot;----Unmarshal----&quot;</span>, err)<br> fmt.Println(<span class="hljs-string">&quot;-----result--&quot;</span>, result)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Running] go run &quot;/Users/rhettnina/mylocalfile/同步（坚果云）/code/work/live-service/tt/main.go&quot;<br>-------string(v)--- &#123;&quot;code&quot;:&quot;123&quot;,&quot;xa&quot;:&quot;456&quot;&#125;<br>----Unmarshal---- &lt;nil&gt;<br>-----result-- &#123;123 456&#125;<br><br>[Done] exited with code=0 in 1.231 seconds<br></code></pre></td></tr></table></figure><p>去掉<code>extra.RegisterFuzzyDecoders()</code>会报错，可见RegisterFuzzyDecoders会兼容string转int的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Running] go run &quot;/Users/rhettnina/mylocalfile/同步（坚果云）/code/work/live-service/tt/main.go&quot;<br>-------string(v)--- &#123;&quot;code&quot;:&quot;123&quot;,&quot;xa&quot;:&quot;456&quot;&#125;<br>----Unmarshal---- struct &#123; Code int &quot;json:\&quot;code\&quot;&quot;; Xa int64 &quot;json:\&quot;xa\&quot;&quot; &#125;.Code: readUint64: unexpected character: �, error found in #9 byte of ...|&#123;&quot;code&quot;:&quot;123&quot;,&quot;xa&quot;:|..., bigger context ...|&#123;&quot;code&quot;:&quot;123&quot;,&quot;xa&quot;:&quot;456&quot;&#125;|...<br>-----result-- &#123;0 0&#125;<br></code></pre></td></tr></table></figure><p>加了个In字段测试int转string，发现还是可以正常运行，RegisterFuzzyDecoders还是挺有用的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br> <span class="hljs-string">&quot;encoding/json&quot;</span><br> <span class="hljs-string">&quot;fmt&quot;</span><br><br> jsoniter <span class="hljs-string">&quot;github.com/json-iterator/go&quot;</span><br> <span class="hljs-string">&quot;github.com/json-iterator/go/extra&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> json2 = jsoniter.ConfigCompatibleWithStandardLibrary<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br> extra.RegisterFuzzyDecoders()<br>&#125;<br><br><span class="hljs-keyword">type</span> input <span class="hljs-keyword">struct</span> &#123;<br> Code <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;code&quot;`</span><br> Xa   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;xa&quot;`</span><br> In   <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;in&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> i := input&#123;<br>  Code: <span class="hljs-string">&quot;123&quot;</span>,<br>  Xa:   <span class="hljs-string">&quot;456&quot;</span>,<br>  In:   <span class="hljs-number">100</span>,<br> &#125;<br> v, err := json.Marshal(i)<br> fmt.Println(<span class="hljs-string">&quot;-------string(v)---&quot;</span>, <span class="hljs-type">string</span>(v))<br> <span class="hljs-keyword">var</span> result <span class="hljs-keyword">struct</span> &#123;<br>  Code <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;code&quot;`</span><br>  Xa   <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;xa&quot;`</span><br>  In   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;in&quot;`</span><br> &#125;<br> err = json2.Unmarshal([]<span class="hljs-type">byte</span>(<span class="hljs-type">string</span>(v)), &amp;result)<br> fmt.Println(<span class="hljs-string">&quot;----Unmarshal----&quot;</span>, err)<br> fmt.Println(<span class="hljs-string">&quot;-----result--&quot;</span>, result)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-------string(v)--- &#123;&quot;code&quot;:&quot;123&quot;,&quot;xa&quot;:&quot;456&quot;,&quot;in&quot;:100&#125;<br>----Unmarshal---- struct &#123; Code int &quot;json:\&quot;code\&quot;&quot;; Xa int64 &quot;json:\&quot;xa\&quot;&quot;; In string &quot;json:\&quot;in\&quot;&quot; &#125;.Code: readUint64: unexpected character: �, error found in #9 byte of ...|&#123;&quot;code&quot;:&quot;123&quot;,&quot;xa&quot;:|..., bigger context ...|&#123;&quot;code&quot;:&quot;123&quot;,&quot;xa&quot;:&quot;456&quot;,&quot;in&quot;:100&#125;|...<br>-----result-- &#123;0 0 &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git branch m git checkout u</title>
    <link href="/2022/02/03/git%20branch%20m%20git%20checkout%20u/"/>
    <url>/2022/02/03/git%20branch%20m%20git%20checkout%20u/</url>
    
    <content type="html"><![CDATA[<p>git branch -m</p><p>git branch -m [old] new 重命名分支，将old重命名为new，old可以不填，不填默认重命名当前分支，例子如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">  master  git branch -m main                                 ✔  6288  16:55:23<br>  main  git branch    <br></code></pre></td></tr></table></figure><p>原来分支名是master，现在叫main了</p><p>git push -u</p><p>今天用到了一个<code>git push -u</code>的命令，完整的是这样写的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push -u origin main1    <br></code></pre></td></tr></table></figure><p>然后想看看这-u啥意思，用 git push –help 看看，发现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">GIT-PUSH(1)                                                        Git Manual                                                       GIT-PUSH(1)<br><br><br><br>NAME<br>       git-push - Update remote refs along with associated objects<br><br>SYNOPSIS<br>       git push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=&lt;git-receive-pack&gt;]<br>                  [--repo=&lt;repository&gt;] [-f | --force] [-d | --delete] [--prune] [-v | --verbose]<br>                  [-u | --set-upstream] [-o &lt;string&gt; | --push-option=&lt;string&gt;]<br>                  [--[no-]signed|--signed=(true|false|if-asked)]<br>                  [--force-with-lease[=&lt;refname&gt;[:&lt;expect&gt;]]]<br>                  [--no-verify] [&lt;repository&gt; [&lt;refspec&gt;...]]<br></code></pre></td></tr></table></figure><p>可以看到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[-u | --set-upstream] [-o &lt;string&gt; | --push-option=&lt;string&gt;]<br></code></pre></td></tr></table></figure><p><strong>它和–set-upstream一个作用</strong>，都是给你的github仓库增加新分支的。不过需要注意的是你指定的远程仓库的分支名得和你所在分支一样，不然会报错，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">main-test   git push --set-upstream origin  main-test1<br>error: src refspec main-test1 does not match any<br>error: failed to push some refs to &#x27;https://github.com/xx/blog.git&#x27;<br>main-test   git push --set-upstream origin  main-test    1 ↵  6297  17:02:28<br>Total 0 (delta 0), reused 0 (delta 0), pack-reused 0<br>remote: <br>remote: Create a pull request for &#x27;main-test&#x27; on GitHub by visiting:<br>remote:      https://github.com/xx/blog/pull/new/main-test<br>remote: <br>To https://github.com/xx/blog.git<br> * [new branch]      main-test -&gt; main-test<br>Branch &#x27;main-test&#x27; set up to track remote branch &#x27;main-test&#x27; from &#x27;origin&#x27;.<br></code></pre></td></tr></table></figure><p>把–set-upstream换成-u效果一样。</p><p>总结下来就是多用命令自带的查看命令看看，其实很多上面就有，不用去往上搜索。</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言高级编程-第0章 简介1</title>
    <link href="/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC0%E7%AB%A0%20%E7%AE%80%E4%BB%8B1/"/>
    <url>/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC0%E7%AB%A0%20%E7%AE%80%E4%BB%8B1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go语言高级编程系列是我读《Go语言高级编程》时的一些要点总结。</p></blockquote><p>整个文件夹是我读《Go语言高级编程的整理》</p><p>补充：前文中关于CGO的一下段介绍</p><p>GO特性实现了Go语言对C语言和C++语言的支持，使得Go语言可以无缝继承C&#x2F;C++世界数十年来积累的巨大软件资产。Go汇编语言更是提供了直接访问底层机器指令的方法，让我们可以无限压榨程序中热点代码的性能。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言高级编程-第1章 语言基础1</title>
    <link href="/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%801/"/>
    <url>/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%801/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go语言高级编程系列是我读《Go语言高级编程》时的一些要点总结。</p></blockquote><h2 id="1-1-Go语言创世纪"><a href="#1-1-Go语言创世纪" class="headerlink" title="1.1 Go语言创世纪"></a>1.1 Go语言创世纪</h2><ol><li><p>本章首先简要介绍Go语言的发展历史，并较详细地分析了“Hello World”程序在各个祖先语言中演化过程。然后，对以数组、字符串和切片为代表的基础结构，对以函数、方法和接口所体现的面向过程和鸭子对象的编程，以及Go语言特有的并发编程模型和错误处理哲学做了简单介绍。</p></li><li><p>Go语言很多时候被描述为“类C语言”，或者是“21世纪的C语言”。从各种角度看，Go语言确实是从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等诸多编程思想，还有彻底继承和发扬了C语言简单直接的暴力编程哲学等。图</p></li></ol><p>Go语言是对C语言最彻底的一次扬弃，不仅仅是语法和C语言有着很多差异，最重要的是舍弃了C语言中灵活但是危险的指针运算。而且，Go语言还重新设计了C语言中部分不太合理运算符的优先级，并在很多细微的地方都做了必要的打磨和改变。当然，C语言中少即是多、简单直接的暴力编程哲学则被Go语言更彻底地发扬光大了（Go语言居然只有25个关键字，sepc语言规范还不到50页)）。</p><ol start="3"><li></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println( <span class="hljs-string">&quot;你好, 世界!&quot;</span> )<br>&#125;<br></code></pre></td></tr></table></figure><p>将以上代码保存到 hello.go 文件中<strong>。因为代码中有非ASCII的中文字符，我们需要将文件的编码显式指定为无BOM的UTF8编码格式（源文件采用UTF8编码是Go语言规范所要求的）。</strong></p><ol start="4"><li>虽然Go语言中，函数的名字没有太多的限制，但是main包中的main函数默认是每一个可执行程序的入口。</li><li>和C语言中的字符串不同，Go语言中的字符串内容是不可变更的。在以字符串作为参数传递给fmt.Println函数时，字符串的内容并没有被复制——传递的仅仅是字符串的地址和长度（字符串的结构在 reflect.StringHeader 中定义）。在Go语言中，函数参数都是以复制的方式(不支持以引用的方式)传递（比较特殊的是，Go语言闭包函数对外部变量是以引用的方式使用）。</li></ol><h2 id="1-2-Hello-World的革命"><a href="#1-2-Hello-World的革命" class="headerlink" title="1.2 Hello,World的革命"></a>1.2 Hello,World的革命</h2><ol><li>C语言可以说是现代IT行业最重要的软件基石，目前主流的操作系统几乎全部是由C语言开发的，许多基础系统软件也是C语言开发的。</li><li>Go语言开始采用是否大小写首字母来区分符号是否可以被导出。大写字母开头表示导出的公共符号，小写字母开头表示包内部的私有符号。国内用户需要注意的是，汉字中没有大小写字母的概念，因此以汉字开头的符号目前是无法导出的（针对问题中国用户已经给出相关建议，等Go2之后或许会调整对汉字的导出规则）。</li></ol><h2 id="1-3-数组、字符串和切片"><a href="#1-3-数组、字符串和切片" class="headerlink" title="1.3 数组、字符串和切片"></a>1.3 数组、字符串和切片</h2><ol><li><p>hash表可以看作是数组和链表的混合体</p></li><li><p>Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的。Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改。字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制。切片的行为更为灵活，切片的结构和字符串结构类似，但是解除了只读限制。切片的底层数据虽然也是对应数据类型的数组，但是每个切片还有独立的长度和容量信息，切片赋值和函数传参数时也是将切片头信息部分按传值方式处理。因为切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制。其实Go语言的赋值和函数传参规则很简单，除了闭包函数以引用的方式对外部变量访问之外，其它赋值和函数传参数都是以传值的方式处理。</p></li><li><p>因为数组的长度是数组类型的一个部分，不同长度或不同类型的数据组成的数组都是不同的类型</p></li><li><p>为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组。</p></li><li></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a = [...] <span class="hljs-type">int</span> &#123; <span class="hljs-number">1</span> , <span class="hljs-number">2</span> , <span class="hljs-number">3</span> &#125; <span class="hljs-comment">// a 是一个数组</span><br><span class="hljs-keyword">var</span> b = &amp;a <br><span class="hljs-comment">// b 是指向数组的指针</span><br>fmt.Println(a[ <span class="hljs-number">0</span> ], a[ <span class="hljs-number">1</span> ]) <br><span class="hljs-comment">// 打印数组的前2个元素</span><br>fmt.Println(b[ <span class="hljs-number">0</span> ], b[ <span class="hljs-number">1</span> ]) <br><span class="hljs-comment">// 通过数组指针访问数组元素的方式和</span><br>数组类似<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> b &#123; <br><span class="hljs-comment">// 通过数组指针迭代数组的元素</span><br>fmt.Println(i, v)<br></code></pre></td></tr></table></figure><p>其中 b 是指向 a 数组的指针，但是通过 b 访问数组中元素的写法和 a 类似的。还可以通过 for range 来迭代数组指针指向的数组元素。</p><ol start="6"><li><p>用 for range 方式迭代的性能可能会更好一些，因为这种迭代可以保证不会出现数组越界的情形，每轮迭代对数组元素的访问时可以省去对下标越界的判断。</p></li><li><p>用for range方式迭代的性能可能会更好一些，因为这种迭代可以保证不会出现数组越界的情形，每轮迭代对数组元素的 访问时可以省去对下标越界的判断。</p></li><li><p>长度为0的数组在内存中并不占用空间。空数组虽然很少直接 使用，但是可以用于强调某种特有类型的操作时避免分配额外 的内存空间，比如用于管道的同步操作</p></li><li><p>我们并不关心管道中传输数据的真实类型，其中管道接收和发送操作只是用于消息的同步。对于这种场景，我们用 空数组来作为管道类型可以减少管道元素赋值时的开销。当然 一般更倾向于用无类型的匿名结构体代替：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">c2 := <span class="hljs-built_in">make</span> ( <span class="hljs-keyword">chan</span>  <span class="hljs-keyword">struct</span> &#123;&#125;)<br><span class="hljs-keyword">go</span>  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;c2&quot;</span>)<br>    c2 &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// struct&#123;&#125;部分是类型, &#123;&#125;表示对应的结构体值</span><br>&#125;()<br>&lt;-c2<br></code></pre></td></tr></table></figure></li><li><p>源代码中的文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。因为字节序列对应的是只读的字节序列，因此字符串可以包含任意的数据，包括byte值0。我们也可以用字符串表示GBK等非UTF8编码的数据，不过这种时候将字符串看作是一个只读的二进制数组更准确，因为 for range 等语法并不能支持非UTF8编码的字符串的遍历。</p></li><li><p>字符串虽然不是切片，但是支持切片操作，不同位置的切片底层也访问的同一块内存数据（因为字符串是只读的，相同的字符串面值常量通常是对应同一个字符串常量）</p></li><li><p>Go语言的字符串中可以存放任意的二进制字节序列，而且即使是UTF8字符序列也可能会遇到坏的编码。如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符‘\uFFFD’，这个字符在不同的软件中的显示效果可能不太一样，在印刷中这个符号通常是一个黑色六角形或钻石形状，里面包含一个白色的问号‘ ’。下面的字符串中，我们故意损坏了第一字符的第二和第三字节，因此第一字符将会打印为“ ”，第二和第三字节则被忽略，后面的“abc”依然可以正常解码打印（错误编码不会向后扩散是UTF8编码的优秀特性之一）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println( <span class="hljs-string">&quot;\xe4\x00\x00\xe7\x95\x8cabc&quot;</span> ) <span class="hljs-comment">// 界abc</span><br></code></pre></td></tr></table></figure></li><li><p>Go语言除了 for range 语法对UTF8字符串提供了特殊支持外，还对字符串和 []rune 类型的相互转换提供了特殊的支持。</p></li><li><p>rune 用于表示每个Unicode码点，目前只使用了21个bit位。</p></li><li><p>在将字符串转为 []byte 时，如果转换后的变量并没有被修改的情形，编译器可能会直接返回原始的字符串对应的底层数据。</p><p>string(bytes) 转换模拟实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bytes2str</span><span class="hljs-params">(s [] <span class="hljs-type">byte</span> )</span></span> (p <span class="hljs-type">string</span> ) &#123;<br>data := <span class="hljs-built_in">make</span> ([] <span class="hljs-type">byte</span> , <span class="hljs-built_in">len</span> (s))<br><span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> s &#123;<br>data[i] = c<br>hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;p))<br>hdr.Data = <span class="hljs-type">uintptr</span> (unsafe.Pointer(&amp;data[ <span class="hljs-number">0</span> ]))<br>hdr.Len = <span class="hljs-built_in">len</span> (s)<br><span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure><p>因为Go语言的字符串是只读的，无法直接同构构造底层字节数组生成字符串。</p></li><li><p>编译器可能会直接基于 []byte 底层的数据构建字符串。</p><p>[]rune(s) 转换模拟实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">str2runes</span><span class="hljs-params">(s [] <span class="hljs-type">byte</span> )</span></span> [] <span class="hljs-type">rune</span> &#123;<br><span class="hljs-keyword">var</span> p [] <span class="hljs-type">int32</span><br><span class="hljs-keyword">for</span> <br><span class="hljs-built_in">len</span> (s) &gt; <span class="hljs-number">0</span> &#123;<br>r, size := utf8.DecodeRuneInString(s)<br>p = <span class="hljs-built_in">append</span> (p, r)<br>s = s[size:]<br>&#125;<br><span class="hljs-keyword">return</span> [] <span class="hljs-type">rune</span> (p)<br>&#125;<br></code></pre></td></tr></table></figure><p>因为底层内存结构的差异，字符串到 []rune 的转换必然会导致重新分配 []rune 内存空间，然后依次解码并复制对应的Unicode码点值。这种强制转换并不存在前面提到的字符串和字节切片转化时的优化情况。</p><p>string(runes) 转换模拟实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runes2string</span><span class="hljs-params">(s [] <span class="hljs-type">int32</span> )</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> p [] <span class="hljs-type">byte</span><br>buf := <span class="hljs-built_in">make</span> ([] <span class="hljs-type">byte</span> , <span class="hljs-number">3</span> )<br>for_, r := <span class="hljs-keyword">range</span> s &#123;<br>n := utf8.EncodeRune(buf, r)<br>p = <span class="hljs-built_in">append</span> (p, buf[:n]...)<br>&#125;<br><span class="hljs-keyword">return</span> <br><span class="hljs-type">string</span> (p)<br>&#125;<br></code></pre></td></tr></table></figure><p>同样因为底层内存结构的差异， []rune 到字符串的转换也必然会导致重新构造字符串。这种强制转换不存在前面提到的优化情况。</p></li><li><p>切片多了一个 Cap 成员表示切片指向的内存空间的最大容量（对应元素的个数，而不是字节数）。</p></li><li><p>在开头一般都会导致内存的重新分配，而且会导致已有的元素全部复制1次。因此，从切片的开头添加元素的性能一般要比从尾部追加元素的性能差很多。</p></li><li><p>并不会复制底层的数据。对于类型，和数组的最大不同是，切片的类型和长度信息无关，只要是相同类型元素构成的切片均对应相同的切片类型。</p></li><li><p>空数组一般很少用到。但是对于切片来说， len 为 0 但是cap 容量不为 0 的切片则是非常有用的特性。当然，如果len 和 cap 都为 0 的话，则变成一个真正的空切片，虽然它并不是一个 nil 值的切片。在判断一个切片是否为空时，一般通过 len 获取切片的长度来判断，一般很少将切片和 nil 值做直接的比较。</p></li></ol><h2 id="1-4-函数、方法和接口"><a href="#1-4-函数、方法和接口" class="headerlink" title="1.4 函数、方法和接口"></a>1.4 函数、方法和接口</h2><ol><li>闭包函数是函数式编程语言的核心。</li><li>Go语言程序的初始化和执行总是从 main.main 函数开始的。但是如果 main 包导入了其它的包，则会按照顺序将它们包含进 main 包里（这里的导入顺序依赖具体实现，一般可能是以文件名或包路径名的字符串顺序导入）。如果某个包被多次导入的话，在执行的时候只会导入一次。当一个包被导入时，如果它还导入了其它的包，则先将其它的包包含进来，然后创建和初始化这个包的常量和变量,再调用包里的 init 函数，如果一个包有多个 init 函数的话，调用顺序未定义(实现可能是以文件名的顺序调用)，同一个文件内的多个 init则是以出现的顺序依次调用（ init 不是普通函数，可以定义有多个，所以也不能被其它函数调用）。最后，当 main包的所有包级常量、变量被创建和初始化完成，并且 init函数被执行后，才会进入 main.main 函数，程序开始正常执行。</li></ol><p> <img src="http://tva1.sinaimg.cn/large/006gLprLgy1gwynbvfm9yj31540k640o.jpg" alt="Xnip2021-12-01_21-19-26.jpg"></p><ol start="3"><li><p>Go语言中的函数可以有多个参数和多个返回值，参数和返回值都是以传值的方式和被调用者交换数据。</p></li><li><p>defer 语句在 return 语句之后修改返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Inc</span><span class="hljs-params">()</span></span> (v <span class="hljs-type">int</span> ) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span>&#123; v++ &#125; ()<br><span class="hljs-keyword">return</span> <span class="hljs-number">42</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中 defer 语句延迟执行了一个匿名函数，因为这个匿名函数捕获了外部函数的局部变量 v ，这种函数我们一般叫闭包。闭包对捕获的外部变量并不是传值方式访问，而是以引用的方式访问。也就是闭包操作会影响外部，外部操作会影响闭包。</p></li><li><p>下面的函数输出是3个 3</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">3</span> ; i++ &#123;<br><span class="hljs-keyword">defer</span> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span>&#123; <span class="hljs-built_in">println</span> (i) &#125; ()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为是闭包，在 for 迭代语句中，每个 defer 语句延迟执行的函数引用的都是同一个 i 迭代变量，在循环结束后这个变量的值为3，因此最终输出的都是3。</p></li><li><p>虽然Go语言运行时会自动更新引用了地址变化的栈变量的指针，但最重要的一点是要明白Go语言中指针不再是固定不变的了（因此不能随意将指针保持到数值变量中，Go语言的地址也不能随意保存到不在GC控制的环境中，因此使用CGO时不能在C语言中长期持有Go语言对象的地址）。</p></li><li><p>对于有C&#x2F;C++编程经验的程序员需要强调的是：不用关心Go语言中函数栈和堆的问题，编译器和运行时会帮我们搞定；同样不要假设变量在内存中的位置是固定不变的，指针随时可能会变化，特别是在你不期望它变化的时候。</p></li><li><p>面向对象编程(OOP)进入主流开发领域一般认为是从C++开始的，C++就是在兼容C语言的基础之上支持了class等面向对象的特性。然后Java编程则号称是纯粹的面向对象语言，因为Java中函数是不能独立存在的，每个函数都必然是属于某个类的。</p></li><li><pre><code class="go">// 关闭文件func (f *File) Close() error &#123;// ...&#125;// 读文件数据func (f *File) Read( int64 offset, data [] byte ) int &#123;// ...&#125;<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>   将第一个函数参数移动到函数前面，从代码角度看虽然只是一个小的改动，但是从编程哲学角度来看，Go语言已经是进入面向对象语言的行列了。我们可以给任何自定义类型添加一个或多个方法。每种类型对应的方法必须和类型的定义在同一个包中，因此是无法给 int 这类内置类型添加方法的（因为方法的定义和类型的定义不在一个包中）。<br><br><span class="hljs-number">10</span>. 方法是由函数演变而来，只是将函数的第一个对象参数移动到了函数名前面了而已。因此我们依然可以按照原始的过程式思维来使用方法。通过叫方法表达式的特性可以将方法还原为普通类型的函数<br><br><span class="hljs-number">11</span>. ```go<br>    type Cache struct &#123;<br>    m map <span class="hljs-selector-attr">[ string ]</span> string<br>    sync<span class="hljs-selector-class">.Mutex</span><br>    &#125;<br>    func (<span class="hljs-selector-tag">p</span> *Cache) <span class="hljs-built_in">Lookup</span>(key string ) string &#123;<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.Lock</span>()<br>    defer <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.Unlock</span>()<br>    return <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.m</span><span class="hljs-selector-attr">[key]</span><br>    &#125;<br></code></pre></td></tr></table></figure> .但是在调用 p.Lock() 和p.Unlock() 时, p 并不是 Lock 和 Unlock 方法的真正接收者, 而是会将它们展开为 p.Mutex.Lock() 和 p.Mutex.Unlock()调用. 这种展开是编译期完成的, 并没有运行时代价.</code></pre></li><li><p>&#96;&#96;&#96;go<br>type UpperWriter struct {<br>io.Writer<br>}<br>func (p *UpperWriter) Write(data [] byte ) (n int<br>, err error) {<br>return p.Writer.Write(bytes.ToUpper(data))<br>}<br>func main() {<br>fmt.Fprintln(&amp;UpperWriter{os.Stdout},<br>“hello, world” )<br>}</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>    我们可以通过定制自己的输出对象，将每个字符转为大写字符后输出<br><br><span class="hljs-number">13.</span> 通过在结构体中嵌入匿名类型成员，可以继承匿名类型的方法。其实这个被嵌入的匿名成员不一定是普通类型，也可以是接口类型。<br><br><span class="hljs-meta">## 1.5 面向并发的内存模型</span><br><br><span class="hljs-number">1.</span> 在早期，CPU都是以单核的形式顺序执行机器指令。Go语言的祖先C语言正是这种顺序编程语言的代表。顺序编程语言中的顺序是指：所有的指令都是以串行的方式执行，在相同的时刻有且仅有一个CPU在顺序执行程序的指令。<br><br><span class="hljs-number">2.</span> 每个系统级线程都会有一个固定大小的栈（一般默认可能是<span class="hljs-number">2</span>MB），这个栈主要用来保存函数递归调用时参数和局部变量。固定了栈的大小导致了两个问题：一是对于很多只需要很小的栈空间的线程来说是一个巨大的浪费，二是对于少数需要巨大栈空间的线程来说又面临栈溢出的风险。针对这两个问题的解决方案是：要么降低固定的栈大小，提升空间的利用率；要么增大栈的大小以允许更深的函数递归调用，但这两者是没法同时兼得的。相反，一个Goroutine会以一个很小的栈启动（可能是<span class="hljs-number">2</span>KB或<span class="hljs-number">4</span>KB），当遇到深度递归导致当前栈空间不足时，Goroutine会根据需要动态地伸缩栈的大小（主流实现中栈的最大值可达到<span class="hljs-number">1</span>GB）。因为启动的代价很小，所以我们可以轻易地启动成千上万个Goroutine。<br><br><span class="hljs-number">3.</span> Go的运行时还包含了其自己的调度器，这个调度器使用了一些技术手段，可以在n个操作系统线程上多工调度m个Goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的Go程序中的Goroutine。Goroutine采用的是半抢占式的协作调度，只有在当前Goroutine发生阻塞时才会导致调度；同时发生在用户态，调度器会根据具体函数只保存必要的寄存器，切换的代价要比系统线程低得多。运行时有一个 runtime.GOMAXPROCS 变量，用于控制当前运行正常非阻塞Goroutine的系统线程数目。<br><br><span class="hljs-number">4.</span> 一般情况下，原子操作都是通过“互斥”访问来保证的，通常由特殊的CPU指令提供保护。当然，如果仅仅是想模拟下粗粒度的原子操作，我们可以借助于 sync.Mutex 来实现<br><br><span class="hljs-number">5.</span> 用互斥锁来保护一个**数值型**的共享资源，麻烦且效率低下。**标准库的 sync/atomic 包对原子操作提供了丰富的支持。**<br><br><span class="hljs-number">6.</span> atomic.AddUint64 函数调用保证了 total 的读取、更新和保存是一个原子操作，因此在多线程中访问也是安全的。<br><br><span class="hljs-number">7.</span> sync/atomic 包对基本的数值类型及复杂对象的读写都提供了原子操作的支持。 atomic.Value 原子对象提供了 Load 和Store 两个原子方法，分别用于加载和保存数据，返回值和参数都是 <span class="hljs-keyword">interface</span>&#123;&#125; 类型，因此可以用于任意的自定义复杂类型。<br><br><span class="hljs-number">8.</span> ```<span class="hljs-function">go</span><br><span class="hljs-function">   <span class="hljs-keyword">var</span> a <span class="hljs-built_in">string</span></span><br><span class="hljs-function">   <span class="hljs-keyword">var</span> done <span class="hljs-built_in">bool</span></span><br><span class="hljs-function">   func <span class="hljs-title">setup</span>()</span> &#123;<br>   a = <span class="hljs-string">&quot;hello, world&quot;</span><br>   done = <span class="hljs-literal">true</span><br>   &#125;<br>   <span class="hljs-function">func <span class="hljs-title">main</span>()</span> &#123;<br>   <span class="hljs-function">go <span class="hljs-title">setup</span>()</span><br><span class="hljs-function">   <span class="hljs-keyword">for</span> !done</span> &#123;&#125;<br>   print (a)<br>   &#125;<br></code></pre></td></tr></table></figure></li></ol><p>   我们创建了 setup 线程，用于对字符串 a 的初始化工作，初始化完成之后设置 done 标志为 true 。 main 函数所在的主线程中，通过 for !done {} 检测 done 变为 true 时，认为字符串初始化工作完成，然后进行字符串的打印工作。但是Go语言并不保证在 main 函数中观测到的对 done 的写入操作发生在对字符串 a 的写入的操作之后，因此程序很可能打印一个空字符串。更糟糕的是，因为两个线程之间没有同步事件， setup 线程对 done 的写入操作甚至无法被 main线程看到， main 函数有可能陷入死循环中。(ps 虽然我运行了几次得到的结果都是hello, world)</p><p>   在Go语言中，同一个Goroutine线程内部，顺序一致性内存模型是得到保证的。但是不同的Goroutine之间，并不满足顺序一致性内存模型，需要通过明确定义的同步事件来作为同步的参考。如果两个事件不可排序，那么就说这两个事件是并发的。</p><p>   因此，如果在一个Goroutine中顺序执行 a &#x3D; 1; b &#x3D; 2; 两个语句，虽然在当前的Goroutine中可以认为 a &#x3D; 1; 语句先于 b &#x3D;2; 语句执行，但是在另一个Goroutine中 b &#x3D; 2; 语句可能会先于 a &#x3D; 1; 语句执行，甚至在另一个Goroutine中无法看到它们的变化（可能始终在寄存器中）。</p><ol start="9"><li><p>通过 sync.Mutex 互斥量也是可以实现同步的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> mu sync.Mutex<br>mu.Lock()<br><span class="hljs-keyword">go</span> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">println</span> ( <span class="hljs-string">&quot;你好, 世界&quot;</span> )<br>mu.Unlock()<br>&#125;()<br>mu.Lock()<br>&#125;<br></code></pre></td></tr></table></figure><p>可以确定后台线程的 mu.Unlock() 必然在 println(“你好, 世界”) 完成后发生（同一个线程满足顺序一致性）， main 函数的第二个 mu.Lock() 必然在后台线程的 mu.Unlock() 之后发生（ sync.Mutex 保证），此时后台线程的打印工作已经顺利完成了</p></li><li><p>如果某个包被多次导入的话，在执行的时候只会导入一次。</p></li><li><p>要注意的是，在 main.main 函数执行之前所有代码都运行在同一个Goroutine中，也是运行在程序的主系统线程中。如果某个 init 函数内部用go关键字启动了新的Goroutine的话，新的Goroutine和 main.main 函数是并发执行的。因为所有的 init 函数和 main 函数都是在主线程完成，它们也是满足顺序一致性模型的。</p></li><li><p>Channel通信是在Goroutine之间进行同步的主要方法。在无缓存的Channel上的每一次发送操作都有与其对应的接收操作相配对，发送和接收操作通常发生在不同的Goroutine上（在同一个Goroutine上执行2个操作很容易导致死锁）。</p></li><li><p>有时程序中最后一句 select{} 是一个空的管道选择语句，该语句会导致main 线程阻塞，从而避免程序过早退出。还有 for{} 、 &lt;-make(chan int) 等诸多方法可以达到类似的效果。因为 main线程被阻塞了，如果需要程序正常退出的话可以通过调用os.Exit(0) 实现。</p></li><li><p>严谨的并发程序的正确性不应该是依赖于CPU的执行速度和休眠时间等不靠谱的因素的。严谨的并发也应该是可以静态推导出结果的：根据线程内顺序一致性，结合Channel或 sync 同步事件的可排序性来推导，最终完成各个线程各段代码的偏序关系排序。如果两个事件无法根据此规则来排序，那么它们就是并发的，也就是执行先后顺序不可靠的。解决同步问题的思路是相同的：使用显式的同步。</p></li></ol><h2 id="1-6-常见的并发模式"><a href="#1-6-常见的并发模式" class="headerlink" title="1.6 常见的并发模式"></a>1.6 常见的并发模式</h2><ol><li><p>Go语言最吸引人的地方是它内建的并发支持。</p></li><li><p>并发不是并行。并发更关注的是程序的设计层面，并发的程序完全是可以顺序执行的，只有在真正的多核CPU上才可能真正地同时运行。并行更关注的是程序的运行层面，并行一般是简单的大量重复，例如GPU中对图像处理都会有大量的并行运算。</p></li><li><p>我们可以让 main 函数保存阻塞状态不退出，只有当用户输入 Ctrl-C 时才真正退出程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span> ( <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> , <span class="hljs-number">64</span> ) <span class="hljs-comment">// 成果队列</span><br><span class="hljs-keyword">go</span> Producer( <span class="hljs-number">3</span> , ch) <span class="hljs-comment">// 生成 3 的倍数的序列</span><br><span class="hljs-keyword">go</span> Producer( <span class="hljs-number">5</span> , ch) <span class="hljs-comment">// 生成 5 的倍数的序列</span><br><span class="hljs-keyword">go</span> Consumer(ch) <br><span class="hljs-comment">// 消费 生成的队列</span><br><span class="hljs-comment">// Ctrl+C 退出</span><br>sig := <span class="hljs-built_in">make</span> ( <span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span> )<br>signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)<br>fmt.Printf( <span class="hljs-string">&quot;quit (%v)\n&quot;</span>, &lt;-sig)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在Go语言自带的godoc程序实现中有一个 vfs 的包对应虚拟的文件系统，在 vfs 包下面有一个 gatefs 的子包，gatefs 子包的目的就是为了控制访问该虚拟文件系统的最大并发数。 gatefs 包的应用很简单：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;golang.org/x/tools/godoc/vfs&quot;</span><br><span class="hljs-string">&quot;golang.org/x/tools/godoc/vfs/gatefs&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fs := gatefs.New(vfs.OS( <span class="hljs-string">&quot;/path&quot;</span> ), <span class="hljs-built_in">make</span> ( <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">8</span> )) <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中 vfs.OS(“&#x2F;path”) 基于本地文件系统构造一个虚拟的文件系统，然后 gatefs.New 基于现有的虚拟文件系统构造一个并发受控的虚拟文件系统。并发数控制的原理在前面一节已经讲过，就是通过带缓存管道的发送和接收规则来实现最大并发阻塞：</p><ol start="5"><li><p>Go语言中不同Goroutine之间主要依靠管道进行通信和同步。要同时处理多个管道的发送或接收操作，我们需要使用select 关键字（这个关键字和网络编程中的 select 函数的行为类似）。当 select 有多个分支时，会随机选择一个可用的管道分支，如果没有可用的管道分支则选择 default 分支，否则会一直保存阻塞状态。</p></li><li><p>通过 select 的 default 分支实现非阻塞的管道发送或接收操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> v := &lt;-in:<br>fmt.Println(v)<br><span class="hljs-keyword">default</span> :<br><span class="hljs-comment">// 没有数据</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过 select 来阻止 main 函数退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// do some thins</span><br><span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>管道的发送操作和接收操作是一一对应的，如果要停止多个Goroutine那么可能需要创建同样数量的管道，这个代价太大了。其实我们可以通过 close 关闭一个管道来实现广播的效果，所有从关闭管道接收的操作均会收到一个零值和一个可选的失败标志。</p></li><li><p>在Go1.7发布时，标准库增加了一个 context 包，用来简化对于处理单个请求的多个Goroutine之间与请求域的数据、超时和退出等操作，官方有博文对此做了专门介绍。我们可以用context 包来重新实现前面的线程安全退出或超时的控制:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(ctx context.Context, wg *sync.WaitGroup)</span></span> <span class="hljs-type">error</span> &#123;<br> <span class="hljs-keyword">defer</span> wg.Done()<br> <span class="hljs-keyword">for</span> &#123;<br>  <span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">default</span>:<br>   fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>  <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>   <span class="hljs-keyword">return</span> ctx.Err()<br>  &#125;<br> &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> ctx, cancel := context.WithTimeout(context.Background(),<span class="hljs-number">10</span>*time.Second)<br> <span class="hljs-keyword">var</span> wg sync.WaitGroup<br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>  wg.Add(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">go</span> worker(ctx, &amp;wg)<br>  time.Sleep(time.Second)<br>  cancel()<br>  wg.Wait()<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当并发体超时或 main 主动停止工作者Goroutine时，每个工作者都可以安全退出。</p></li><li><p><strong>Go语言是带内存自动回收特性的，因此内存一般不会泄漏。</strong></p></li><li><p>当main函数完成工作前，通过调用 cancel() 来通知后台Goroutine退出，这样就避免了Goroutine的泄漏。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> <span class="hljs-comment">// 通过 Context 控制后台Goroutine状态</span><br> ctx, cancel := context.WithCancel(context.Background())<br> ch := GenerateNatural(ctx) <span class="hljs-comment">// 自然数序列: 2, 3, 4, ...</span><br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ; i++ &#123;<br> prime := &lt;-ch <span class="hljs-comment">// 新出现的素数</span><br> fmt.Printf( <span class="hljs-string">&quot;%v: %v\n&quot;</span><br> , i+ <span class="hljs-number">1</span> , prime)<br> ch = PrimeFilter(ctx, ch, prime) <span class="hljs-comment">// 基于新素数构造的过滤器</span><br> &#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言高级编程-第1章 语言基础2</title>
    <link href="/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%802/"/>
    <url>/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC1%E7%AB%A0%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%802/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go语言高级编程系列是我读《Go语言高级编程》时的一些要点总结。</p></blockquote><h2 id="1-7-错误和异常"><a href="#1-7-错误和异常" class="headerlink" title="1.7 错误和异常"></a>1.7 错误和异常</h2><ol><li>在C语言中，默认采用一个整数类型的 errno 来表达错误，这样就可以根据需要定义多种错误类型。<strong>在Go 语言中， syscall.Errno 就是对应C语言中 errno 类型的错误。</strong>在 syscall 包中的接口，如果有返回错误的话，底层也 是 syscall.Errno 错误类型。</li></ol><p>比如我们通过 syscall 包的接口来修改文件的模式时，如果 遇到错误我们可以通过将 err 强制断言为 syscall.Errno 错误类型来处理:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">err := syscall.Chmod( <span class="hljs-string">&quot;:invalid path:&quot;</span> ,  <span class="hljs-number">0666</span> )<br>  <span class="hljs-keyword">if</span>  err !=  <span class="hljs-literal">nil</span>  &#123;<br>      log.Fatal(err.(syscall.Errno))<br>&#125;<br></code></pre></td></tr></table></figure><p>在Go语言中，错误被认为是一种可以预期的结果;而异常则 是一种非预期的结果，发生异常可能表示程序中存在BUG或发生了其它不可控的问题。<strong>Go语言推荐使用 recover 函数将内部异常转为错误处理</strong>，这使得用户可以真正的关心业务相关的错误处理。</p><p>如果某个接口简单地将所有普通的错误当做异常抛出，将会使错误信息杂乱且没有价值。就像在 main 函数中直接捕获全部一样，是没有意义的:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">defer</span>   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span> &#123;<br> <span class="hljs-keyword">if</span> r:= <span class="hljs-built_in">recover</span>();r!= <span class="hljs-literal">nil</span> &#123; log.Fatal(r)<br>&#125; &#125;()<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>捕获异常不是最终的目的。如果异常不可预测，直接输出异常信息是最好的处理方式。</p><ol start="2"><li><strong>为了记录错误类型在包装的变迁过程中的信息，我们一般 会定义一个辅助的 WrapError 函数</strong>，用于包装原始的错误， 同时保留完整的原始错误类型。为了问题定位的方便，同时也 为了能记录错误发生时的函数调用状态，我们很多时候希望在 出现致命错误的时候保存完整的函数调用信息。<strong>同时，为了支 持RPC等跨网络的传输，我们可能要需要将错误序列化为类似 JSON格式的数据，然后再从这些数据中将错误解码恢出来。</strong></li></ol><p>为此，我们可以定义自己的 github.com&#x2F;chai2010&#x2F;errors 包， 里面是以下的错误类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span>  Error  <span class="hljs-keyword">interface</span>  &#123;<br>      Caller() []CallerInfo<br>      Wraped() []<span class="hljs-type">error</span><br>      Code()  <span class="hljs-type">int</span><br>      <span class="hljs-type">error</span><br>      private()<br>&#125;<br><br>  <span class="hljs-keyword">type</span>  CallerInfo  <span class="hljs-keyword">struct</span>  &#123;<br>      FuncName  <span class="hljs-type">string</span><br>      FileName  <span class="hljs-type">string</span><br>      FileLine  <span class="hljs-type">int</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>其中 Error 为接口类型，是 error 接口类型的扩展，用于 给错误增加调用栈信息，同时支持错误的多级嵌套包装，支持 错误码格式。为了使用方便，我们可以定义以下的辅助函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">New</span><span class="hljs-params">(msg  <span class="hljs-type">string</span> )</span></span> <span class="hljs-type">error</span><br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">NewWithCode</span><span class="hljs-params">(code  <span class="hljs-type">int</span> , msg  <span class="hljs-type">string</span> )</span></span> <span class="hljs-type">error</span><br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">Wrap</span><span class="hljs-params">(err <span class="hljs-type">error</span>, msg <span class="hljs-type">string</span> )</span></span> <span class="hljs-type">error</span><br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">WrapWithCode</span><span class="hljs-params">(code <span class="hljs-type">int</span>,err <span class="hljs-type">error</span>, msg <span class="hljs-type">string</span> )</span></span> <span class="hljs-type">error</span><br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">FromJson</span><span class="hljs-params">(json  <span class="hljs-type">string</span> )</span></span> (Error, <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">ToJson</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span>  <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>Go语言中的错误是一种接口类型。接口信息中包含了原始类 型和原始的值。只有当接口的类型和原始的值都为空的时候， 接口的值才对应 nil 。</strong>其实当接口中类型为空的时候，原始 值必然也是空的;反之，当接口对应的原始值为空的时候，接 口对应的原始类型并不一定为空的。</li></ol><p>因此，在处理错误返回值的时候，没有错误的返回值最好直接 写为 nil 。</p><p><strong>Go语言作为一个强类型语言，不同类型之间必须要显式的转 换(而且必须有相同的基础类型)。但是，Go语言中</strong></p><p><strong>interface 是一个例外:非接口类型到接口类型，或者是接口 类型之间的转换都是隐式的。</strong>这是为了支持鸭子类型，当然会 牺牲一定的安全性。</p><ol start="4"><li>Go语言函数调用的正常流程是函数执行返回语句返回结果， 在这个流程中是没有异常的，因此在这个流程中执行 recover 异常捕获函数始终是返回 nil 。另一种是异常流程: 当函数 调用 panic 抛出异常，函数将停止执行后续的普通语句，但 是之前注册的 defer 函数调用仍然保证会被正常执行，然后 再返回到调用者。对于当前函数的调用者，因为处理异常状态 还没有被捕获，和直接调用 panic 函数的行为类似。在异常 发生时，如果在 defer 中执行 recover 调用，它可以捕获触 发 panic 时的参数，并且恢复到正常的执行流程。</li></ol><p><strong>在非 defer 语句中执行 recover 调用是初学者常犯的错误:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> r: = <span class="hljs-built_in">recover</span>();r != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(r)<br>    &#125;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-number">123</span>)<br>    <span class="hljs-keyword">if</span> r: = <span class="hljs-built_in">recover</span>();r != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(r)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面程序中两个 recover 调用都不能捕获任何异常。在第一 个 recover 调用执行时，函数必然是在正常的非异常执行流 程中，这时候 recover 调用将返回 nil 。发生异常时，第 二个 recover 调用将没有机会被执行到，因为 panic 调用会 导致函数马上执行已经注册 defer 的函数后返回。</p><p>其实 recover 函数调用有着更严格的要求:<strong>我们必须在 defer 函数中直接调用 recover</strong> 。如果 defer 中调用的是 recover 函数的包装函数的话，异常的捕获工作将失败!</p><p>如果是在嵌套的 defer 函数中调用 recover 也将导致 无法捕获异常</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 无法捕获异常</span><br>                <span class="hljs-keyword">if</span> r: = <span class="hljs-built_in">recover</span>();<br>                r != <span class="hljs-literal">nil</span> &#123;<br>                    fmt.Println(r)<br>                &#125;<br>            &#125;()<br>        &#125;()<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-number">1</span>)<br>  &#125;<br></code></pre></td></tr></table></figure><p>2层嵌套的 defer 函数中直接调用 recover 和1层 defer 函 数中调用包装的 MyRecover 函数一样，都是经过了2个函数帧 才到达真正的 recover 函数，这个时候Goroutine的对应上<strong>一 级栈帧中</strong>已经没有异常信息。</p><p><strong>必须要和有异常的栈帧只隔一个栈帧， recover 函数才能正 常捕获异常。换言之， recover 函数捕获的是祖父一级调用 函数栈帧的异常(刚好可以跨越一层 defer 函数)!</strong></p><ol start="5"><li>我们可以模拟出不同类型的异常。通过为定义不同类型的保护接口，我们就可以区分异常的类型<br>了:</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">if</span> r: = <span class="hljs-built_in">recover</span>();<br>            r != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">switch</span> x: = r.(<span class="hljs-keyword">type</span>) &#123;<br>                    <span class="hljs-keyword">case</span> runtime.Error:<br>                        <span class="hljs-comment">// 这是运行时错误类型异常 case error:</span><br>                        <span class="hljs-comment">// 普通错误类型异常 default :</span><br>                        <span class="hljs-comment">// 其他类型异常</span><br>                &#125;<br>            &#125;<br>        &#125;()<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>如果遇到要查阅API的时候可以通过godoc命令打开 自带的文档查询。Go语言本身不仅仅包含了所有的文档，也 包含了所有标准库的实现代码，这是第一手的最权威的Go语 言资料。我们认为此时你应该已经可以熟练使用Go语言了。</li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言高级编程-第2章 CGO</title>
    <link href="/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0%20CGO/"/>
    <url>/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0%20CGO/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go语言高级编程系列是我读《Go语言高级编程》时的一些要点总结。</p></blockquote><ol><li><p><strong>C语言作为一个 通用语言，很多库会选择提供一个C兼容的API</strong>，然后用其他 不同的编程语言实现。<strong>Go语言通过自带的一个叫CGO的工具来支持C语言函数调用</strong>，同时我们可以用Go语言导出C动态库 接口给其它语言使用。本章主要讨论CGO编程中涉及的一些问 题。</p></li><li><p>一个简单的CGO程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hello cgo&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码通过 import “C” 语句启用CGO特性</strong>，主函数只是通过Go 内置的println函数输出字符串，其中并没有任何和CGO相关的 代码。虽然没有调用CGO的相关函数，但是go build命令会在 编译和链接阶段启动gcc编译器，这已经是一个完整的CGO程 序了。</p></li><li><p>另一个程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">//#include &lt;stdio.h&gt;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    C.puts(C.CString(<span class="hljs-string">&quot;Hello, World\n&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>我们不仅仅通过 import “C” 语句启用CGO特性，同时包含C 语言的 &lt;stdio.h&gt; 头文件。然后通过CGO包的 C.CString 函 数将Go语言字符串转为C语言字符串，最后调用CGO包的C.puts 函数向标准输出窗口打印转换后的C字符串</p><p>相比“Hello, World 的革命”一节中的CGO程序最大的不同是: 我们没有在程序退出前释放 C.CString 创建的C语言字符串; 还有我们改用 puts 函数直接向标准输出打印，之前是采用fputs 向标准输出打印。</p><p>没有释放使用 C.CString 创建的C语言字符串会导致内存泄 漏。但是对于这个小程序来说，这样是没有问题的，因为程序 退出后操作系统会自动回收程序的所有资源。</p></li></ol><p>不写了后面的，之前的之前看不懂没看完</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言高级编程-第3章 Go汇编语言</title>
    <link href="/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0%20Go%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    <url>/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0%20Go%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go语言高级编程系列是我读《Go语言高级编程》时的一些要点总结。</p></blockquote><ol><li><p>Go汇编语言并不是一个独立的语言，因为Go汇编程序无法独 立使用。Go汇编代码必须以Go包的方式组织，同时包中至少 要有一个Go语言文件用于指明当前包名等基本包信息。如果 Go汇编代码中定义的变量和函数要被其它Go语言代码引用， 还需要通过Go语言代码将汇编中定义的符号声明出来。用于 变量的定义和函数的定义Go汇编文件类似于C语言中的.c文 件，而用于导出汇编中定义符号的Go源文件类似于C语言的.h 文件。</p></li><li><p>以下命令可查看的Go语言程序对应的伪汇编代码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go tool compile -S pkg.go<br></code></pre></td></tr></table></figure></li></ol><p>TODO: 后面的看不太懂，没记什么。等有空了再重新读下，补上笔记。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
      <tag>TODO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言高级编程-第4章 RPC和Protobuf</title>
    <link href="/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0%20RPC%E5%92%8CProtobuf/"/>
    <url>/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC4%E7%AB%A0%20RPC%E5%92%8CProtobuf/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go语言高级编程系列是我读《Go语言高级编程》时的一些要点总结。</p></blockquote><ol><li><p>RPC是远程过程调用的缩写(Remote Procedure Call)，通俗 地说就是调用远处的一个函数</p></li><li><p>因为 RPC涉及的函数可能非常之远，远到它们之间说着完全不同的 语言，语言就成了两边的沟通障碍。<strong>而Protobuf因为支持多种 不同的语言(甚至不支持的语言也可以扩展支持)，其本身特性也非常方便描述服务的接口(也就是方法列表)，因此非常 适合作为RPC世界的接口交流语言</strong></p></li><li><p>RPC是远程过程调用的简称，是分布式系统中不同节点间流行 的通信方式。</p></li><li><p>Go语言的RPC包的路径为net&#x2F;rpc，也就是放在了net包目录下 面。因此我们可以猜测该RPC包是建立在net包基础之上的</p></li><li><p><strong>我们尝试基于rpc实现一个类似的例子。</strong></p><p>我们先构造一个HelloService类型，其中的Hello方法用于实现 打印功能:</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HelloService <span class="hljs-keyword">struct</span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p * HelloService)</span></span> Hello(request <span class="hljs-type">string</span>, reply * <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123; <br>  *reply = <span class="hljs-string">&quot;hello&quot;</span> + request<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中Hello方法必须满足Go语言的RPC规则:方法只能有两个 可序列化的参数，其中第二个参数是指针类型，并且返回一个 error类型，同时必须是公开的方法。</p><p>然后就可以将HelloService类型的对象注册为一个RPC服务:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    rpc.RegisterName(<span class="hljs-string">&quot;HelloService&quot;</span>, <span class="hljs-built_in">new</span>(HelloService))<br>    listener, err: = net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;ListenTCP error:&quot;</span>, err)<br>    &#125;<br>    conn, err: = listener.Accept()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;Accept error:&quot;</span>, err)<br>    &#125;<br>    rpc.ServeConn(conn)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中rpc.Register函数调用会将对象类型中所有满足RPC规则的 对象方法注册为RPC函数，所有注册的方法会放 在“HelloService”服务空间之下。然后我们建立一个唯一的TCP 链接，并且通过rpc.ServeConn函数在<strong>该TCP链接</strong>上为对方提供 RPC服务。</p><p>下面是客户端请求HelloService服务的代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    client, err: = rpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;dialing:&quot;</span>, err)<br><br>    &#125;<br>    <span class="hljs-keyword">var</span> reply <span class="hljs-type">string</span><br>    err = client.Call(<span class="hljs-string">&quot;HelloService.Hello&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, &amp; reply)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    fmt.Println(reply)<br>&#125;<br></code></pre></td></tr></table></figure><p>首选是通过rpc.Dial拨号RPC服务，然后通过client.Call调用具 体的RPC方法。</p><ol start="6"><li><p>标准库的RPC默认采用Go语言特有的gob编码，因此从其它语 言调用Go语言实现的RPC服务将比较困难。</p></li><li><p>Go语言的RPC框架有两个比较有特色的设计:一个是RPC数据 打包时可以通过插件实现自定义的编码和解码;另一个是RPC 建立在抽象的io.ReadWriteCloser接口之上的，我们可以将RPC 架设在不同的通讯协议之上。这里我们将尝试通过官方自带的 net&#x2F;rpc&#x2F;jsonrpc扩展实现一个跨语言的PPC。</p><p>首先是基于json编码重新实现RPC服务:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    rpc.RegisterName(<span class="hljs-string">&quot;HelloService&quot;</span>, <span class="hljs-built_in">new</span>(HelloService))<br>    listener, err: = net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;ListenTCP error:&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err: = listener.Accept()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Fatal(<span class="hljs-string">&quot;Accept error:&quot;</span>, err)<br>        &#125;<br>        <span class="hljs-keyword">go</span> rpc.ServeCodec(jsonrpc.NewServerCodec(conn))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中最大的变化是用rpc.ServeCodec函数替代了 rpc.ServeConn函数，传入的参数是针对服务端的json编解码 器。</p><p>然后是实现json版本的客户端:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    conn, err: = net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;net.Dial:&quot;</span>, err)<br>    &#125;<br>    client: = rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))<br>    <span class="hljs-keyword">var</span> reply <span class="hljs-type">string</span><br>    err = client.Call(<span class="hljs-string">&quot;HelloService.Hello&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, &amp;reply)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    fmt.Println(reply)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在确保客户端可以正常调用RPC服务的方法之后，我们用一个 普通的TCP服务代替Go语言版本的RPC服务，这样可以查看客 户端调用时发送的数据格式。<strong>比如通过nc命令 nc -l 1234 在 同样的端口启动一个TCP服务。</strong></p></li><li><p>在获取到RPC调用对应的json数据后，我们可以通过直接向架 设了RPC服务的TCP服务器发送json数据模拟RPC方法调用:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">$ echo -e &#x27;&#123;<span class="hljs-string">&quot;method&quot;</span>:<span class="hljs-string">&quot;HelloService.Hello&quot;</span>,<span class="hljs-string">&quot;params&quot;</span>:<br>[<span class="hljs-string">&quot;hello&quot;</span>],<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">1</span>&#125;&#x27; | <span class="hljs-type">nc</span> localhost <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure></li></ol><p>​   返回的结果也是一个json格式的数据:</p><p>​   { “id” : 1 , “result” : “hello:hello” , “error” : null }</p><p>因此无论采用何种语言，只要遵循同样的json结构，以同样的 流程就可以和Go语言编写的RPC服务进行通信。这样我们就实 现了跨语言的RPC。</p><ol start="10"><li><p>RPC的服务架设在“&#x2F;jsonrpc”路径，在处理函数中基于 http.ResponseWriter和http.Request类型的参数构造一个 io.ReadWriteCloser类型的conn通道。然后基于conn构建针对服 务端的json编码解码器。最后通过rpc.ServeRequest函数为每次 请求处理一次RPC方法调用。</p></li><li><p>Protobuf是Protocol Buffers的简称，它是Google公司开发的一种 数据描述语言，并于2008年对外开源。Protobuf刚开源时的定 位类似于XML、JSON等数据描述语言，通过附带工具生成代 码并实现将结构化数据序列化的功能。</p></li><li><p>Protobuf中最基本 的数据单元是message，是类似Go语言中结构体的存在。在 message中可以嵌套message或其它的基础数据类型的成员。</p></li><li><p>在XML或JSON等数据描述语言中，一般通过成员的名字来绑 定对应的数据。但是Protobuf编码却是通过成员的唯一编号来 绑定对应的数据，因此Protobuf编码后数据的体积会比较小， 但是也非常不便于人类查阅。我们目前并不关注Protobuf的编 码技术，最终生成的Go结构体可以自由采用JSON或gob等编码 格式，因此大家可以暂时忽略Protobuf的成员编码部分。</p><p>Protobuf核心的工具集是C++语言开发的，在官方的protoc编译 器中并不支持Go语言。要想基于上面的hello.proto文件生成相 应的Go代码，需要安装相应的插件。首先是安装官方的protoc 工具，可以从 <a href="https://github.com/google/protobuf/releases">https://github.com/google/protobuf/releases</a> 下载。 然后是安装针对Go语言的代码生成插件，可以通过 go get github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go 命令安装。</p><p>然后通过以下命令生成相应的Go代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">protoc --go_out=. hello.proto<br></code></pre></td></tr></table></figure><p>其中 go_out 参数告知protoc编译器去加载对应的protoc-gen- go工具，然后通过该工具生成代码，生成代码放到当前目录。 最后是一系列要处理的protobuf文件的列表。</p><p>这里只生成了一个hello.pb.go文件</p></li><li><p>其实用Protobuf定义语言无关的RPC服务接口 才是它真正的价值所在!</p></li><li><p>在protoc-gen-go内部已经集成了一个叫grpc的插件，可以 针对grpc生成代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">protoc --go_out=plugins=grpc:. hello.proto<br></code></pre></td></tr></table></figure><p>在生成的代码中多了一些类似HelloServiceServer、 HelloServiceClient的新类型。这些类型是为grpc服务的，并不 符合我们的RPC要求。</p><p>go_out&#x3D;plugins&#x3D;grpc 参数来生成grpc相关代码，否则只会针对 message生成相关代码。</p></li><li><p>因为Go语言的包只能静态导入，我们无法向已经安装的protoc- gen-go添加我们新编写的插件。我们将重新克隆protoc-gen-go 对应的main函数</p><p>我们将我们的可执行 程序命名为protoc-gen-go-netrpc，表示包含了nerpc插件</p><p>插件中的 plugins&#x3D;netrpc 指示启用内部 唯一的名为netrpc的netrpcPlugin插件。</p></li><li><p>rpc调用中的client.send方法调用是线程安全的，因此可以从多个Goroutine同时向同一 个RPC链接发送调用指令。</p></li><li><p><strong>反向RPC:<strong>通常的RPC是基于C&#x2F;S结构，RPC的服务端对应网络的服务 器，RPC的客户端也对应网络客户端。但是对于一些特殊场 景，比如在公司内网提供一个RPC服务，但是在外网无法链接 到内网的服务器。这种时候我们可以参考类似反向代理的技 术，</strong>首先从内网主动链接到外网的TCP服务器，然后基于TCP 链接向外网提供RPC服务</strong></p><p>反向RPC的内网服务将不再主动提供TCP监听服务，而是首先 主动链接到对方的TCP服务器。然后基于每个建立的TCP链接 向对方提供RPC服务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    rpc.Register(<span class="hljs-built_in">new</span>(HelloService))<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, _: = net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:1234&quot;</span>)<br>        <span class="hljs-keyword">if</span> conn == <span class="hljs-literal">nil</span> &#123;<br>            time.Sleep(time.Second)<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        rpc.ServeConn(conn)<br>        conn.Close()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而RPC客户端则需要在一个公共的地址提供一个TCP服务，用 于接受RPC服务器的链接请求:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    listener, err: = net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:1234&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;ListenTCP error:&quot;</span>, err)<br>    &#125;<br>    clientChan: = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> * rpc.Client)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            conn, err: = listener.Accept()<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                log.Fatal(<span class="hljs-string">&quot;Accept error:&quot;</span>, err)<br>            &#125;<br>            clientChan &lt; -rpc.NewClient(conn)<br>        &#125;<br>    &#125;()<br>    doClientWork(clientChan)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>RPC是远程函数调用，因此每次调用的函数参数和返回值不能 太大</strong>，否则将严重影响每次调用的响应时间。因此传统的RPC 方法调用对于上传和下载较大数据量场景并不适合。</p><p><strong>RPC模式也不适用于对时间不确定的订阅和发布模式。</strong>为此， GRPC框架针对服务器端和客户端分别提供了流特性。</p><p><strong>服务端或客户端的单向流是双向流的特例</strong>。我们在 HelloService增加一个支持双向流的Channel方法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">rpc Channel (stream String) returns (stream String);<br></code></pre></td></tr></table></figure><p>关键字stream指定启用流特性，参数部分是接收客户端参数的 流，返回值是返回给客户端的流。</p></li><li><p><strong>GRPC建立在HTTP&#x2F;2协议之上，对TLS提供了很好的支持。我 们前面章节中GRPC的服务都没有提供证书支持，因此客户端 在链接服务器中通过 grpc.WithInsecure() 选项跳过了对服务 器证书的验证。</strong>没有启用证书的GRPC服务在和客户端进行的 是明文通讯，信息面临被任何第三方监听的风险。为了保障 GRPC通信不被第三方监听篡改或伪造，我们可以对服务器启 动TLS加密特性。</p><p>可以将生成server.key、server.crt、client.key和client.crt四 个文件。其中以.key为后缀名的是私钥文件，需要妥善保管。 以.crt为后缀名是证书文件，也可以简单理解为公钥文件，并 不需要秘密保存。在subj参数中的 &#x2F;CN&#x3D;server.grpc.io 表示服 务器的名字为 server.grpc.io ，在验证服务器的证书时需要 用到该信息。</p><p>服务端代码就写成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">creds, err := credentials.NewServerTLSFromFile(<br>  <span class="hljs-string">&quot;server.crt&quot;</span> ,  <span class="hljs-string">&quot;server.key&quot;</span> )<br></code></pre></td></tr></table></figure></li></ol><p>​  客户端代码写成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">creds, err := credentials.NewClientTLSFromFile(<br>          <span class="hljs-string">&quot;server.crt&quot;</span> ,  <span class="hljs-string">&quot;server.grpc.io&quot;</span> ,<br>     )<br></code></pre></td></tr></table></figure><p>其中redentials.NewClientTLSFromFile是构造客户端用的证书对 象，第一个参数是服务器的证书文件，第二个参数是签发证书 的服务器的名字。</p><ol start="21"><li><p>如果截取器函数返回了错误，那么该次GRPC方法调用将被视 作失败处理。因此，我们可以在截取器中对输入的参数做一些 简单的验证工作。同样，也可以对handler返回的结果做一些验 证工作。截取器也非常适合前面对Token认证工作。</p></li><li><p>GRPC构建在HTTP&#x2F;2协议之上，因此我们可以将GRPC服务和 普通的Web服务架设在同一个端口之上。因为目前Go语言版本 的GRPC实现还不够完善，只有启用了TLS协议之后才能将GRPC和Web服务运行在同一个端口。</p><p>因为GRPC服务已经实现了ServeHTTP方法，可以直接作为 Web路由处理对象。如果将GRPC和Web服务放在一起，会导 致GRPC和Web路径的冲突，在处理时我们需要区分两类服 务。</p><p>我们可以通过以下方式生成同时支持Web和GRPC协议的路由 处理函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">grpcServer.ServeHTTP(w, r)  <span class="hljs-comment">// GRPC Server</span><br></code></pre></td></tr></table></figure></li><li><p>GRPC服务一般用于集群内部通信，如果需要对外暴露服务一 般会提供等价的REST接口。通过REST接口比较方便前端 JavaScript和后端交互.通 过RegisterRestServiceHandlerFromEndpoint函数将RestService服 务相关的REST接口中转到后面的GRPC服务。</p></li><li><p>Protobuf本身具有反射功能，可以在运行时获取对象的Proto文 件。grpc同样也提供了一个名为reflection的反射包，用于为 grpc服务提供查询。GRPC官方提供了一个C++实现的grpc_cli 工具，可以用于查询GRPC列表或调用GRPC方法。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言高级编程-第5章go和web</title>
    <link href="/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC5%E7%AB%A0go%E5%92%8Cweb/"/>
    <url>/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC5%E7%AB%A0go%E5%92%8Cweb/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go语言高级编程系列是我读《Go语言高级编程》时的一些要点总结。</p></blockquote><ol><li><p>因为Go的 net&#x2F;http 包提供了基础的路由函数组合与丰富的功 能函数。所以在社区里流行一种用Go编写api不需要框架的观点;在我们看来，如果你的项目的路由在个位数、URI 固定且 不通过 URI 来传递参数，那么确实使用官方库也就足够。</p></li><li><p>只要你的路由带有参数，并且 这个项目的 api 数目超过了 10，就尽量不要使用 net&#x2F;http 中默 认的路由。</p></li><li><p>在常见的 web 框架中，router 是必备的组件。golang 圈子里 router 也时常被称为 http 的 multiplexer。在上一节中我们通过 对 Burrow 代码的简单学习，已经知道如何用 http 标准库中内 置的 mux 来完成简单的路由功能了。</p></li><li><p>restful 中常见的请求路径:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-title class_">GET</span> /repos/<span class="hljs-symbol">:owner/</span><span class="hljs-symbol">:repo/comments/</span><span class="hljs-symbol">:id/reactions</span><br><span class="hljs-title class_">POST</span> /projects/<span class="hljs-symbol">:project_id/columns</span><br><span class="hljs-title class_">PUT</span> /user/starred/<span class="hljs-symbol">:owner/</span><span class="hljs-symbol">:repo</span><br><span class="hljs-title class_">DELETE</span> /user/starred/<span class="hljs-symbol">:owner/</span><span class="hljs-symbol">:repo</span><br></code></pre></td></tr></table></figure><p>restful 风格的 API 重度依赖请求路径。会将很 多参数放在请求 URI 中。除此之外还会使用很多并不那么常 见的 HTTP 状态码，</p></li><li><p>较流行的开源 golang web 框架大多使用 httprouter，或是基于 httprouter 的变种对路由进行支持。前面提到的 github 的参数 式路由在 httprouter 中都是可以支持的。</p><p>因为 httprouter 中使用的是显式匹配，所以在设计路由的时候 需要规避一些会导致路由冲突的情况，例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">conflict:<br>  GET /user/info/:name<br>  GET /user/:id<br>  no conflict:<br>  GET /user/info/:name<br>  POST /user/:id<br></code></pre></td></tr></table></figure><p>简单来讲的话，如果两个路由拥有一致的 http method (指 GET&#x2F;POST&#x2F;PUT&#x2F;DELETE) 和请求路径前缀，且在某个位置出 现了 A 路由是 wildcard (指 :id 这种形式) 参数，B 路由则是普 通字符串，那么就会发生路由冲突。</p><p>因为 httprouter 考虑到字典树的深度，在 初始化时会对参数的数量进行限制，所以在路由中的参数数目 不能超过 255，否则会导致 httprouter 无法识别后续的参数。</p><p>除支持路径中的wildcard参数之外，httprouter还可以支持 <em>号来进行通配，不过</em> 号开头的参数只能放在路由的结尾， 例如下面这样:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Pattern: <span class="hljs-regexp">/src/</span>*filepath<br></code></pre></td></tr></table></figure></li><li><p>除了正常情况下的路由支持，httprouter 也支持对一些特殊情 况下的回调函数进行定制，例如 404 的时候</p><p>目前开源界最为流行(star 数最多)的 web 框架 gin 使用的就是 httprouter 的变种。</p></li><li><p>httprouter 和众多衍生 router 使用的数据结构被称为 radix tree， 压缩字典树。读者可能没有接触过压缩字典树，但对字典树 trie tree 应该有所耳闻。</p></li><li><p>我们犯的最大的错误是把业务代码和非业务代码揉在 了一起。对于大多数的场景来讲，非业务的需求都是在 http 请 求处理前做一些事情，或者&#x2F;并且在响应完成之后做一些事 情。一个middleware可以类似这样写，注意<code>next.ServeHTTP(wr, r)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">hello</span><span class="hljs-params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;<br>      wr.Write([] <span class="hljs-type">byte</span> ( <span class="hljs-string">&quot;hello&quot;</span> ))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">timeMiddleware</span><span class="hljs-params">(next http.Handler)</span></span> http.Handler &#123;<br>       <span class="hljs-keyword">return</span>                    <span class="hljs-function"><span class="hljs-keyword">func</span></span><br>          timeStart := time.Now()<br>           <span class="hljs-comment">// next handler</span><br>          next.ServeHTTP(wr, r)<br>          timeElapsed := time.Since(timeStart)<br>          logger.Println(timeElapsed)<br>      &#125;)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> http.Handle(<br><span class="hljs-string">&quot;/&quot;</span><br> , timeMiddleware(http.HandlerFunc(hello)))<br>err := http.ListenAndServe( <span class="hljs-string">&quot;:8080&quot;</span> ,  <span class="hljs-literal">nil</span> )<br>...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一般为了验证请求是否正确，我们得为每一个 http 请求都去写这么一套差不多的 validate 函数，有没有更好的办法来帮助我们解除这项体力劳 动?答案就是 validator。</p><p>这里我们引入一个新的 validator 库:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>   <span class="hljs-string">&quot;gopkg.in/go-playground/validator.v9&quot;</span><br><span class="hljs-keyword">type</span> RegisterReq <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 字符串的 gt=0 表示长度必须 &gt; 0，gt = greater than</span><br>Username <span class="hljs-type">string</span> <span class="hljs-string">`validate:&quot;gt=0&quot;`</span> <span class="hljs-comment">// 同上</span><br>PasswordNew <span class="hljs-type">string</span> <span class="hljs-string">`validate:&quot;gt=0&quot;`</span> <span class="hljs-comment">// eqfield 跨字段相等校验</span><br>      PasswordRepeat   <span class="hljs-type">string</span><br>  <span class="hljs-string">`validate:&quot;eqfield=PasswordNew&quot;`</span><br><span class="hljs-comment">// 合法 email 格式校验</span><br>Email   <span class="hljs-type">string</span> <span class="hljs-string">`validate:&quot;email&quot;`</span><br>&#125;<br><br><br>  <span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">validate</span><span class="hljs-params">(req RegisterReq)</span></span> <span class="hljs-type">error</span> &#123;<br>      err := validate.Struct(mystruct)<br>       <span class="hljs-keyword">if</span>  err !=  <span class="hljs-literal">nil</span>  &#123;<br>          doSomething()<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意下面函数写法，对于reflect</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validate</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span> &#123;&#125;)</span></span>(<span class="hljs-type">bool</span>, <span class="hljs-type">string</span>) &#123;<br>    validateResult: = <span class="hljs-literal">true</span><br>    errmsg: = <span class="hljs-string">&quot;success&quot;</span><br>    vt: = reflect.TypeOf(v)<br>    vv: = reflect.ValueOf(v)<br>    <span class="hljs-keyword">for</span> i: = <span class="hljs-number">0</span>;i &lt; vv.NumField();i++&#123;<br>        fieldVal: = vv.Field(i)<br>        tagContent: = vt.Field(i).Tag.Get(<span class="hljs-string">&quot;validate&quot;</span>)<br>        k: = fieldVal.Kind()<br>        <span class="hljs-keyword">switch</span> k &#123;<br>            <span class="hljs-keyword">case</span> reflect.String:<br>                val: = fieldVal.String() tagValStr: = tagContent<br>                <span class="hljs-keyword">switch</span> tagValStr &#123;<br><br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;email&quot;</span>:<br>                        nestedResult: = validateEmail(val)<br>                        <span class="hljs-keyword">if</span> nestedResult == <span class="hljs-literal">false</span> &#123;<br>                            errmsg =<br>                                <span class="hljs-string">&quot;validate mail failed, field val is: &quot;</span> + val<br>                            validateResult = <span class="hljs-literal">false</span><br>                        &#125;<br>                &#125;<br>            <span class="hljs-keyword">case</span> reflect.Struct:<br>                <span class="hljs-comment">// 如果有内嵌的 struct，那么深度优先遍历 // 就是一个递归过程</span><br>                valInter: = fieldVal.Interface() nestedResult, msg: = validate(valInter) <span class="hljs-keyword">if</span> nestedResult == <span class="hljs-literal">false</span> &#123;<br>                    validateResult = <span class="hljs-literal">false</span><br>                    errmsg = msg<br>                &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> validateResult,<br>    errmsg<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>我们对 struct 进行 validate 时大量使用了 reflect，而 go 的 reflect 在性 能上不太出众，有时甚至会影响到我们程序的性能。这样的考 虑确实有一些道理，但需要对 struct 进行大量校验的场景往往 出现在 web 服务，这里并不一定是程序的性能瓶颈所在，实 际的效果还是要从 pprof 中做更精确的判断。</p></li><li><p>Go官方提供了 database&#x2F;sql 包来给用户进行和数据库打交道 的工作，实际上 database&#x2F;sql 库就只是提供了一套操作数据 库的接口和规范，例如抽象好的 sql 预处理(prepare)，连接池 管理，数据绑定，事务，错误处理等等。官方并没有提供具体 某种数据库实现的协议支持。</p><p><strong>和具体的数据库，例如 MySQL 打交道，还需要再引入 MySQL 的驱动，像下面这样</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>   <span class="hljs-string">&quot;database/sql&quot;</span><br><span class="hljs-keyword">import</span>  _  <span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span><br></code></pre></td></tr></table></figure><p>这一句 import，实际上是调用了 mysql 包的 init 函数，做的事 情也很简单:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    sql.Register( <span class="hljs-string">&quot;mysql&quot;</span> , &amp;MySQLDriver&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意读取出来内容后，必须要把 rows 里的内容读完，否则<strong>连接</strong>永远不会释放</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"> rows, err := db.Query(<br><span class="hljs-string">&quot;select id, name from users where id = ?&quot;</span> ,  <span class="hljs-number">1</span> )<br>     <span class="hljs-keyword">if</span>  err !=  <span class="hljs-literal">nil</span>  &#123;<br>        log.Fatal(err)<br>    &#125;<br>     <span class="hljs-keyword">defer</span>  rows.Close()<br><span class="hljs-comment">// 必须要把 rows 里的内容读完，否则连接永远不会释放 </span><br><span class="hljs-keyword">for</span> rows.Next() &#123;<br></code></pre></td></tr></table></figure></li><li><p>在 web 开发领域常常提到的 ORM 是什么?我们先看看万能的 维基百科:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">对象关系映射(英语:<span class="hljs-keyword">Object</span> Relational <span class="hljs-keyword">Mapping</span>，简称ORM，或O/RM，或 O/R <span class="hljs-keyword">mapping</span>)，<br>是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。<br>从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。<br></code></pre></td></tr></table></figure><p>最为常见的 ORM 实际上做的是从 db -&gt; 程序的 class &#x2F; struct 这 样的映射。所以你手边的程序可能是从 mysql 的表 -&gt; 你的程 序内 class。</p><p> ORM 的目的就是屏蔽掉DB 层，实际上很多语言的 ORM 只要把你的 class&#x2F;struct 定义好， 再用特定的语法将结构体之间的一对一或者一对多关系表达出 来。那么任务就完成了。然后你就可以对这些映射好了数据库 表的对象进行各种操作，例如 save，create，retrieve，delete。 至于 orm在背地里做了什么阴险的勾当，你是不一定清楚的。</p><p>ORM 一类的工具在出发点上就是屏蔽 sql，让我们对数据 库的操作更接近于人类的思维方式。</p></li><li><p>有些 orm 背后隐藏了非常难以察觉的细节， 那就是生成的 sql 语句会自动 limit 1000。喜欢强类型语言的人一般都不喜欢语 言隐式地去做什么事情，例如各种语言在赋值操作时进行的隐 式类型转换然后又在转换中丢失了精度的勾当，一定让你非常 的头疼。所以一个程序库背地里做的事情还是越少越好，如果 一定要做，那也一定要在显眼的地方做。比如上面的例子，去 掉这种默认的自作聪明的行为，或者要求用户强制传入 limit 参数都是更好的选择。orm 想从设计上隐去太多的细 节。而方便的代价是其背后的运行完全失控。</p></li><li><p>相比 ORM 来说，sql builder 在 sql 和项目可维护性之间取得了 比较好的平衡。首先 sql builer 不像 ORM 那样屏蔽了过多的细 节，其次从开发的角度来讲，sql builder 简单进行封装后也可 以非常高效地完成开发，举个例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">where :=  <span class="hljs-keyword">map</span> [ <span class="hljs-type">string</span> ] <span class="hljs-keyword">interface</span> &#123;&#125; &#123;<br>      <span class="hljs-string">&quot;order_id &gt; ?&quot;</span>  :  <span class="hljs-number">0</span> ,<br>      <span class="hljs-string">&quot;customer_id != ?&quot;</span>  :  <span class="hljs-number">0</span> ,<br> &#125;<br> limit := [] <span class="hljs-type">int</span> &#123; <span class="hljs-number">0</span> , <span class="hljs-number">100</span> &#125;<br> orderBy := [] <span class="hljs-type">string</span> &#123; <span class="hljs-string">&quot;id asc&quot;</span> ,  <span class="hljs-string">&quot;create_time desc&quot;</span> &#125;<br> orders := orderModel.GetList(where, limit, orderBy)<br></code></pre></td></tr></table></figure><p>说白了 sql builder 是 sql 在代码里的一种特殊方言，如果你们 没有DBA但研发有自己分析和优化 sql 的能力，或者你们公司 的 dba 对于学习这样一些 sql 的方言没有异议。那么使用 sql builder 是一个比较好的选择，不会导致什么问题。</p></li><li><p>所以现如今，大型的互联网公司核心线上业务都会在代码中把 sql 放在显眼的位置提供给 DBA review，以此来控制系统在数 据层的风险。</p></li><li><p>web 系统打交道最多的是网络，无论是接收，解析用户请求， 访问存储，还是把响应数据返回给用户，都是要走网络的。在 没有 epoll&#x2F;kqueue 之类的系统提供的 IO 多路复用接口之前， 多个核心的现代计算机最头痛的是 C10k 问题，C10k 问题会导 致计算机没有办法充分利用 CPU 来处理更多的用户连接，进 而没有办法通过优化程序提升 CPU 利用率来处理更多的请 求。</p><p>自从 linux 实现了 epoll，freebsd 实现了 kqueue，这个问题基 本解决了，我们可以借助内核提供的 API 轻松解决当年的 C10k 问题，<strong>也就是说如今如果你的程序主要是和网络打交 道，那么瓶颈一定在用户程序而不在操作系统内核。</strong></p></li><li><p>Go 的 net 库针对不同平台封装了不同的 syscall API，http 库又是构建 在 net 库之上，所以在 Go 我们可以借助标准库，很轻松地写 出高性能的 http 服务，</p></li><li><p>如果 碰到业务逻辑复杂代码量巨大的模块，其瓶颈并不是三下五除 二可以推测出来的，还是需要从压力测试中得到更为精确的结 论。</p></li><li><p>对于 IO&#x2F;Network bound 类的程序，其表现是网卡&#x2F;磁盘 IO 会先 于 CPU 打满，这种情况即使优化 CPU 的使用也不能提高整个 系统的吞吐量，<strong>只能提高磁盘的读写速度，增加内存大小</strong>，提 升网卡的带宽来提升整体性能。而 CPU bound 类的程序，则 是在存储和网卡未打满之前 CPU 占用率提前到达 100%，CPU 忙于各种计算任务，IO 设备相对则较闲。</p><p>无论哪种类型的服务，在资源使用到极限的时候都会导致请求 堆积，超时，系统 hang 死，最终伤害到终端用户。对于分布 式的 web 服务来说，瓶颈还不一定总在系统内部，也有可能 在外部。非计算密集型的系统往往会在关系型数据库环节失 守，而这时候 web 模块本身还远远未达到瓶颈。</p><p>不管我们的服务瓶颈在哪里，最终要做的事情都是一样的，那就是流量限制。</p></li><li><p>流量限制的手段有很多，最常见的:漏桶、令牌桶两种</p></li><li><p>QoS 全称是 Quality of Service，顾名思义是服务质 量。QoS 包含有可用性、吞吐量、时延、时延变化和丢失等指 标。一般来讲我们可以通过优化系统，来提高 web 服务的 CPU 利用率，从而提高整个系统的吞吐量。</p></li><li><p>流行的 web 框架大多数是 MVC 框架，MVC 这个概念最早由 Trygve Reenskaug 在 1978 年提出，为了能够对 GUI 类型的应 用进行方便扩展，将程序划分为:</p><ol><li>控制器(Controller)- 负责转发请求，对请求进行处理。</li><li>视图(View)-界面设计人员进行图形界面设计。</li><li>模型(Model)-程序员编写程序应有的功能(实现算法等等)、数据库专家进行数据管理和数据库设计(可以实现 具体的功能)。</li></ol><p>随着时代的发展，前端也变成了越来越复杂的工程，为了更好 地工程化，现在更为流行的一般是前后分离的架构。前后端之间通过 ajax 来交 互，有时候要解决跨域的问题</p></li><li><p>业务流程也算是一种“模型”，是对 真实世界用户行为或者既有流程的一种建模，并非只有按格式 组织的数据才能叫模型</p></li><li><p>现在比较流行的 纯后端 api 模块一般采用下述划分方法:</p><ol><li><p>Controller，与上述类似，服务入口，负责处理路由，参数 校验，请求转发。</p></li><li><p>Logic&#x2F;Service，逻辑(服务)层，一般是业务逻辑的入口，可 以认为从这里开始，所有的请求参数一定是合法的。业务 逻辑和业务流程也都在这一层中。常见的设计中会将该层 称为 Business Rules。</p></li><li><p>DAO&#x2F;Repository，这一层主要负责和数据、存储打交道。 将下层存储以更简单的函数、接口形式暴露给 Logic 层来 使用。负责数据的持久化工作。</p></li></ol><p>可以认为，我 们的代码运行到 controller 层之后，就没有任何与“协议”相关 的代码了。在这里你找不到 http.Request，也找不到 http.ResponseWriter，也找不到任何与 thrift 或者 gRPC 相关的 字眼。</p></li><li><p>我们的外部依赖总是为了自己爽而不断地做升级，且不想做向前兼容</p></li><li><p>非实时的统计类系统，那么就没有必 要在主流程里为每一套系统做一套 RPC 流程。我们只要将下 游需要的数据打包成一条消息，传入消息队列，之后的事情与 主流程一概无关</p></li><li><p>一件事情本身变的复杂的话，这时候拆解和异步化就不灵了。我们还是要对事情本身进行一定程度的封装抽象。</p></li><li><p>引入 interface 对 我们的系统本身是否有意义，这是要按照场景去进行分析的。 假如我们的系统只服务一条产品线，并且内部的代码只是针对 很具体的场景进行定制化开发，那么实际上引入 interface 是不 会带来任何收益的。</p></li><li><p>当我们接手了一个 几十万行的系统时，如果看到定义了很多 interface，例如订单 流程的 interface，<strong>我们希望能直接找到这些 interface 都被哪些 对象实现了。但直到现在，这个简单的需求也就只有 goland 实现了，</strong>并且体验尚可。</p></li><li><p>熟悉开源 lint 工具的同学应该见到过圈复杂度的说法，<strong>在函数 中如果有 if 和 switch 的话，会使函数的圈复杂度上升。</strong>所以 有强迫症的同学即使在入口一个函数中有 switch，还是想要干 掉这个 switch，有没有什么办法呢?当然有，用表驱动的方式 来存储我们需要实例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">entry</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> bi BusinessInstance<br>    <span class="hljs-keyword">switch</span> businessType &#123;<br>        <span class="hljs-keyword">case</span> TravelBusiness:<br>            bi = travelorder.New()<br>        <span class="hljs-keyword">case</span> MarketBusiness:<br>            bi = marketorder.New()<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;not supported business&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以修改为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> businessInstanceMap = <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>] BusinessInstance &#123;<br>    TravelBusiness: travelorder.New(),<br>    MarketBusiness: marketorder.New(),<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">entry</span><span class="hljs-params">()</span></span> &#123;<br>    bi: = businessInstanceMap[businessType]<br>&#125;<br></code></pre></td></tr></table></figure><p>table driven 的设计方式，很多设计模式相关的书籍并没有把它 作为一种设计模式来讲，但我认为这依然是一种非常重要的帮 助我们来简化代码的手段。在日常的开发工作中可以多多思 考，<strong>不必要的 switch case 可以用一个字典和一行代码就可 以轻松搞定。</strong></p></li><li><p>灰度非常重要，灰度发布也称为金丝雀 发布。互联网系统的灰度发布一般通过两种方式实现:</p><ol><li>通过分批次部署实现灰度发布 2. 通过业务规则进行灰度发布</li></ol><p>在对系统的旧功能进行升级迭代时，第一种方式用的比较多。新功能上线时，第二种方式用的比较多。当然，对比较重要的老功能进行较大幅度的修改时，一般也会选择按业务规则来进行发布，因为直接全量开放给所有用户风险实在太大。</p></li><li><p>假如服务部署在 15 个实例(可能是物理机，也可能是容器) 上，我们把这 7 个实例分为三组，按照先后顺序，分别有 1-2- 4-8 台机器，保证每次扩展时大概都是二倍的关系。为什么要用 2 倍?这样能够保证我们不管有多少台机器，都不 会把组划分得太多。例如 1024 台机器，实际上也就只需要 1- 2-4-8-16-32-64-128-256-512 部署十次就可以全部部署完毕。</p></li><li><p>在上线时，最有效的观察手法是查看程序的错误日志，如果较 明显的逻辑错误，一般错误日志的滚动速度都会有肉眼可见的 增加。</p></li><li><p><strong>map 的查询比数组稍慢，但扩展会灵活一 些</strong></p></li><li><p>求哈希可用的算法非常多，比如 md5，crc32，sha1 等等，但 我们这里的目的只是为了给这些数据做个映射，并不想要因为 计算哈希消耗过多的 cpu，所以现在业界使用较多的算法是 murmurhash，下面是我们对这些常见的 hash 算法的简单benchmark</p><p>hash.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span><br><span class="hljs-keyword">import</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;crypto/md5&quot;</span><br><span class="hljs-string">&quot;crypto/sha1&quot;</span><br><span class="hljs-string">&quot;github.com/spaolacci/murmur3&quot;</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">md5Hash</span><span class="hljs-params">()</span></span>[<span class="hljs-number">16</span>] <span class="hljs-type">byte</span> &#123;<br>    <span class="hljs-keyword">return</span> md5.Sum([] <span class="hljs-type">byte</span>(str))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sha1Hash</span><span class="hljs-params">()</span></span>[<span class="hljs-number">20</span>] <span class="hljs-type">byte</span> &#123;<br>    <span class="hljs-keyword">return</span> sha1.Sum([] <span class="hljs-type">byte</span>(str))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">murmur32</span><span class="hljs-params">()</span></span> <span class="hljs-type">uint32</span> &#123;<br>    <span class="hljs-keyword">return</span> murmur3.Sum32([] <span class="hljs-type">byte</span>(str))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">murmur64</span><span class="hljs-params">()</span></span> <span class="hljs-type">uint64</span> &#123;<br>    <span class="hljs-keyword">return</span> murmur3.Sum64([] <span class="hljs-type">byte</span>(str))<br>&#125;<br></code></pre></td></tr></table></figure><p>hash_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMD5</span><span class="hljs-params">(b * testing.B)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i: = <span class="hljs-number">0</span>;<br>    i &lt; b.N;<br>    i++&#123;<br>        md5Hash()<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSHA1</span><span class="hljs-params">(b * testing.B)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i: = <span class="hljs-number">0</span>;<br>    i &lt; b.N;<br>    i++&#123;<br>        sha1Hash()<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMurmurHash32</span><span class="hljs-params">(b * testing.B)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i: = <span class="hljs-number">0</span>;<br>    i &lt; b.N;<br>    i++&#123;<br>        murmur32()<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMurmurHash64</span><span class="hljs-params">(b * testing.B)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i: = <span class="hljs-number">0</span>;<br>    i &lt; b.N;<br>    i++&#123;<br>        murmur64()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>~&#x2F;t&#x2F;g &#x2F; hash_bench git: master❯❯❯ go test - bench &#x3D; .goos: darwin<br>goarch: amd64<br>BenchmarkMD5 - 4<br>BenchmarkSHA1 - 4<br>BenchmarkMurmurHash32 - 4<br>BenchmarkMurmurHash64 - 4<br>PASS</p><p>10000000<br>10000000<br>50000000<br>20000000<br>180 ns &#x2F; op<br>211 ns &#x2F; op<br>25.7 ns &#x2F; op<br>66.2 ns &#x2F; op<br>7.050 s<br>ok _ &#x2F; Users &#x2F; caochunhui &#x2F; test &#x2F; go &#x2F; hash_bench</p></blockquote></li></ol><p>​  可见 murmurhash 相比其它的算法有三倍以上的性能提升。</p><ol start="38"><li>对于哈希算法来说，性能是一方面的问题，另一方面还要考虑哈希后的值是否分布均匀。</li><li>web 甚至可以 不用非得基于 http 协议。<strong>只要是 CS 或者 BS 架构，都可以认 为是 web 系统。</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言高级编程-第6章 分布式系统</title>
    <link href="/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC6%E7%AB%A0%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC6%E7%AB%A0%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go语言高级编程系列是我读《Go语言高级编程》时的一些要点总结。</p></blockquote><ol><li>有时我们需要能够生成类似 MySQL 自增 ID 这样不断增大， 同时又不会重复的 id。以支持业务中的高并发场景。比较典型 的，电商促销时，短时间内会有大量的订单涌入到系统，比如 每秒 10w+。明星出轨时，会有大量热情的粉丝发微博以表心 意，同样会在短时间内产生大量的消息。</li></ol><p>在插入数据库之前，我们需要给这些消息&#x2F;订单先打上一个 ID，然后再插入到我们的数据库。对这个 id 的要求是希望其 中能带有一些时间信息，这样即使我们后端的系统对消息进行 了分库分表，也能够以时间顺序对这些消息进行排序。</p><p>Twitter 的 snowflake 算法是这种场景下的一个典型解法。首先确定我们的数值是 64 位，int64 类型，被划分为四部分， 不含开头的第一个 bit，因为这个 bit 是符号位。用 41 位来表 示收到请求时的时间戳，单位为毫秒，然后五位来表示数据中 心的 id，然后再五位来表示机器的实例 id，最后是 12 位的循 环自增 id(到达 1111 1111 1111 后会归 0)。一般不同数据中心的机器，会提供对应的获取数据中心 id 的 api</p><ol start="2"><li><p>在单机程序并发或并行修改全局变量时，需要对修改行为加锁以创造临界区</p></li><li><p>如果我们的逻辑限定每个 goroutine 只有成功执行了 Lock 才会 继续执行后续逻辑，因此在 Unlock 时可以保证 Lock struct 中 的 channel 一定是空，从而不会阻塞，也不会失败。这种方法可以叫trylock。</p></li></ol><p>在单机系统中，trylock 并不是一个好选择。因为大量的 goroutine 抢锁可能会导致 cpu 无意义的资源浪费。有一个专有 名词用来描述这种抢锁的场景:活锁。</p><p>活锁指的是程序看起来在正常执行，但实际上 cpu 周期被浪费 在抢锁，而非执行任务上，从而程序整体的执行效率低下。<strong>活 锁的问题定位起来要麻烦很多。所以在单机场景下，不建议使 用这种锁。</strong></p><ol start="4"><li><p>redis 的 setnx 很适合在高并发场景下，用来争抢一些“唯一”的资源。</p></li><li><p>基于 zk 的锁与基于 redis 的锁的不同之处在于 Lock 成功之前 会一直阻塞，这与我们单机场景中的 mutex.Lock 很相似。</p></li><li><p>业务发展到一定量级的话，就需要从多方面来考虑了。首先是 你的锁是否在任何恶劣的条件下都不允许数据丢失，如果不允 许，那么就不要使用 redis 的 setnx 的简单锁。</p><p>对锁数据的可靠性要求极高的话，那只能使用 etcd 或者 zk 这 种通过一致性协议保证数据可靠性的锁方案。但可靠的背面往 往都是较低的吞吐量和较高的延迟。</p></li><li><p>定时器英文为 timer</p></li><li><p>实现timer，最常见的时间堆一般用小顶堆实现，小顶堆其实就是一种特殊的二叉树。小顶堆的好处是什么呢?实际上对于定时器来说，如果堆顶元 素比当前的时间还要大，那么说明堆内所有元素都比当前时间 大。进而说明这个时刻我们还没有必要对时间堆进行任何处 理。所以对于定时 check 来说，时间复杂度是 O(1) 的。当我们发现堆顶的元素 &lt; 当前时间时，那么说明可能已经有一 批事件已经开始过期了，这时进行正常的弹出和堆调整操作就 好。当我们发现堆顶的元素 &lt; 当前时间时，那么说明可能已经有一 批事件已经开始过期了，这时进行正常的弹出和堆调整操作就 好。每一次堆调整的时间复杂度都是 O(LgN)。</p></li><li><p><strong>在 web 一章中，我们提到 MySQL 很脆弱。数据库系统本身要 保证实时和强一致性，所以其功能设计上都是为了满足这种一 致性需求。</strong></p><p>关系型数据库一般被用于实现 OLTP 系统，所谓 OLTP，援引 wikipedia:</p><p>在线交易处理(OLTP, Online transaction processing)是指 透过信息系统、电脑网络及数据库，以线上交易的方式处 理一般即时性的作业数据，和更早期传统数据库系统大量 批量的作业方式并不相同。OLTP通常被运用于自动化的 数据处理工作，如订单输入、金融业务…等反复性的日常 性交易活动。和其相对的是属于决策分析层次的联机分析 处理(OLAP)。</p><p>如果我们所经营的是一个大型电商，根据关键字进行一次 like 查询，可能整个 MySQL 就直接挂掉了。<strong>这时候我们就需要搜索引擎来救场了。</strong></p></li><li><p>elasticsearch 是开源分布式搜索引擎的霸主，其依赖于 Lucene 实现，在部署和运维方面做了很多优化。当今搭建一个分布式 搜索引擎比起 Sphinx 的时代已经是容易很多很多了。只要简 单配置客户端 ip 和端口就可以了。实际应用 中常常用 es 来作为 database 来使用，就是因为倒排列表的特 性。</p></li><li><p>json 本身是可以表达树形结构的，我们的程序代码在被编译器parse 之后，也会变成 AST，而 AST 抽象语法树，顾名思义， 就是树形结构。理论上 json 能够完备地表达一段程序代码被 parse 之后的结果。这里的 Boolean Expression 被编译器 Parse 之后也会生成差不多的树形结构，而且只是整个编译器实现的 一个很小的子集。</p></li><li><p>在实际应用中，我们很少直接向搜索引擎中写入数据。更为常 见的方式是，将 MySQL 或其它关系型数据中的数据同步到搜 索引擎中。<strong>而搜索引擎的使用方只能对数据进行查询，无法进 行修改和删除。</strong></p></li><li><p>没有随机种子。在没有随机种子的情况下，rand.Intn 返回的伪随机数序列是固定的。</p></li><li><p>比如我们为了对去下游 的流量进行限制，在内存中堆积一些数据，并对堆积设定时 间&#x2F;总量的阈值。在任意阈值达到之后将数据统一发送给下 游，以避免频繁的请求超出下游的承载能力而将下游打垮。这 种情况下重启要做到优雅就比较难了。所以我们的目标还是尽量避免采用或者绕过上线的方式，对线上程序做一些修改。比较典型的修改内容就是程序的配置项。</p></li><li><p>为了快速止损，最快且最有效 的办法就是进行版本管理，并支持按版本回滚。</p></li><li><p>使用 MySQL 来存储配置文件&#x2F;字符串的不同版 本内容，在需要回滚时，只要进行简单的查询即可。</p></li><li><p>在给业务提供配置读取的 sdk 时，最好能够将拿到 的配置在业务机器的磁盘上也缓存一份。这样远程配置中心不 可用时，可以直接用硬盘上的内容来做兜底。当重新连接上配 置中心时，再把相应的内容进行更新。</p><p>加入缓存之后务必需要考虑的是数据一致性问题，当个别业务机器因为网络错误而与其它机器配置不一致时，我们也应该能够从监控系统中知晓。</p></li><li><p>分布式爬虫是一套任务分发和执行系统。而常见的任务分发，因为上下游存在速度不匹配问题，必然要借助消息队列。</p></li><li><p>如果希望在分布式的消费端进行 任务的负载均衡，而不是所有人都收到同样的消息，那么就要 给消费端指定相同的 queue 名字。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言高级编程-第99章 附录</title>
    <link href="/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC99%E7%AB%A0%20%E9%99%84%E5%BD%95/"/>
    <url>/2021/12/04/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC99%E7%AB%A0%20%E9%99%84%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Go语言高级编程系列是我读《Go语言高级编程》时的一些要点总结。</p></blockquote><ol><li>当参数的可变参数是空接口类型时，传人空接口的切片时需要注意参数展开的问题。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a=[]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>      fmt.Println(a)<br>      fmt.Println(a...)<br>&#125;<br></code></pre></td></tr></table></figure><p>不管是否展开，编译器都无法发现错误，但是输出是不同的:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[1 2 3]</span> <br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>在函数调用参数中，数组是值传递，无法通过修改数组类型的参数返回结果。必要时需要使用切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    x: = [<span class="hljs-number">3</span>] <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arr[3] <span class="hljs-type">int</span>)</span></span> &#123;<br>      arr[<span class="hljs-number">0</span>] = <span class="hljs-number">7</span> <br>      fmt.Println(arr)<br>    &#125;(x)<br>    fmt.Println(x)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>recover</strong>必须在<strong>defer</strong>函数中运行</p><p><em>recover捕获的是祖父级调用时的异常，直接调用时无效:</em></p><p>必须在defer函数中直接调用才有效:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">  <span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>       <span class="hljs-keyword">defer</span>   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span> &#123;<br>           <span class="hljs-built_in">recover</span> ()<br>      &#125;()<br>  <span class="hljs-built_in">panic</span> ( <span class="hljs-number">1</span> )<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Goroutine是协作式抢占调度，Goroutine本身不会主动放弃CPU，可以在for循环加入runtime.Gosched()调度函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runtime.GOMAXPROCS(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i: = <span class="hljs-number">0</span>;<br>        i &lt; <span class="hljs-number">10</span>;<br>        i++&#123;<br>            fmt.Println(i)<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">for</span> &#123;<br>        runtime.Gosched()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者是通过阻塞的方式避免CPU占用:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    runtime.GOMAXPROCS(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i: = <span class="hljs-number">0</span>;<br>        i &lt; <span class="hljs-number">10</span>;<br>        i++&#123;<br>            fmt.Println(i)<br>        &#125;<br>        os.Exit(<span class="hljs-number">0</span>)<br>    &#125;()<br>    <span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>defer在函数退出时才能执行，在for执行defer会导致资源延迟 释放</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i: = <span class="hljs-number">0</span>;<br>    i &lt; <span class="hljs-number">5</span>;<br>    i++&#123;<br>        f, err: = os.Open(<span class="hljs-string">&quot;/path/to/file&quot;</span>)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Fatal(err)<br>        &#125;<br>        <span class="hljs-keyword">defer</span> f.Close()<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决的方法可以在for中构造一个局部函数，在局部函数内部 执行defer:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i: = <span class="hljs-number">0</span>;<br>    i &lt; <span class="hljs-number">5</span>;<br>    i++&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            f, err: = os.Open(<span class="hljs-string">&quot;/path/to/file&quot;</span>)<br><br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                log.Fatal(err)<br>            &#125;<br>            <span class="hljs-keyword">defer</span> f.Close()<br>        &#125;()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>切片会导致整个底层数组被锁定，底层数组无法释放内存。如果底层数组较大会对内存产生很大的压力。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    headerMap: = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][] <span class="hljs-type">byte</span>)<br>    <span class="hljs-keyword">for</span> i: = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++&#123;<br>        name: = <span class="hljs-string">&quot;/path/to/file&quot;</span><br>        data,<br>        err: = ioutil.ReadFile(name)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Fatal(err)<br>        &#125;<br>        headerMap[name] = data[: <span class="hljs-number">1</span>]<br>    &#125;<br>    <span class="hljs-comment">// do some thing</span><br>&#125;<br></code></pre></td></tr></table></figure><p>解决的方法是将结果克隆一份，这样可以释放底层的数组</p></li><li><p>空指针和空接口不等价。比如返回了一个错误指针，但是并不是空的error接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnsError</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">var</span> p * MyError = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">if</span> bad() &#123;<br>        p = ErrBad<br>    &#125;<br>    <span class="hljs-keyword">return</span> p <span class="hljs-comment">// Will always return a non-nil error.</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Go语言中对象的地址可能发生变化，因此指针不能从其它非 指针类型的值生成</p><p>当内存发送变化的时候，相关的指针会同步更新，但是非指针 类型的uintptr不会做同步更新。</p><p>同理CGO中也不能保存Go对象地址</p></li><li><p><strong>Goroutine</strong>泄露</p><p>Go语言是带内存自动回收的特性，因此内存一般不会泄漏。 但是Goroutine确存在泄漏的情况，同时泄漏的Goroutine引用的 内存同样无法被回收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch: = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &lt; -<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>        ch: = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">for</span> i: = <span class="hljs-number">0</span>;;i++&#123;<br>                ch &lt; -i<br>            &#125;<br>        &#125;()<br>        <span class="hljs-keyword">return</span> ch<br>    &#125;()<br>    <span class="hljs-keyword">for</span> v: = <span class="hljs-keyword">range</span> ch &#123;<br>        fmt.Println(v)<br>        <span class="hljs-keyword">if</span> v == <span class="hljs-number">5</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的程序中后台Goroutine向管道输入自然数序列，main函数 中输出序列。但是当break跳出for循环的时候，后台Goroutine 就处于无法被回收的状态了。</p><p><strong>我们可以通过context包来避免这个问题:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ctx, cancel: = context.WithCancel(context.Background())<br>    ch: = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &lt; -<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>        ch: = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>        <span class="hljs-keyword">go</span><br>        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">for</span> i: = <span class="hljs-number">0</span>;;<br>            i++&#123;<br>                <span class="hljs-keyword">select</span> &#123;<br>                    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>                        <span class="hljs-keyword">return</span><br>                    <span class="hljs-keyword">case</span> ch &lt; -i:<br>                &#125;<br>            &#125;<br>        &#125;()<br>        <span class="hljs-keyword">return</span> ch<br>    &#125;(ctx)<br>    <span class="hljs-keyword">for</span> v: = <span class="hljs-keyword">range</span> ch &#123;<br>        fmt.Println(v)<br>        <span class="hljs-keyword">if</span> v == <span class="hljs-number">5</span> &#123;<br>            cancel()<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当main函数在break跳出循环时，<strong>通过调用 cancel() 来通知后 台Goroutine退出，这样就避免了Goroutine的泄漏。</strong></p></li><li><p>随机数的一个特点是不好预测。如果一个随机数的输出是可以简单预测的，那么一般会称为伪随机数</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件读写方法整理</title>
    <link href="/2021/10/05/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <url>/2021/10/05/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">configFile, err := os.Open(f)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>fi, _ := configFile.Stat()<br><span class="hljs-keyword">if</span> fi.Size() == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;config file (%s) is empty&quot;</span>, f.dictionaryPath)<br>&#125;<br>buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, fi.Size())<br><span class="hljs-keyword">if</span> _, err := configFile.Read(buffer); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>dict := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-keyword">if</span> err := yaml.Unmarshal(buffer, &amp;dict); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p><strong>会在文件不存在的时候创建</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">logFile, err := <span class="hljs-built_in">os</span>.OpenFile(filename, <span class="hljs-built_in">os</span>.O_APPEND|<span class="hljs-built_in">os</span>.O_RDWR|<span class="hljs-built_in">os</span>.O_CREATE, <span class="hljs-number">0777</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">log</span>.Fatalw(<span class="hljs-string">&quot;new es log error&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>, err)<br>&#125;<br>logFile.Write([]<span class="hljs-built_in">byte</span>(<span class="hljs-string">&quot;xxxxx&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>postman查看完整http报文</title>
    <link href="/2021/04/09/postman%E6%9F%A5%E7%9C%8B%E5%AE%8C%E6%95%B4http%E6%8A%A5%E6%96%87/"/>
    <url>/2021/04/09/postman%E6%9F%A5%E7%9C%8B%E5%AE%8C%E6%95%B4http%E6%8A%A5%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p>一般是这样请求的</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h13lqgrhmhj31j0118n6t.jpg" alt="WeCom20220409-173106@2x.png"></p><p>比如想查看当前http版本等信息，点击View-&gt;Show Postman Console</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h13lr7u17yj30cy0cego4.jpg" alt="WeCom20220409-173405@2x.png"></p><p>在Console中选择Show raw log</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h13lsgu2vbj325a0eq7by.jpg" alt="WeCom20220409-173530@2x.png"></p><p>即可查看完整报文</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h13lt2orx3j32560fy7ab.jpg" alt="WeCom20220409-173604@2x.png"></p>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s核心概念总结</title>
    <link href="/2021/04/09/k8s%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/04/09/k8s%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是k8s？"><a href="#1-什么是k8s？" class="headerlink" title="1. 什么是k8s？"></a>1. 什么是k8s？</h2><p><strong>k8s是一个容器编排系统</strong></p><p>Kubernetes（k8s）是<strong>自动化容器操作的开源平台</strong>，<strong>Docker是Kubernetes内部使用的低级别组件</strong>。所以Kubernetes不仅仅支持Docker，还支持Rocket，这是另一种容器技术。</p><p>k8s配置非常简单，可以通过一个.yaml文件实现规则定义，所以可以先画部署图，然后将部署图翻译为yaml文件即可。</p><p>k8s上可以看到仪表盘，监控，日志，报警等等</p><p>k8s要求很多地方都要配置证书，很多时候k8s部署的时候是跨多云部署的，比如一个在aws，一个在google cloud上</p><p>k8s的功能如下：</p><ul><li>自动化容器的部署和复制</li><li>很多时候对服务器或者容器的操作都不可追溯，比如通过图形界面的操作。k8s可以解决操作不可追溯这一问题。</li><li>k8s可以动态变更队列大小，数量，当请求峰值时使队列变大，请求较少时使队列变小。</li><li>实现定时任务，比如每天晚上dump数据库进行备份</li><li>执行疑似性程序：所谓疑似性程序就是按需运行的程序，比如往etcd配置中心写数据</li><li>随时扩展或收缩容器规模</li><li>看流量追踪，比如流量先后经历了哪些节点</li><li>看日志</li><li><strong>将容器组织成组</strong>（组是一个新概念），并且提供容器间的负载均衡</li><li>很容易地升级应用程序容器的新版本</li><li>提供容器弹性，如果容器失效就替换它，等等…</li></ul><p>实际上，使用Kubernetes只需一个部署文件，使用和Kubernetes API交互的命令行程序kubectl的一条命令就可以部署多层容器（前端，后台等）的完整集群：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">kubectl <span class="hljs-built_in">create</span> -f single-config-<span class="hljs-built_in">file</span>.yaml<br></code></pre></td></tr></table></figure><h2 id="2-k8s的一些核心概念介绍"><a href="#2-k8s的一些核心概念介绍" class="headerlink" title="2. k8s的一些核心概念介绍"></a>2. k8s的一些核心概念介绍</h2><p>一个典型的k8s架构图如下：<br>我整理的图:k8s架构图<br><img src="http://ww1.sinaimg.cn/large/006gLprLgy1gcthutgohsj31jq15yqec.jpg" alt="QQ20200314-153534@2x.png"></p><h3 id="2-1-集群cluster"><a href="#2-1-集群cluster" class="headerlink" title="2.1 集群cluster"></a>2.1 集群cluster</h3><p>集群是一组节点，每个节点可以是物理服务器或者虚拟机，之上安装了Kubernetes平台。</p><p>实际生产中，可以针对不同的环境分别配置该环境对应的集群。</p><h3 id="2-2-Pod"><a href="#2-2-Pod" class="headerlink" title="2.2 Pod"></a>2.2 Pod</h3><p>Pod（绿色方框）位于节点上，一个节点上可以有多个Pod。一个Pod包含了一组容器和卷。同一个Pod里的各个容器之间共享一个网络命名空间，可以用localhost互相通信。<strong>Pod是短暂的，不是持续性实体。</strong> 所以如果想要持久化容器中的数据，可以使用卷功能。而且Pod是暂时的，所以重启时Pod的IP地址可能会变化。</p><p>Pod一般会根据业务场景进行分组，是根据业务区分的。实际上与docker-compose类似，一个Pod可以可以包含多个容器，这些容器是同一个业务中的。</p><h3 id="2-3-Label（标签）"><a href="#2-3-Label（标签）" class="headerlink" title="2.3 Label（标签）"></a>2.3 Label（标签）</h3><p>一些Pod上会有Label。（图上Pod旁的深蓝色方框）一个Label是attach到Pod的一对键&#x2F;值对，用来传递用户定义的属性。比如，你可能创建了一个”tier”和“app”标签，通过Label（tier&#x3D;frontend, app&#x3D;myapp）来标记前端Pod容器，使用Label（tier&#x3D;backend, app&#x3D;myapp）标记后台Pod。<strong>然后可以使用Selectors选择带有特定Label的Pod，并且将Service或者Replication Controller应用到上面。</strong></p><h3 id="2-4-Replication-Controller（复制控制器）"><a href="#2-4-Replication-Controller（复制控制器）" class="headerlink" title="2.4 Replication Controller（复制控制器）"></a>2.4 Replication Controller（复制控制器）</h3><p>Replication Controller确保任意时间都有指定数量的Pod“副本”在运行。如果为某个Pod创建了Replication Controller并且指定3个副本，它会创建3个Pod，并且持续监控它们。如果某个Pod不响应，那么Replication Controller会替换它。可以看看原文这里的动图。<br><img src="http://ww1.sinaimg.cn/large/006gLprLgy1gctgtdbjvkj31au0ugtep.jpg" alt="QQ20200314-145934@2x.png"><br>由图可以看出，复制控制器保持了3个Pod副本。计算Pod是不必计算原本的那个，只需关注它的副本即可。</p><p>当创建Replication Controller时，需要指定两个东西：</p><ul><li>Pod模板：用来创建Pod副本的模板</li><li>Label：Replication Controller需要监控的Pod的标签。</li></ul><h3 id="2-5-Service（服务）"><a href="#2-5-Service（服务）" class="headerlink" title="2.5 Service（服务）"></a>2.5 Service（服务）</h3><p>因为Pods是短暂的，那么重启时IP地址可能会改变，怎么才能从前端容器正确可靠地指向后台容器呢？</p><p>Service是定义一系列Pod以及访问这些Pod的策略的一层抽象。<strong>Service通过Label找到Pod组</strong>。因为Service是抽象的，所以在图表里通常看不到它们的存在，这也就让这一概念更难以理解。</p><p>现在，假定有2个后台Pod，并且定义后台Service的名称为‘backend-service’，lable选择器为（tier&#x3D;backend, app&#x3D;myapp）。backend-service 的Service会完成如下两件重要的事情：<br>会为Service创建一个本地集群的DNS入口，因此前端Pod只需要DNS查找主机名为 ‘backend-service’，就能够解析出前端应用程序可用的IP地址。<br>现在前端已经得到了后台服务的IP地址，但是它应该访问2个后台Pod的哪一个呢？Service在这2个后台Pod之间提供透明的负载均衡，会将请求分发给其中的任意一个（如下面的动画所示）。通过每个Node上运行的代理（kube-proxy）完成。这里有更多技术细节。</p><p>有一个特别类型的Kubernetes Service，<strong>称为’LoadBalancer’，作为外部负载均衡器使用，在一定数量的Pod之间均衡流量</strong>。比如，对于负载均衡Web流量很有用。</p><h3 id="2-6-Node（节点）"><a href="#2-6-Node（节点）" class="headerlink" title="2.6 Node（节点）"></a>2.6 Node（节点）</h3><p>在k8s中的意思通常指<strong>资源</strong>。从图上可以看出，两个Node上可以分别运行一模一样的Pod副本。节点（上图橘色方框）是物理或者虚拟机器，作为Kubernetes worker，通常称为Minion。每个节点都运行如下Kubernetes关键组件：</p><ul><li>Kubelet：是主节点代理。会暴露API给master进行使用和调用Node，这样Node可以控制Pod和Node的相关配置。kubelet也是一个基于docker或者其他容器技术运行的容器。kubelet可以与docker引擎通信，控制该机器上的容器。</li><li>Kube-proxy：Service使用其将链接路由到Pod，如上文所述。</li><li>Docker或Rocket：Kubernetes使用的容器技术来创建容器。</li></ul><h3 id="2-7-Kubernetes-Master"><a href="#2-7-Kubernetes-Master" class="headerlink" title="2.7 Kubernetes Master"></a>2.7 Kubernetes Master</h3><p>集群拥有一个Kubernetes Master（紫色方框）。</p><p>Kubernetes Master提供集群的独特视角，并且拥有一系列组件，比如Kubernetes API Server。API Server提供可以用来和集群交互的REST端点。master节点包括用来创建和复制Pod的Replication Controller。</p><p>master上运行了etcd ,etcd是一个数据中心，存储了每个Node上的每个Pod的运行情况，运行情况包括健康检查，探针（ 是由 <a href="https://kubernetes.io/docs/admin/kubelet/">kubelet</a> 对容器执行的定期诊断，用于看服务是否启动成功）等。</p><h2 id="3-k8s各个核心概念的关系"><a href="#3-k8s各个核心概念的关系" class="headerlink" title="3. k8s各个核心概念的关系"></a>3. k8s各个核心概念的关系</h2><p>灰色方框表示集群，集群里有一组节点（黄色方框）。<br>一个节点包含多个Pod。</p><p>Pod是短暂的，重启时IP会变化。</p><p>复制控制器：确保制定Pod的指定个数的副本在运行。（如图，控制四个副本在运行）</p><p>因为Pod重启时IP会变，服务即Service是定义一系列Pod以及访问这些Pod的策略的一层抽象，Service通过label找到Pod组。Service实现了负载均衡，方便Pod之间相互访问，</p><p><strong>master的功能是指挥调度</strong>:那么具体指挥调度的是什么呢？可以调度Pod，当指定某个Pod的指定个数的副本时候，master可以实现在某个Pod副本挂掉的时候，重建其他Pod，以实现保持Pod的副本个数为指定个。master可以为各个副本提供负载均衡的功能，也可以实现各个副本的滚动升级。master除了调度Pod之外，还可以控制各个Node，不过控制的是Node与k8s相关的配置。master控制Node或者控制Node上的Pod，都是通过Node上的kubelet实现的。</p><p>下面是原文的图：</p><p><img src="http://ww1.sinaimg.cn/large/006gLprLgy1gctgbglcc2j31ei0zk49e.jpg" alt="QQ20200314-144217@2x.png"></p><p>参考</p><p><a href="http://www.dockone.io/article/932">入门级的原文</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s 概念总结</title>
    <link href="/2021/04/09/k8s%20%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"/>
    <url>/2021/04/09/k8s%20%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>K8s 的核心功能：自动化运维管理多个容器化程序</p><p><img src="http://ww1.sinaimg.cn/large/006gLprLgy1grwlfqg8l6j61640kijye02.jpg" alt="Xnip2021-06-27_10-01-10.jpg"></p><p>K8S 中，主节点一般被称为<strong>Master Node</strong> 或者 <strong>Head Node</strong>，而从节点则被称为<strong>Worker Node</strong> 或者 <strong>Node</strong>。同一个集群可能存在多个 Master Node 和 Worker Node。</p><p><strong>Master Node</strong> 的组件有：<strong>API Server</strong>，<strong>Scheduler</strong>，<strong>Controller Manager</strong>，<strong>etcd</strong></p><p><strong>Worker Node</strong> 的组件有：<strong>Kubelet</strong>，<strong>Kube-Proxy</strong>，<strong>Container Runtime</strong>，<strong>Logging Layer(K8S</strong> 的监控状态收集器**)<strong>，</strong>Add-Ons(K8S** 管理运维 <strong>Worker Node</strong> 的插件组件**)**</p><p>————————————— 概念</p><p>————————————— 概念：组件（至此只与 Node 有关）</p><ul><li><strong>API Server</strong></li></ul><p><strong>K8S</strong> 的请求入口服务。API Server 负责接收 K8S 所有请求（来自 UI 界面或者 CLI 命令行工具），然后，API Server 根据用户的具体请求，去通知其他组件干活。</p><ul><li><strong>Scheduler</strong></li></ul><p><strong>K8S</strong> 所有 <strong>Worker Node</strong> 的调度器。当用户要部署服务时，Scheduler 会选择最合适的 Worker Node（服务器）来部署。</p><ul><li><strong>Controller Manager</strong></li></ul><p><strong>K8S</strong> 所有 <strong>Worker Node</strong> 的监控器，会指挥 <strong>Scheduler</strong> 干活。</p><p>Controller 负责监控和自动调节。负责监控和调整在 Worker Node 上部署的服务的状态，比如用户要求 A 服务部署 2 个副本，那么当其中一个服务挂了的时候，Controller 会马上调整，让 Scheduler 再选择一个 Worker Node 重新部署服务。</p><ul><li>Etcd</li></ul><p>有 Secret 对象，存放了容器需要使用的敏感信息。k8s 会在指定 Pod 启动时，自动把 Secret 数据挂载到容器中。</p><p>K8S 中仅 API Server 才具备读写权限</p><ul><li><strong>Kubelet</strong></li></ul><p><strong>Worker Node</strong> 的监视器，以及与 <strong>Master Node</strong> 的通讯器。Kubelet 是 Master Node 安插在 Worker Node 上的“眼线”，它会定期向 Worker Node 汇报自己 Node 上运行的服务的状态，并接受来自 Master Node 的指示采取调整措施。</p><ul><li><strong>Kube-Proxy</strong></li></ul><p><strong>K8S</strong> 的网络代理。负责网络和负载均衡。</p><ul><li><strong>Container Runtime</strong></li></ul><p><strong>Worker Node</strong> 的运行环境。即安装了容器化所需的软件环境确保容器化程序能够跑起来，比如 Docker Engine。</p><ul><li><strong>Logging Layer</strong></li></ul><p><strong>K8S</strong> 的监控状态收集器。Logging Layer 负责采集 Node 上所有服务的 CPU、内存、磁盘、网络等监控项信息。</p><ul><li><strong>Add-Ons</strong></li></ul><p><strong>K8S</strong> 管理运维 <strong>Worker Node</strong> 的插件组件。让用户可以扩展更多定制化功能。</p><p>————————————— 概念：其他</p><ul><li>Pod（没有什么对应的英文翻译）</li></ul><p><strong>Pod</strong>是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。</p><p>一个Pod总是运行在一个<strong>Node</strong>上。</p><p>一个 <strong>Pod</strong> 内可以有多个容器 <strong>container</strong>。</p><p><strong>Pod</strong> 可以被理解成一群可以共享网络、存储和计算资源的容器化服务的集合。</p><p>内含多个容器。Pod 内的容器在同一个 Pod 里的几个 Docker 服务&#x2F;程序，好像被部署在同一台机器上，可以通过 localhost 互相访问，且共享信息（包括配置）。不同的 <strong>Pod</strong> 之间的 <strong>Container</strong> 不能用 <strong>localhost</strong> 访问，也不能挂载其他 <strong>Pod</strong> 的数据卷。</p><p>可以在 yaml 中声明 kind 为 Pod 来创建 Pod。例如：</p><p>apiVersion: v1 # K8S 的 API Server 版本</p><p>kind: Pod</p><p>metadata: #  Pod 自身的元数据</p><p> name: memory-demo # Pod 的名字</p><p> namespace: mem-example # 这个 Pod 属于哪个 namespace</p><p>spec: # Pod 内部所有的资源的详细信息</p><p> containers:</p><p> - name: memory-demo-ctr # 容器名</p><p>  image: polinux&#x2F;stress</p><p>  resources: # 容器需要的 CPU、内存、GPU 等资源</p><p>   limits:</p><p>​    memory: “200Mi”</p><p>   requests:</p><p>​    memory: “100Mi”</p><p>  command: [“stress”] # 容器的入口命令</p><p>  args: [“–vm”, “1”, “–vm-bytes”, “150M”, “–vm-hang”, “1”] # 容器的入口参数</p><p>  volumeMounts: # 容器要挂载的 Pod 数据卷等</p><p>  - name: redis-storage</p><p>   mountPath: &#x2F;data&#x2F;redis</p><p> volumes: # Pod 内的数据卷信息</p><p> - name: redis-storage</p><p>  emptyDir: {}</p><ul><li>Node 节点</li></ul><p>一个 Node 对应了一台实体服务器。每个 Node 上可有多个 Pod。</p><ul><li>Volumn 数据卷</li></ul><p>数据卷 <strong>volume</strong> 是 <strong>Pod</strong> 内部的磁盘资源。</p><ul><li><strong>Container</strong> 容器</li></ul><p>部署的大多是标准容器（ <strong>Application Container</strong>）</p><ul><li><strong>Deployment</strong></li></ul><p><strong>Deployment</strong> 的作用是管理和控制 <strong>Pod</strong> 和 <strong>ReplicaSet</strong>，管控它们运行在用户期望的状态中。打个形象的比喻，<strong>Deployment</strong> 就是包工头，主要负责监督底下的工人 Pod 干活，确保每时每刻有用户要求数量的 Pod 在工作。如果一旦发现某个工人 Pod 不行了，就赶紧新拉一个 Pod 过来替换它。</p><p>Deployment并不是直接控制着Pod的，中间实际上还有一个ReplicaSet</p><p>根据我们的需求（比如通过标签）将Pod调度到目标机器上，调度完成之后，它还会继续帮我们继续监控容器是否在正确运行，一旦出现问题，会立刻告诉我们Pod的运行不正常以及寻找可能的解决方案，比如目标节点不可用的时候它可以快速地调度到别的机器上去。另外，如果需要对应用扩容提升响应能力的时候，通过Deployment可以快速地进行扩展。</p><p>将Pod调度到目标机器上是什么意思？？？？？？？这是问题，知道的话解释下：：：应该是在哪个机器上产生 Pod 的意思吧</p><p><img src="http://ww1.sinaimg.cn/large/006gLprLgy1grwlg709tdj61ds0sygqu02.jpg" alt="Xnip2021-06-27_10-01-42.jpg"></p><p>下面是一个 <strong>Deployment</strong> 的配置文件：</p><p>apiVersion: extensions&#x2F;v1beta1</p><p> kind: Deployment</p><p> metadata:</p><p>  name: rss-site</p><p>  namespace: mem-example # 如果没有指明 namespace，那么就是用 kubectl 默认的 namespace 即 default</p><p> spec:</p><p>  replicas: 2 # 副本个数。也就是该 Deployment 需要起多少个相同的 Pod</p><p>  template:</p><p>   metadata:</p><p>​    labels:</p><p>​     app: web</p><p>   spec: # 写明了 Deployment 下属管理的每个 Pod 的具体内容。</p><p>   containers:</p><p>​    - name: memory-demo-ctr</p><p>​     image: polinux&#x2F;stress</p><p>​     resources:</p><p>​     limits:</p><p>​      emory: “200Mi”</p><p>​     requests:</p><p>​      memory: “100Mi”</p><p>​     command: [“stress”]</p><p>​     args: [“–vm”, “1”, “–vm-bytes”, “150M”, “–vm-hang”, “1”]</p><p>​     volumeMounts:</p><p>​     - name: redis-storage</p><p>​      mountPath: &#x2F;data&#x2F;redis</p><p>   volumes:</p><p>   - name: redis-storage</p><p>​    emptyDir: {}</p><ul><li>ReplicaSet</li></ul><p>简称 RS。ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。</p><p>ReplicaSet 的作用就是管理和控制 Pod，管控他们好好干活。但是，ReplicaSet 受控于 Deployment。</p><p>用户会直接操作 Deployment 部署服务，而当 Deployment 被部署的时候，K8S 会自动生成要求的 ReplicaSet 和 Pod。在<a href="https://link.zhihu.com/?target=https://www.kubernetes.org.cn/replicasets"><strong>K8S</strong> 官方文档</a>中也指出用户只需要关心 Deployment 而不操心 ReplicaSet：</p><p><img src="http://ww1.sinaimg.cn/large/006gLprLgy1grwlgsddpjj61cq0kowh402.jpg" alt="Xnip2021-06-27_10-02-17.jpg"></p><ul><li><strong>Service</strong></li></ul><p><strong>Service</strong> 不一定有个固定的 <strong>IP</strong>。</p><p><strong>Service</strong> 負責管控 <strong>Pod</strong> 網絡服務。是將運行在一組 <strong>Pods</strong> 上的應用程序公開為網絡服務的抽象方法。</p><p>使用 Kubernetes，您无需修改应用程序即可使用不熟悉的服务发现机制。 Kubernetes 为 Pods 提供自己的 IP 地址，并为一组 Pod 提供相同的 DNS 名， 并且可以在它们之间进行负载均衡。</p><p>Service是一个完全虚拟的网络层，并不会存在于任何网络设备上。它通过修改集群内部的路由规则，仅对集群内部有效。</p><p>Deploment创建好应用之后，再为它生成一个Service对象。接下来就可以通过Service的域名访问到服务，形式是<Service name>.<NameSpace>，比如你有为Deployment的应用创建了一个名为portal的Service在默认的命名空间，那么集群内想要通过Http访问这个应用，就可以使用<a href="https://link.zhihu.com/?target=http://portal.default">http://portal.default</a>。这个域名仅在集群内有效，因为是内部的一个DNS负责解析。</NameSpace></Service></p><p><strong>Service</strong> 是 <strong>K8S</strong> 服务的核心，屏蔽了服务细节，统一对外暴露服务接口，真正做到了<strong>“</strong>微服务<strong>”</strong>。举个例子，我们的一个服务 A，部署了 3 个备份，也就是 3 个 Pod；对于用户来说，只需要关注一个 Service 的入口就可以，而不需要操心究竟应该请求哪一个 Pod。优势非常明显：一方面外部用户不需要感知因为 <strong>Pod</strong> 上服务的意外崩溃、<strong>K8S</strong> 重新拉起 <strong>Pod</strong> 而造成的 <strong>IP</strong> 变更，外部用户也不需要感知因升级、变更服务带来的 <strong>Pod</strong> 替换而造成的 <strong>IP</strong> 变化，另一方面，<strong>Service</strong> 还可以做流量负载均衡。</p><p><img src="http://ww1.sinaimg.cn/large/006gLprLgy1grwlhci9k2j61ek0skq8b02.jpg" alt="Xnip2021-06-27_10-02-44.jpg"></p><ul><li>Ingress</li></ul><p><strong>Ingress</strong> 负责管控 <strong>Pod</strong> 网络服务。</p><p>Service 主要负责 K8S 集群内部的网络拓扑。Ingress 用于对外提供服务。它是集群的入口。比如我们的集群Web应用想要让用户能够访问，那必然要在Ingress入口上增加一条解析记录。这一点，熟悉像Nginx的朋友应该比较容易理解，事实上Nginx Ingress也是K8s生态中的一个成员。</p><p><img src="http://ww1.sinaimg.cn/large/006gLprLgy1grwlhv0o6oj61cy0ps43r02.jpg" alt="Xnip2021-06-27_10-03-18.jpg"></p><p><img src="http://ww1.sinaimg.cn/large/006gLprLgy1grwliarw7pj61eu0skadw02.jpg" alt="Xnip2021-06-27_10-03-44.jpg"></p><ul><li>namespace 命名空间</li></ul><p>namespace 跟 Pod 没有直接关系，而是 K8S 另一个维度的对象。或者说，前文提到的概念都是为了服务 Pod 的，而 namespace 则是为了服务整个 K8S 集群的。</p><p>Kubernetes 支持多个虚拟集群，它们底层依赖于同一个物理集群。 这些虚拟集群被称为名字空间。<strong>namespace</strong> 是为了把一个 <strong>K8S</strong> 集群划分为若干个资源不可共享的虚拟集群而诞生的。</p><p>可以通过在 <strong>K8S</strong> 集群内创建 <strong>namespace</strong> 来分隔资源和对象。比如我有 2 个业务 A 和 B，那么我可以创建 ns-a 和 ns-b 分别部署业务 A 和 B 的服务，如在 ns-a 中部署了一个 deployment，名字是 hello，返回用户的是“hello a”；在 ns-b 中也部署了一个 deployment，名字恰巧也是 hello，返回用户的是“hello b”（要知道，在同一个 namespace 下 deployment 不能同名；但是不同 namespace 之间没有影响）。前文提到的所有对象，都是在 namespace 下的；当然，也有一些对象是不隶属于 namespace 的，而是在 K8S 集群内全局可见的</p><ul><li><strong>DaemonSet</strong> 守护进程</li></ul><p>保证在所有的目标节点上运行一个Pod的副本。在这期间，如果有新的Node加入到K8s集群中的话，它也会自动完成调度，在新的机器上运行一个Pod副本。守护进程的使用场景比如日志收集等。</p><ul><li>Job和CronJob对象</li></ul><p>用于定时任务</p><p><img src="http://ww1.sinaimg.cn/large/006gLprLgy1grwlirakv5j613i0n077v02.jpg" alt="Xnip2021-06-27_10-04-07.jpg"></p><ul><li><strong>kubectl</strong></li></ul><p>Kubectl 是一个命令行接口，用于对 Kubernetes 集群运行命令。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言实战-9章 测试和性能</title>
    <link href="/2021/03/24/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-9%E7%AB%A0%20%E6%B5%8B%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD/"/>
    <url>/2021/03/24/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-9%E7%AB%A0%20%E6%B5%8B%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<ol><li><p>一些单元测试可能会测试负向路径的场景，保证代码不仅会产生错误，而且是预期的错误。这种场景下的测试可能是对数据库进行查询时没有找到任何结果，或者对数据库做了无效的更新。在这两种情况下，测试都要验证确实产生了错误，且产生的是预期的错误。总之，不管如何调用或者执行代码，所写的代码行为都是可预期的。在 Go 语言里有几种方法写单元测试。基础测试（basic test）只使用一组参数和结果来测试一段代码。表组测试（table test）也会测试一段代码，但是会使用多组参数和结果进行测试。也可以使用一些方法来模仿（mock）测试代码需要使用到的外部资源，如数据库或者网络服务器。这有助于让测试在没有所需的外部资源可用的时候，模拟这些资源的行为使测试正常进行。</p></li><li><p>不但函数名字要以 Test 开头，而且函数的签名必须接收一个指向 testing.T 类型的指针，并且不返回任何值。如果没有遵守这些约定，测试框架就不会认为这个函数是一个测试函数，也不会让测试工具去执行它。</p></li><li><p>如果执行 go test 的时候没有加入冗余选项（-v），除非测试失败，否则我们是看不到任何测试输出的。</p></li><li><p>t.Fatal 方法不但报告这个单元测试已经失败，而且会向测试输出写一些消息，而后立刻停止这个测试函数的执行。如果除了这个函数外还有其他没有执行的测试函数，会继续执行其他测试函数。这个方法对应的格式化版本名为 t.Fatalf。</p></li><li><p>如果测试函数执行时没有调用过 t.Fatal或者 t.Error 方法，就会认为测试通过了。</p></li><li><p>依赖不属于你的或者你无法操作的服务来进行测试，也不是一个好习惯。这两点会严重影响测试持续集成和部署的自动化。如果突然断网，导致测试失败，就没办法部署新构建的程序。</p></li><li><p>包 httptest 可以让你能够模仿互联网资源的请求和响应。在我们的单元测试中，通过模仿 http.Get 的响应，我们可以解决在图 9-4 中遇到的问题，保证在没有网络的时候，我们的测试也不会失败，依旧可以验证我们的 http.Get 调用正常工作，并且可以处理预期的响应。</p></li><li><p>服务端点（endpoint）是指与服务宿主信息无关，用来分辨某个服务的地址，一般是不包含宿主的一个路径。如果在构造网络 API，你会希望直接测试自己的服务的所有服务端点，而不用启动整个网络服务。包 httptest 正好提供了做到这一点的机制。让我们看一个简单的包含一个服务端点的网络服务的例子</p></li><li><p>如果包使用这种方式命名，测试代码只能访问包里公开的标识符。即便测试代码文件和被测试的代码放在同一个文件夹中，也只能访问公开的标识符。就像直接运行服务时一样，需要为服务端点初始化路由，</p></li><li><p>如果包使用这种方式命名，测试代码只能访问包里公开的标识符。即便测试代码文件和被测试的代码放在同一个文件夹中，也只能访问公开的标识符。就像直接运行服务时一样，需要为服务端点初始化路由，</p></li><li><p>对于示例代码，需要遵守一个规则。示例代码的函数名字必须基于已经存在的公开的函数或者方法。我们的示例的名字基于 handlers 包里公开的 SendJSON 函数。如果没有使用已经存在的函数或者方法，这个示例就不会显示在包的 Go 文档里。</p></li><li><p>基准测试是一种测试代码性能的方法。想要测试解决同一问题的不同方案的性能，以及查看哪种解决方案的性能更好时，基准测试就会很有用。基准测试也可以用来识别某段代码的 CPU或者内存效率问题，而这段代码的效率可能会严重影响整个应用程序的性能。许多开发人员会用基准测试来测试不同的并发模式，或者用基准测试来辅助配置工作池的数量，以保证能最大化系统的吞吐量。</p></li><li><p>testing.T. 有一个方法叫 ResetTimer()。基准测试里面调用 b.ResetTimer 的作用。在代码开始执行循环之前需要进行初始化时，这个方法用来重置计时器，保证测试代码执行前的初始化代码，不会干扰计时器的结果。为了保证得到的测试结果尽量精确，需要使用这个函数来跳过初始化代码的执行时间。</p></li><li><p>基准测试函数必须以 Benchmark 开头，接受一个指向 testing.B 类型的指针作为唯一参数。为了让基准测试框架能准确测试性能，它必须在一段时间内反复运行这段代码，</p></li><li><p>基准测试框架默认会在持续 1 秒的时间内，反复调用需要测试的函数。测试框架每次调用测试函数时，都会增加 b.N 的值。第一次调用时，b.N 的值为 1。需要注意，一定要将所有要进行基准测试的代码都放到循环里，并且循环要使用 b.N 的值。否则，测试的结果是不可靠的。</p></li><li><p>默认情况下，基准测试的最小运行时间是 1 秒。如果想让运行时间更长，可以使用另一个名为-benchtime 的<br>选项来更改测试执行的最短时间。</p></li><li><p>对大多数测试来说，超过 3 秒的基准测试并不会改变测试的精确度。</p></li><li><p>运行基准测试时，另一个很有用的选项是-benchmem 选项。这个选项可以提供每次操作分配内存的次数，以及总共分配内存的字节数。输出的结果会多出两组新的数值：一组数值的单位是 B&#x2F;op，另一组的单位是<br>allocs&#x2F;op。单位为 allocs&#x2F;op 的值表示每次操作从堆上分配内存的次数。你可以看到Sprintf 函数每次操作都会从堆上分配两个值，而另外两个函数每次操作只会分配一个值。单位为 B&#x2F;op 的值表示每次操作分配的字节数。你可以看到 Sprintf 函数两次分配总共消耗了 16字节的内存，而另外两个函数每次操作只会分配 2 字节的内存。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言实战-6章 并发</title>
    <link href="/2021/03/23/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-6%E7%AB%A0%20%E5%B9%B6%E5%8F%91/"/>
    <url>/2021/03/23/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-6%E7%AB%A0%20%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="6-并发"><a href="#6-并发" class="headerlink" title="6. 并发"></a>6. 并发</h2><ol><li><p>Go 语言里的并发指的是能让某个函数独立于其他函数运行的能力。当一个函数创建为 goroutine<br>时，Go 会将其视为一个独立的工作单元。这个单元会被调度到可用的逻辑处理器上执行。Go 语言<br>运行时的调度器是一个复杂的软件，能管理被创建的所有 goroutine 并为其分配执行时间。这个调度<br>器在操作系统之上，将操作系统的线程与语言运行时的逻辑处理器绑定，并在逻辑处理器上运行<br>goroutine。调度器在任何给定的时间，都会全面控制哪个 goroutine 要在哪个逻辑处理器上运行。<br>Go 语言的并发同步模型来自一个叫作通信顺序进程（Communicating Sequential Processes，CSP）<br>的范型（paradigm）。CSP 是一种消息传递模型，通过在 goroutine 之间传递数据来传递消息，而不是<br>对数据进行加锁来实现同步访问。用于在 goroutine 之间同步和传递数据的关键数据类型叫作通道<br>（channel）。对于没有使用过通道写并发程序的程序员来说，通道会让他们感觉神奇而兴奋。希望读<br>者使用后也能有这种感觉。使用通道可以使编写并发程序更容易，也能够让并发程序出错更少。</p></li><li><p>什么是操作系统的线程（thread）和进程（process）。</p></li></ol><p>每个进程的初始线程被称作主线程。因为执行这个线程的空间是应用程序的本身的空间，所以当主线程终止时，应用程序也会终止。操作系统将线程调度到某个处理器上运行，这个处理器并不一定是进程所在的处理器。</p><ol start="3"><li><p>操作系统会在物理处理器上调度线程来运行，而 Go 语言的运行时会在逻辑处理器上调度<br>goroutine来运行。每个逻辑处理器都分别绑定到单个操作系统线程。在 1.5 版本 ①<br>在图 6-2 中，可以看到操作系统线程、逻辑处理器和本地运行队列之间的关系。如果创建一<br>个 goroutine 并准备运行，这个 goroutine 就会被放到调度器的全局运行队列中。之后，调度器就<br>将这些队列中的 goroutine 分配给一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列<br>上，Go语言的运行时默认会为每个可用的物理处理器分配一个逻辑处理器。在 1.5 版本之前的版本中，默认给整个应用程序只分配一个逻辑处理器。这些逻辑处理器会用于执行所有被创建的goroutine。即便<br>只有一个逻辑处理器，Go也可以以神奇的效率和性能，并发调度无数个goroutine。</p></li><li><p>并发（concurrency）不是并行（parallelism）。并行是让不同的代码片段同时在不同的物理处<br>理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做<br>了一半就被暂停去做别的事情了。</p></li><li><p>不过要想真的实现并行的效果，用户需要让自己的程序运行在有多个物理处理器的机器上。否则，哪怕 Go 语<br>言运行时使用多个线程，goroutine 依然会在同一个物理处理器上并发运行，达不到并行的效果。</p></li><li><p>下面的代码会分配一个逻辑处理器给调度器使用</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">runtime.GOMAXPROCS(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><ol start="7"><li><p>基于调度器的内部算法，一个正运行的 goroutine 在工作结束前，可以被停止并重新调度。</p></li><li></li></ol><p><img src="http://ww1.sinaimg.cn/large/006gLprLly1gpyn0jryhsj31ac1ucnfm.jpg" alt="IMG_C703DF60F789-1.jpeg"></p><p>运行结果是</p><p><img src="http://ww1.sinaimg.cn/large/006gLprLly1gpyn3uzdanj315g0uy76h.jpg" alt="IMG_0285.jpg"></p><p>goroutine B 先显示素数。一旦 goroutine B 打印到素数 4591，调度器就会将正运行的 goroutine<br>切换为 goroutine A。之后 goroutine A 在线程上执行了一段时间，再次切换为 goroutine B。这次<br>goroutine B 完成了所有的工作。一旦 goroutine B 返回，就会看到线程再次切换到 goroutine A 并<br>完成所有的工作。每次运行这个程序，调度器切换的时间点都会稍微有些不同。</p><ol start="9"><li><p>函数 NumCPU 返回可以使用的物理处理器的数量。因此，调用 GOMAXPROCS 函数就为每个可用的物理处理器创建一个逻辑处理器。需要强调的是，使用多个逻辑处理器并不意味着性能更好。在修改任何语言运行时配置参数的时候，都需要配合基准测试来评估程序的运行效果。</p></li><li><p>只有在有多个逻辑处理器且可以同时让每个goroutine 运行在一个可用的物理处理器上的时候，goroutine 才会并行运行。</p></li><li><p>如果两个或者多个 goroutine 在没有互相同步的情况下，访问某个共享的资源，并试图同时读和写这个资源，就处于相互竞争的状态，这种情况被称作竞争状态（race candition）。</p></li><li><p><code>go build -race</code> 用竞争检测器标识来编译程序</p></li><li><p>Go 语言提供了传统的同步 goroutine 的机制，就是对共享资源加锁。如果需要顺序访问一个整型变量或者一段代码，atomic 和 sync 包里的函数提供了很好的解决方案。</p></li><li><p><code>atomic.AddInt64(&amp;counter, 1)</code>这是安全的对 counter 加 1，表示同一时刻只能有一个 grouting 运行并完成这个加法操作。另外两个有用的原子函数是 LoadInt64 和 StoreInt64。这两个函数提供了一种安全地读和写一个整型值的方式。</p></li><li><p>如果哪个 doWork goroutine 试图在 main 函数调用 StoreInt64 的同时调用 LoadInt64 函数，那么原子函数会将这些调用互相同步，保证这些操作都是安全的，不会进入竞争状态。</p></li><li><p>另一种同步访问共享资源的方式是使用互斥锁（mutex）。互斥锁这个名字来自互斥（mutual exclusion）的概念。互斥锁用于在代码上创建一个临界区，保证同一时间只有一个 goroutine 可以执行这个临界区代码。</p></li><li><p>可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。</p></li><li></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 无缓冲的整型通道</span><br>buffered:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-comment">// 有缓冲的字符串通道</span><br>buffered:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>,<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><ol start="19"><li>可以使用&lt;-操作符，但这次是一元运算符</li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言实战-7-8章</title>
    <link href="/2021/03/23/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-7-8%E7%AB%A0/"/>
    <url>/2021/03/23/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-7-8%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>第 7 章 并发模式</strong></p><ol><li><p>runner 包用于展示如何使用通道来监视程序的执行时间，如果程序运行时间太长，也可以用 runner 包来终止程序。当开发需要调度后台处理任务的程序的时候，这种模式会很有用。这个程序可能会作为 cron 作业执行，或者在基于定时任务的云环境（如 iron.io）里执行。</p></li><li><p>这是一个名为 New 的工厂函数</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(d *time.Duration)</span></span> *Runner&#123;<br>  <span class="hljs-keyword">return</span> &amp;Runner&#123;<br>    interrupt: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>),<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通道 interrupt 被初始化为缓冲区容量为 1 的通道。这可以保证通道至少能接收一个来自语言运行时的 os.Signal 值，确保语言运行时发送这个事件的时候不会被阻塞。如果 goroutine没有准备好接收这个值，这个值就会被丢弃。例如，如果用户反复敲 Ctrl+C 组合键，程序只会在这个通道的缓冲区可用的时候接收事件，其余的所有事件都会被丢弃。</p><p>下面与 Runner 有关的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Runner)</span></span> goInterrupt() <span class="hljs-type">bool</span>&#123;<br> <span class="hljs-keyword">select</span> &#123;<br>  signal.Stop(r.interrupt)<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br> <span class="hljs-comment">// 继续正常执行</span><br> <span class="hljs-keyword">default</span>:<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>default 分支会将接收 interrupt 通道的阻塞调用转变为非阻塞的。</p><ol start="3"><li><p>pool包用于展示如何使用有缓冲的通道实现资源池，来管理可以在任意数量的goroutine之间共享及独立使用的资源。</p></li><li><p>work 包的目的是展示如何使用无缓冲的通道来创建一个 goroutine 池，这些 goroutine 执行并控制一组工作，让其并发执行。在这种情况下，使用无缓冲的通道要比随意指定一个缓冲区大小的有缓冲的通道好。无缓冲的通道保证两个 goroutine 之间的数据交换。这种使用无缓冲的通道的方法允许使用者知道什么时候 goroutine 池正在执行工作，而且如果池里的所有 goroutine 都忙，无法接受新的工作的时候，也能及时通过通道来通知调用者。使用无缓冲的通道不会有工作在队列里丢失或者卡住，所有工作都会被处理。</p></li><li><p>有缓冲的通道可以用来管理一组可复用的资源。<br>语言运行时会处理好通道的协作和同步。<br>使用无缓冲的通道来创建完成工作的 goroutine 池。<br>任何时间都可以用无缓冲的通道来让两个 goroutine 交换数据，在通道操作完成时一定保证对方接收到了数据。</p></li></ol><p><strong>第8章 标准库</strong></p><ol><li><p>什么是 Go 标准库？为什么这个库这么重要？Go 标准库是一组核心包，用来扩展和增强语<br>言的能力。这些包为语言增加了大量不同的类型。开发人员可以直接使用这些类型，而不用再写<br>自己的包或者去下载其他人发布的第三方包。由于这些包和语言绑在一起发布，它们会得到以下<br>特殊的保证：<br>每次语言更新，哪怕是小更新，都会带有标准库；<br>这些标准库会严格遵守向后兼容的承诺；<br>标准库是 Go 语言开发、构建、发布过程的一部分；<br>标准库由 Go 的构建者们维护和评审；<br>每次 Go 语言发布新版本时，标准库都会被测试，并评估性能。</p></li><li><p>准库里包含众多的包，不可能在一章内把这些包都讲一遍。目前，标准库里总共有超过100 个包，这些包被分到 38 个类别里</p></li><li><p>不管用什么方式安装 Go，标准库的源代码都会安装在$GOROOT&#x2F;src&#x2F;pkg 文件夹中。</p></li><li><p>作为 Go 发布包的一部分，标准库的源代码是经过预编译的。这些预编译后的文件，称作归档文件（archive file），可以 在$GOROOT&#x2F;pkg 文件夹中找到已经安装的各目标平台和操作系统的归档文件。</p></li><li><p>归档文件是特殊的 Go 静态库文件，由 Go 的构建工具创建，并在编译和链接最终程序时被使用。归档文件可以让构建的速度更快。但是在构建的过程中，没办法指定这些文件，所以没办法与别人共享这些文件。Go 工具链知道什么时候可以使用已有的.a 文件，什么时候需要从机器上的源代码重新构建。</p></li><li><p>在 UNIX 里，日志有很长的历史。这些积累下来的经验都体现在 log 包的设计里。传统的CLI（命令行界面）程序直接将输出写到名为 stdout 的设备上。所有的操作系统上都有这种设备，这种设备的默认目的地是标准文本输出。默认设置下，终端会显示这些写到 stdout 设备上的文本。这种单个目的地的输出用起来很方便，不过你总会碰到需要同时输出程序信息和输出执行细节的情况。这些执行细节被称作日志。当想要记录日志时，你希望能写到不同的目的地，这样就不会将程序的输出和日志混在一起了。为了解决这个问题，UNIX 架构上增加了一个叫作 stderr 的设备。这个设备被创建为日志的默认目的地。这样开发人员就能将程序的输出和日志分离开来。如果想在程序运行时同时看到程序输出和日志，可以将终端配置为同时显示写到 stdout 和 stderr 的信息。不过，如果用户的程序只记录日志，没有程序输出，更常用的方式是将一般的日志信息写到 stdout，将错误或者警告信息写到 stderr。</p></li><li><p>通常程序会在这个 init()函数里配置日志参数</p></li><li><p>设置了一个字符串，作为每个日志项的前缀。这个字符串应该是能让用户从一般的程序输出中分辨出日志的字符串。传统上这个字符串的字符会全部大写。</p></li><li><p>操作符&lt;&lt;对左边的操作数执行按位左移操作</p></li><li><p>Panic 系列函数用来写日志消息，然后触发一个 panic。除非程序执行 recover 函数，否则会导致程序打印调用栈后终止。Print 系列函数是写日志消息的标准方法。log 包有一个很方便的地方就是，这些日志记录器是多 goroutine 安全的。这意味着在多个goroutine 可以同时调用来自同一个日志记录器的这些函数，而不 会有彼此间的写冲突。标准日志记录器具有这一性质，用户定制的日志记录器也应该满足这一性质。</p></li><li><p>记录不同的日志</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">Trace *log.Logger <span class="hljs-comment">// 记录所有日志</span><br>Info *log.Logger <span class="hljs-comment">// 重要的信息</span><br>Warning *log.Logger <span class="hljs-comment">// 需要注意的问题</span><br>Error *log.Logger <span class="hljs-comment">// 非常严重的问题</span><br></code></pre></td></tr></table></figure><ol start="12"><li>如下一个声明和它的作用</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Discard 是一个 io.Writer，所有的 Write 调用都不会有动作，但是会成功返回</span><br><span class="hljs-keyword">var</span> Discard io.Writer = delNull(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ol start="13"><li><p>在今天，JSON 远比 XML 流行。这主要是因为与 XML 相比，使用 JSON 需要处理的标签更少。而这就意味着网络传输时每个消息的数据更少，从而提升整个系统的性能。而且，JSON 可以转换为 BSON（Binary JavaScript Object Notation，二进制 JavaScript 对象标记），进一步缩小每个消息的数据长度</p></li><li><p>如下你会注意到每个字段最后使用单引号声明了一个字符串。这些字符串被称作标签（tag），是提供每个字段的元信息的一种机制，将 JSON 文档和结构类型里的字段一一映射起来。如果不存在标签，编码和解码过程会试图以大小写无关的方式，直接使用字段的名字进行匹配。如果无法匹配，对应的结构类型里的字段就包含其零值。</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span>&#123;<br> Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="15"><li>由于 Go 语言支持复合语句调用，可以直接调用从 NewDecoder 函数返回的值的 Decode 方法，而不用把这个返回值存入变量。NewDecode 如下</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDecoder</span><span class="hljs-params">(r *io.Reader)</span></span> *Decoder<br></code></pre></td></tr></table></figure><ol start="16"><li><p>我们 向 Decode 方法传入了指向 gResponse 类型的指针变量的地址，而这个地址的实际值为 nil。该方法调用后，这个指针变量会被赋给一个 gResponse 类型的值，并根据解码后的 JSON 文档做初始化。</p></li><li><p>使用 map 会很快</p></li><li><p>序列化（marshal）是指将数据转换为 JSON 字符串的过程</p></li><li><p>MarshalIndent 很像 Marshal，只是用缩减对输出进行了格式化</p></li><li><p>如果不需要输出带有缩进格式的 JSON 字符串，json 包还提供了名为 Marshal 的函数来进行解码。这个函数产生的 JSON 字符串很适合作为在网络响应（如 Web API）的数据。函数 Marshal的工作原理和函数 MarshalIndent 一样，只不过没有用于前缀 prefix 和缩进 indent 的参数。</p></li><li><p>同样的理念扩展到了标准库的 io 包，而且提供的功能很神奇。这个包可以以流的方式高效处理数据，而不用考虑数据是什么，数据来自哪里，以及数据要发送到哪里的问题。与 stdout和 stdin 对应，这个包含有 io.Writer 和 io.Reader 两个接口。所有实现了这两个接口的类型的值，都可以使用 io 包提供的所有功能，也可以用于其他包里接受这两个接口的函数以及方法。这是用接口类型来构造函数和 API 最美妙的地方。开发人员可以基于这些现有功能进行组合，利用所有已经存在的实现，专注于解决业务问题。</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br> Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>,err <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="22"><li>Read 最多读入 len(p)字节，保存到 p。这个方法返回读入的字节数（0 &lt;&#x3D; n<br>(1) Rd l()0 &lt;<br>&lt;l()Rd &lt; l()<br>习惯上 Read 会立刻返回可用的数据，而不等待更多的数据。<br>(2) 当成功读取 n &gt; 0 字节后，如果遇到错误或者文件读取完成，Read 方法会返回<br>(2) &gt; 0 Rd<br>il<br>0Rd<br>下一次调用 Read 应该返回 0, EOF。<br>(3) 调用者在返回的 n &gt; 0 时，总应该先处理读入的数据，再处理错误 err。这样才<br>(3) &gt; 0<br>(4) Read 的实现不鼓励返回 0 个读取字节的同时，返回 nil 值的错误。调用者需要将<br>这种返回状态视为没有做任何操作，而不是遇到读取结束。</li><li>关于变量的声明：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> &#123;<br> Stdin = NewFile(<span class="hljs-type">uintptr</span>(syscall.Stdin), <span class="hljs-string">&quot;/dev/stdin&quot;</span>)<br> Stdout = NewFile(<span class="hljs-type">uintptr</span>(syscall.Stdout), <span class="hljs-string">&quot;/dev/stdout&quot;</span>)<br> Stderr = NewFile(<span class="hljs-type">uintptr</span>(syscall.Stderr), <span class="hljs-string">&quot;/dev/stderr&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="24"><li>使用 MultiWriter，这样可以同时向文件和标准输出设备进行写操作</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">dest:=io.MultiWriter(os.Stdout, file)<br></code></pre></td></tr></table></figure><ol start="25"><li></li></ol><p><img src="http://ww1.sinaimg.cn/large/006gLprLly1gqh4v4zzb6j30y70f6tfi.jpg" alt="IMG_0325.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言实战-1-5章</title>
    <link href="/2021/03/22/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-1-5%E7%AB%A0/"/>
    <url>/2021/03/22/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-1-5%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-2-章-关于-Go-语言的介绍和快速开始一个-Go-程序"><a href="#1-2-章-关于-Go-语言的介绍和快速开始一个-Go-程序" class="headerlink" title="1.2 章 关于 Go 语言的介绍和快速开始一个 Go 程序"></a>1.2 章 关于 Go 语言的介绍和快速开始一个 Go 程序</h2><ol><li>如果 main 函数不在 main 包中，构建工程就不会生成可执行文件。</li><li>程序中每个代码文件的 init 函数都会在 main 函数执行前调用。这个 init 函数将标准库里日志类的输出，从标准的默认错误(stderr)，设置为标准输出(stdout)设备。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br> log.SetOutput(os.Stdout)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>编译器查找包的时候，总是会到 GOROOT 和 GOPATH 环境变量。</p></li><li><p>map 是 Go 语言的一个引用类型，需要使用 make 来构造。如果不先构造 map 并将构造后的值赋值给变量，会在试图使用这个 map 变量时收到出错细节。这是因为 map 变量默认的零值是 nil。</p></li><li><p>如果需要声明初始值为零值的变量，应该使用 var 关键字声明变量。</p></li><li><p>匿名函数是指没有明确声明名字的函数</p></li><li><p>Go 语言支持闭包，这里就应用了闭包。实际上，在匿名函数内访问 searchTerm 和 results<br>变量，也是通过闭包的形式访问的。因为有了闭包，函数可以直接访问到那些没有作为参数传入<br>的变量。匿名函数并没有拿到这些变量的副本，而是直接访问外层函数作用域中声明的这些变量<br>本身。因为 matcher 和 feed 变量每次调用时值不相同，所以并没有使用闭包的方式访问这两<br>个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(matcher Matcher,feed *Feed)</span></span>&#123;<br> Match(matcher, feed, searchTerm, results)<br> waitGroup.Done()<br>&#125;(matcher,feed)<br></code></pre></td></tr></table></figure></li><li><p>使用关键字 defer ，可以保证这个函数一定会被调用。哪怕函数意外崩溃终止，也能保证关键字 defer 安排调用的函数会被执行。</p></li><li><p>json 的一系列方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> feeds []*Feed<br><span class="hljs-comment">// 我们调用 json 包的 NewDecoder 函数，然后在其返回值上调用Decode 方法，调用 Decode 方法传入了切片地址</span><br>err = json.NewDecoder(file).Decode(&amp;feeds)<br><br><span class="hljs-keyword">return</span> feeds,err<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dec *Decoder)</span></span> Decode(v <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><p>这是 Decode 方法的声明。Decode 方法接受一个类型为 interface{}的值作为参数。这个类型在 Go 语言里很特殊，一般会配合 reflect 包里提供的反射功能一起使用。</p></li><li><p>命名接口的时候，也需要遵守 Go 语言的命名惯例。如果接口类型只包含一个方法，那么这个类型的名字以 er 结尾。</p></li><li><p>因为大部分方法在被调用后都需要维护接收者的值的状态，所以，一个最佳实践是，将方法的接收者声明为指针，使用指针可以在函数或者 goroutine 之间共享数据。而使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用。</p></li></ol><h2 id="3-打包和工具链"><a href="#3-打包和工具链" class="headerlink" title="3. 打包和工具链"></a>3. 打包和工具链</h2><ol><li>每个包都在一个单独的目录里。不能把多个包放到同一个目录中，也不能把同一个包的文件分拆到多个不同目录中。这意味着，同一个目录下的所有.go 文件必须声明同一个包名。</li><li>所有用 Go 语言编译的可执行程序都必须有一个名叫 main 的包。当编译器发现某个包的名字为 main 时，它一定也会发现名为 main()的函数，否则不会创建可执行文件。main()函数是程序的入口，所以，如果没有这个函数，程序就没有办法开始执行。程序编译时，会使用声明 main 包的代码所在的目录的目录名作为二进制可执行文件的文件名。</li><li><strong>main函数必须放在main包里</strong></li><li>标准库中的包会在安装 Go 的位置找到。Go 开发者创建的包会在 GOPATH 环境变量指定的目录里查找。GOPATH 指定的这些目录就是开发者的个人工作空间。</li><li>有一件重要的事需要记住，编译器会首先查找 Go 的安装目录，然后才会按顺序查找 GOPATH 变量里列出的目录。</li><li>go get 将获取任意指定的 URL 的包，</li><li>下划线 _ 在 Go 语言中称为空白标识符</li><li>go clean xx.go ，调用 clean 会删除编译生成的可执行文件</li><li>go build 可以在指定包的时候使用通配符</li><li>go run 可以完成编译和运行两个操作，go run 命令会先构建 wordcount.go 里包含的程序，然后执行构建后的程序。这样可以节省好多录入工作量。</li><li>fmt 工具会将开发人员的代码布局成和 Go 源代码类似的风格，不用再为了大括号是不是要放到行尾，或者用 tab（制表符）还是空格来做缩进而争论不休。使用 go fmt 后面跟文件名或者包名，就可以调用这个代码格式化工具。</li><li><code>good -http=:6060</code>可以实现在 6060 端口访问 go 的文档，如果浏览器已经打开，导航到<a href="http://localhost:6060/">http://localhost:6060</a> 可以看到一个页面，包含所有 Go 标准库和你的 GOPATH 下的 Go 源代码的文档。</li></ol><p>显示结果为：</p><p><img src="http://ww1.sinaimg.cn/large/006gLprLly1gpeyg2ssjrj325210m15i.jpg" alt="Xnip2021-04-10_21-10-23.jpg"></p><h2 id="4-数组，切片和映射"><a href="#4-数组，切片和映射" class="headerlink" title="4. 数组，切片和映射"></a>4. 数组，切片和映射</h2><ol><li><p>如果使用…替代数组的长度，Go 语言会根据初始化时数组元素的数量来确定该数组的长度</p></li><li><p><strong>声明数组指定位置的值</strong>：<code>array := [5]int&#123;1: 10, 2: 20&#125;</code>，表明数组大小是 5，下标为 1 的位置的元素的值是 10，下标为 2 的位置的元素的值是 20。</p></li><li><p>数组变量的类型包括数组长度和每个元素的类型。</p></li><li><p>二维数组的赋值：<code>aray := [4][2]&#123;&#123;10, 11&#125;,&#123;10, 11&#125;,&#123;10, 11&#125;,&#123;10, 11&#125;&#125;</code></p></li><li><p>声明一个需要 8 MB 的数组：var array [1e6]int</p></li><li><p>切片是一种数据结构，这种数据结构便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。</p></li><li><p><strong>一种创建切片的方法是使用内置的 make 函数。</strong>当使用 make 时，需要传入一个参数，指定切片的长度，如果只指定长度，那么切片的容量和长度相等。如果基于这个切片创建新的切片，新切片会和原有切片共享底层数组，也能通过后期操作来访问多余容量的元素。</p></li><li><p>例子：创建切片<code>s:=[]string&#123;&quot;1&quot;,&quot;2&#125;</code>，使用空字符串初始化第100个元素,<code>slice:=[]string&#123;99:&quot;&quot;&#125;</code></p></li><li><p>创建 nil 整形切片：<code>var slice []int</code></p></li><li><p>使用 make 创建空的整型切片：<code>slice := make([]int, 0)</code>。使用切片字面量创建空的整型切片：<code>slice := []int&#123;&#125;</code>。空切片在底层数组包含 0 个元素，也没有分配任何存储空间。想表示空集合时空切片很有用，例如，数据库查询返回 0 个查询结果时。</p></li><li><p>切片之所以被称为切片，是因为创建一个新的切片就是把底层数组切出一部分。</p></li><li><p>对底层容量是 k 的切片 slice[i:j] 来说，长度j-i，容量：k-i</p></li><li><p>基于切片创建切片：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">// 长度是 2 个元素，容量是 4 个元素</span><br>newSlice:=slice[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><ol start="14"><li><p>切片有额外的容量是很好，但是如果不能把这些容量合并到切片的长度里，这些容量就没有用处。<strong>好在可以用 Go 语言的内置函数 append 来做这种合并很容易。</strong></p></li><li><p>如果切片的底层数组没有足够的可用容量，append 函数会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值</p></li><li><p>函数 append 会智能地处理底层数组的容量增长。在切片的容量小于 1000 个元素时，总是会成倍地增加容量。一旦元素个数超过 1000，容量的增长因子会设为 1.25，也就是会每次增加 25%的容量。随着语言的演化，这种增长算法可能会有所改变。</p></li><li><p>对于 <code>slice[i:j:k]或者[2:3:4]</code>，其长度为 j-i 或者 3-2 &#x3D;1，其容量为 k-i 或者 4-2&#x3D;2。</p></li><li><p>如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个 append 操作创建新的底层数组，与原有的底层数组分离。新切片与原有的底层数组分离后，可以安全地进行后续修改，</p></li><li><p>Go 语言有个特殊的关键字 range，它可以配合关键字 for 来迭代切片里的元素。</p></li><li><p>和数组一样，切片是一维的。不过，和之前对数组的讨论一样，可以组合多个切片形成多维切片，比如可以类似二维数组一样创建二维切片。</p></li><li><p>将切片复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底层数组。函数调用时复制切片，函数返回时复制切片。</p></li><li><p>切片每次迭代映射的时候顺序也可能不一样。无序的原因是映射的实现使用了散列表，映射通过合理数量的桶来平衡键值对的分布。</p></li><li><p>切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的键，使用这些类型会造成编译错误。</p></li><li><p>可以通过声明一个未初始化的映射来创建一个值为 nil 的映射（称为 nil 映射 ）。nil 映射不能用于存储键值对，否则，会产生一个语言运行时错误，比如 <code>var s map[string]string  s[&quot;a&quot;]=&quot;a&quot;</code>会报错:<code>assignment to entry in nil map</code>。</p></li><li><p>如果想把一个键值对从映射里删除，就使用内置的 delete 函数，比如 delete(mapvalue, key)</p></li><li><p>在函数间传递映射并不会制造出该映射的一个副本。实际上，当传递映射给一个函数，并对这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改。也就是类似指针，一个地方改了其他地方有会改。</p></li></ol><h2 id="5-Go-语言的系统类型"><a href="#5-Go-语言的系统类型" class="headerlink" title="5. Go 语言的系统类型"></a>5. Go 语言的系统类型</h2><ol><li><p>Go 是一种静态类型的语言。</p></li><li><p>bool 类型的值需要 1 字节（8 位），表示布尔值 true和 false。有些类型的内部表示与编译代码的机器的体系结构有关。例如，根据编译所在的机器的体系结构，一个 int 值的大小可能是 8 字节（64 位），也可能是 4 字节（32 位）。</p></li><li><p>Go 语言里声明用户定义的类型有两种方法。最常用的方法是使用关键字 struct，它可以让用户创建一个结构类型。</p></li><li><p>任何时候，创建一个变量并初始化为其零值，习惯是使用关键字 var。</p></li><li><p><code>type Duration int64</code>，在 Duration类型的声明中，我们把 int64 类型叫作 Duration 的基础类型。不过，虽然 int64 是基础类型，Go 并不认为 Duration 和 int64 是同一种类型。这两个类型是完全不同的有区别的类型。</p></li><li><p>方法能给用户定义的类型添加新的行为。方法实际上也是函数。</p></li><li><p>关键字 func 和函数名之间的参数被称作接收者，将函数与接收者的类型绑在一起。如果一个函数有接收者，这个函数就被称为方法。</p></li><li><p>Go 语言里有两种类型的接收者：值接收者和指针接收者。</p></li><li><p>如果使用值接收者声明方法，调用时会使用这个值的一个副本来执行。</p></li><li><p>Go语言既允许使用值，也允许使用指针来调用方法，不必严格符合接收者的类型。这个支持非常方便开发者编写程序。</p></li><li><p>如果是要创建一个新值，该类型的方法就使用值接收者。如果是要修改当前值，就使用指针接收者。</p></li><li><p>内置类型是由语言提供的一组类型。我们已经见过这些类型，分别是数值类型、字符串类型和布尔类型。这些类型本质上是原始的类型。因此，当对这些值进行增加或者删除的时候，会创建一个新值。基于这个结论，当把这些类型的值传递给方法或者函数时，应该传递一个对应值的副本。</p></li><li><p>Go语言里的引用类型有如下几个：切片、映射、通道、接口和函数类型。当声明上述类型的变量时，创建的变量被称作标头（header）值。从技术细节上说，字符串也是一种引用类型。每个引用类型创建的标头值是包含一个指向底层数据结构的指针。每个引用类型还包含一组独特的字段，用于管理底层数据结构。因为标头值是为复制而设计的，所以永远不需要共享一个引用类型的值。标头值里包含一个指针，因此通过复制来传递一个引用类型的值的副本，本质上就是在共享底层数据结构。</p></li><li><p>一个值接收者，正像预期的那样通过复制来传递引用，从而不需要通过指针来共享引用类型的值。这种传递方法也可以应用到函数或者方法的参数传递。</p></li><li><p>当需要修改值本身时，在程序中其他地方，需要使用指针来共享这个值。</p></li><li><p>Chdir 方法展示了，即使没有修改接收者的值，依然是用指针接收者来声明的。因为 File 类型的值具备非原始的本质，所以总是应该被共享，而不是被复制。是使用值接收者还是指针接收者，不应该由该方法是否修改了接收到的值来决定。这个决策应该基于该类型的本质。这条规则的一个例外是，需要让类型值符合某个接口的时候，即便类型的本质是非原始本质的，也可以选择使用值接收者声明方法。这样做完全符合接口值调用方法的机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *File)</span></span>Chdir()<span class="hljs-type">error</span>&#123;<br> <span class="hljs-comment">// do some read</span><br> <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>http.Response 类型包含一个名为 Body 的字段，这个字段是一个 io.ReadCloser 接口类型的值。Body 字段作为第二个参数传给 io.Copy 函数。io.Copy 函数的第二个参数，接受一个 io.Reader 接口类型的值，这个值表示数据流入的源。</p></li><li><p>接口是用来定义行为的类型。这些被定义的行为不由接口直接实现，而是通过方法由用户定义的类型实现。如果用户定义的类型实现了某个接口类型声明的一组方法，那么这个用户定义的类型的值就可以赋给这个接口类型的值。这个赋值会把用户定义的类型的值存入接口类型的值。对接口值方法的调用会执行接口值里存储的用户定义的类型的值对应的方法。因为任何用户定义的类型都可以实现任何接口，所以对接口值方法的调用自然就是一种多态。在这个关系里，用户定义的类型通常叫作实体类型，原因是如果离开内部存储的用户定义的类型的值的实现，接口值并没有具体的行为。</p></li><li><p>接口值是一个两个字长度的数据结构，第一个字包含一个指向内部表的指针。这个内部表叫作 iTable，包含了所存储的值的类型信息。iTable 包含了已存储的值的类型信息以及与这个值相关联的一组方法。第二个字是一个指向所存储值的指针。将类型信息和指针组合在一起，就将这两个值组成了一种特殊的关系。</p></li></ol><p><img src="http://ww1.sinaimg.cn/large/006gLprLly1gpezideoc1j30o607a0t8.jpg" alt="Xnip2021-04-10_21-47-21.jpg"></p><ol start="20"><li><p>方法集定义了一组关联到给定类型的值或者指针的方法。定义方法时使用的接收者的类型决定了这个方法是关联到值，还是关联到指针，还是两个都关联。</p></li><li><p>如果使用指针接收者来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。如果使用值接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。</p></li><li><p>Go 语言允许用户扩展或者修改已有类型的行为。这个功能对代码复用很重要，在修改已有类型以符合新类型的时候也很重要。这个功能是通过嵌入类型（type embedding）完成的。嵌入类型是将已有的类型直接声明在新的结构类型里。被嵌入的类型被称为新的外部类型的内部类型。</p></li><li><p>一旦我们将 user 类型嵌入 admin，我们就可以说 user 是外部类型 admin 的内部类型。由于内部类型的提升，内部类型实现的接口会自动提升到外部类型。这意味着由于内部类型的实现，外部类型也同样实现了这个接口。比如</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> admin <span class="hljs-keyword">struct</span>&#123;<br> user <span class="hljs-comment">// 嵌入类型</span><br> level <span class="hljs-type">string</span> <br>&#125;<br><span class="hljs-keyword">var</span> a admin&#123;<br>  user : user&#123;<br>    xxxx<br>  &#125;,<br>  level:<span class="hljs-string">&quot;...&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *user)</span></span>do()&#123;<br>&#125;<br><span class="hljs-comment">// 可以直接访问内部类型的方法</span><br>a.user.do()<br>a.yyy <span class="hljs-comment">// yy 是 user 中的字段，可以直接访问</span><br></code></pre></td></tr></table></figure><p>如果外部类型实现了 do 方法，内部类型的实现就不会被提升。不过内部类型的值一直存在，因此还可以通过直接访问内部类型的值，来调用没有被提升的内部类型实现的方法。。不过，即便内部类型是未公开的，内部类型里声明的字段依旧是公开的。既然内部类型的标识符提升到了外部类型，这些公开的字段也可以通过外部类型的字段的值来访问。</p><ol start="24"><li>将工厂函数命名为 New 是 Go 语言的一个习惯。比如 New 函数做了些有意思的事情：它创建了一个未公开的类型的值。要让这个行为可行，需要两个理由。第一，公开或者未公开的标识符，不是一个值。第二，短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量。永远不能显式创建一个未公开的类型的变量，不过短变量声明操作符可以这么做。</li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆结构简介</title>
    <link href="/2021/03/22/%E5%A0%86%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/03/22/%E5%A0%86%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1 基本结构"></a>1 基本结构</h2><p>堆类似二叉树，但是是有序的，所谓的有序，就是父节点和子节点有固定的大小关系（即堆属性）。就是父节点大于它的每个子节点的话，此时根节点就是最大的了，这叫最大堆。如果父节点小于它的每个子节点的话，此时根节点就是最小的了，这叫最小堆。<br><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0n29y2o47j30m009874b.jpg" alt="Xnip2022-03-26_10-09-15.jpg"></p><p>如图，10&gt;7 10&gt;2 7&gt;5 7&gt;1 这是一个最大堆</p><h2 id="2-与树的比较"><a href="#2-与树的比较" class="headerlink" title="2 与树的比较"></a>2 与树的比较</h2><p>树的内存使用空间比堆高，因为需要存储节点的指向，堆只要一个数组存储就可以了。</p><p>对于普通的二叉树，可以使用如下的方式组织数据，</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0n32mt3ohj30vo0c674j.jpg" alt="Xnip2022-03-26_10-38-07.jpg"></p><p>可以看到是允许第三层没有铺满的情况，最右边的节点还是空的。</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0n3431eocj30we0dujs9.jpg" alt="Xnip2022-03-26_10-40-14.jpg"></p><p><strong>对于堆的话，是必须要把当前层铺满才能铺下一层的，也就是可能会出现上面这样的结构，但是不会出现上面的二叉树那样没有铺满一层的情况。</strong></p><h2 id="3-堆的存储"><a href="#3-堆的存储" class="headerlink" title="3 堆的存储"></a>3 堆的存储</h2><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0n29y2o47j30m009874b.jpg" alt="Xnip2022-03-26_10-09-15.jpg"></p><p>以这个堆为例，是用数组</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[10, 7, 2, 5, 1]</span><br></code></pre></td></tr></table></figure><p>来存储的。实际上堆的堆属性可以满足快速查找某个节点的父子节点的要求。</p><p>堆的n个节点存在一个大小为n的数组，数组从前往后，相当于从上到下，从左到右遍历了堆依次存储下了各节点。故很容易得到对于数组中的下标为i的节点，其父节点在数组中的下标为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">father</span> = floor((i-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>)<br><span class="hljs-attribute">leftchid</span> = <span class="hljs-number">2</span>i+<span class="hljs-number">1</span><br><span class="hljs-attribute">rightchid</span> = <span class="hljs-number">2</span>i+<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>比如10，父节点下标是floor((0-1)&#x2F;2)&#x3D;floor(-0.5)&#x3D;-1，这不是一个有效的数组下标，所以节点10没有父节点，左右节点下标分别是1 2</p><p>需要注意下，对于数组中下标为2的节点2，算出来子节点在数组中的下标分别是5 6，但是数组没那么大，说明节点2没有子节点。</p><p><strong>显然根据该公式找父子节点非常快，时间是O(1)</strong></p><h2 id="4-堆的高度"><a href="#4-堆的高度" class="headerlink" title="4 堆的高度"></a>4 堆的高度</h2><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0n29y2o47j30m009874b.jpg" alt="Xnip2022-03-26_10-09-15.jpg"></p><p>这个堆的高度是2，有3层。堆的高度就是层数-1</p><p>如果一个堆有n个节点，那么其高度h就是floor(log2(n))，计算思路如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">2^0+2^1+..+2^h&gt;=n<br>2^(h+1)-1&gt;=n<br></code></pre></td></tr></table></figure><p>叶子节点总是位于数组的floor(n&#x2F;2)和n-1之间</p><h2 id="5-堆的操作"><a href="#5-堆的操作" class="headerlink" title="5 堆的操作"></a>5 堆的操作</h2><p>主要涉及2个操作，以最大堆为例：</p><p>如果节点的值比父节点的值大，那么交换这个节点和它的父节点，这个节点在堆中的位置上升了。</p><p>对应的，从父节点的角度看，如果节点的值比子节点的值小，<strong>那么需要将这个节点向下移动，这个操作叫堆化（heapify）。</strong></p><h3 id="5-1-插入一个节点"><a href="#5-1-插入一个节点" class="headerlink" title="5.1 插入一个节点"></a>5.1 插入一个节点</h3><p>以如下的最大堆为例：</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0n29y2o47j30m009874b.jpg" alt="Xnip2022-03-26_10-09-15.jpg"></p><p>插入16的话，在对应的数组后追加</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[ 10, 7, 2, 5, 1, 16 ]</span><br></code></pre></td></tr></table></figure><p>对应的树变成了：</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0n3p1uhvqj30oa08smx9.jpg" alt="Xnip2022-03-26_11-00-24.jpg"></p><p>发现16比2大，交换16和2:</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0n3q7f5hcj30uo09gmxk.jpg" alt="WX20220326-110130@2x.png"></p><p>完了发现16比10大，交换：</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0n3qtfp4mj30rg0aamxk.jpg" alt="WX20220326-110206@2x.png"></p><p>这就是最终结果</p><h3 id="5-2-删除根节点"><a href="#5-2-删除根节点" class="headerlink" title="5.2 删除根节点"></a>5.2 删除根节点</h3><p><strong>堆的设计决定了绝大部分你要删除的是根节点。</strong></p><p>最重要的一步就是删除根节点了，根节点由最后一个节点补上，然后不断<strong>堆化</strong>（因为是从根节点的角度考虑的），最终得到满足堆属性的堆。</p><p>举个例子：</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0n3t5yln8j30lg09gjrm.jpg" alt="WX20220326-110421@2x.png"></p><p>删掉10了，取出最后堆对应数组的最后一个元素放到根节点：</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0n3u0yddej30r60a8aac.jpg" alt="WX20220326-110511@2x.png"></p><p><strong>发现1比7和2都小，此时交换一个较大的上来，</strong></p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0n3vr1b25j30um0a2t8z.jpg" alt="WX20220326-110650@2x.png"></p><p>1&lt;5，再交换：</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0n3vdny1yj30vy08uq39.jpg" alt="WX20220326-110627@2x.png"></p><p>这就是最终结果</p><h3 id="5-3-删除任意节点"><a href="#5-3-删除任意节点" class="headerlink" title="5.3 删除任意节点"></a>5.3 删除任意节点</h3><p>将选择的要删除的节点D和最后一个节点P交换，然后删除D，站在P的角度，如果P是子节点，考虑和父节点交换，如果P是有子节点的父节点，考虑堆化。</p><h2 id="6-应用场景"><a href="#6-应用场景" class="headerlink" title="6 应用场景"></a>6 应用场景</h2><p>总结下来就是需要快速访问到最重要的元素，这时候可以使用堆，把最重要的元素放在根节点</p><h3 id="6-1-堆排序"><a href="#6-1-堆排序" class="headerlink" title="6.1 堆排序"></a>6.1 堆排序</h3><p>这个看上面图应该就理解了，这里不多赘述了</p><h3 id="6-2-优先级队列"><a href="#6-2-优先级队列" class="headerlink" title="6.2 优先级队列"></a>6.2 优先级队列</h3><p>优先级队列和一般队列的区别在于，一般队列出的优先级可以理解为进的越早，出的越早，即先进先出。但是优先级队列是按照特定的优先级出去的，谁优先级越高，谁越先出去。那么可以和堆联系起来，可以将优先级最高的放在堆顶，组成一个最大堆，当然组成最小堆也可以，需要看看实际场景中哪种方便。</p><p>例子：有100个文件，每个文件大小是100M，每个文件都是由有序字符组成的，现在要将这100个文件组成一个有序的大文件。</p><p>其实任意两个文件之间，都是可以比出顺序的，那么就可以决定了谁排在前面，谁排在后面。可以用这100个文件组成一个最小堆，堆的根节点实际上就是大文件最开始的元素，根节点的子节点都是排在它后面的。最后对这个堆从上往下，从左到右逐层遍历，那么就可以得出这个大文件了。</p><h3 id="6-3-求topK即前K大元素"><a href="#6-3-求topK即前K大元素" class="headerlink" title="6.3 求topK即前K大元素"></a>6.3 求topK即前K大元素</h3><p>问题：在包含n个元素的数组array中，求解前K大元素</p><p>排个<strong>最小堆</strong>，这个堆的大小只要为K即可，可以用数组存储。遍历array，如果发现堆满了，比较当前元素值和最小堆的根节点，比根节点大则替换到根节点，然后调整堆为最小堆。如果堆没满，则将元素最为最后一个节点插入，调整堆为最小堆。</p><hr><p>本文参考了如下资料：</p><p><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap">Heap</a></p><p><a href="https://blog.51cto.com/u_15076209/3481016">堆排序原理及其应用场景</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现String方法来自定义打印结果</title>
    <link href="/2021/03/22/%E5%AE%9E%E7%8E%B0String%E6%96%B9%E6%B3%95%E6%9D%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C/"/>
    <url>/2021/03/22/%E5%AE%9E%E7%8E%B0String%E6%96%B9%E6%B3%95%E6%9D%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>某个自定义类型，如果直接打印的话，就是其原始值，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t1 := T(<span class="hljs-number">1</span>)<br>fmt.Println(t1)<br>t2 := T(<span class="hljs-number">2</span>)<br>fmt.Println(&amp;t2)<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">1<br>0xc00012a010<br></code></pre></td></tr></table></figure><p> 如果想自定义打印结果，比如t1打印出来是one，那么<strong>需要这个自定义类型实现 String() string</strong>，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t1 := T(<span class="hljs-number">1</span>)<br>fmt.Println(t1)<br>t2 := T(<span class="hljs-number">2</span>)<br>fmt.Println(&amp;t2)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> t == T(<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;one&quot;</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unknown&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">one<br>unknown<br></code></pre></td></tr></table></figure><p>另一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>Value <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t1 := T&#123;<span class="hljs-number">1</span>&#125;<br>fmt.Println(t1)<br>t2 := &amp;T&#123;<span class="hljs-number">2</span>&#125;<br>fmt.Println(t2)<br>fmt.Println(&amp;t2)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> t.Value == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;one&quot;</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;unknown&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">one<br>unknown<br>0xc00000e030<br></code></pre></td></tr></table></figure><p>对于指针类型的t2，注意这里打印t2和&amp;t2的不同，打印t2的时候也调用String()。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么需要对 html 进行转义？</title>
    <link href="/2021/03/09/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AF%B9%20html%20%E8%BF%9B%E8%A1%8C%E8%BD%AC%E4%B9%89%EF%BC%9F/"/>
    <url>/2021/03/09/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AF%B9%20html%20%E8%BF%9B%E8%A1%8C%E8%BD%AC%E4%B9%89%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>在 html 中，有一些符号&lt;&gt;等等都是有特定含义的，比如&lt;&gt;是一个标签的开始和结束。如果在一个.html文件写&lt;&gt;，会被解析为标签。那么如果想在页面显示这些特定字符呢？那么就需要对这些字符进行转义，然后写到 html 中，就不会被浏览器认为是 html 中的特殊字符。</p><h2 id="go-中的方法"><a href="#go-中的方法" class="headerlink" title="go 中的方法"></a>go 中的方法</h2><p>在 go 中，可以使用官方 html 包的 EscapeString 方法，将一个字符串中的在 html 中有特定含义的字符转义，官方对于这个方法的注释如下：</p><blockquote><p>EscapeString escapes special characters like “&lt;” to become “&lt;”. It escapes only five such characters: &lt;, &gt;, &amp;, ‘ and “. UnescapeString(EscapeString(s)) &#x3D;&#x3D; s always holds, but the converse isn’t always true.</p></blockquote><p>官方示例：</p><p>Code:<a href="https://godoc.org/html?play=EscapeString">play</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> s = <span class="hljs-string">`&quot;Fran &amp; Freddie&#x27;s Diner&quot; &lt;tasty@example.com&gt;`</span><br>fmt.Println(html.EscapeString(s))<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&amp;#34;Fran &amp;amp; Freddie&amp;#39;s Diner&amp;#34; &amp;lt;tasty@example.com&amp;gt;<br></code></pre></td></tr></table></figure><p>与 EscapeString 对应的方法叫 <a href="https://golang.org/src/html/escape.go#L187">UnescapeString</a>，官方注释如下：</p><blockquote><p>UnescapeString unescapes entities like “&lt;” to become “&lt;”. It unescapes a larger range of entities than EscapeString escapes. For example, “&amp;aacute;” unescapes to “á”, as does “&amp;#225;” and “&amp;#xE1;”. UnescapeString(EscapeString(s)) &#x3D;&#x3D; s always holds, but the converse isn’t always true.</p></blockquote><p>官方示例：</p><p>Code:<a href="https://godoc.org/html?play=UnescapeString">play</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> s = <span class="hljs-string">`&amp;quot;Fran &amp;amp; Freddie&amp;#39;s Diner&amp;quot; &amp;lt;tasty@example.com&amp;gt;`</span><br>fmt.Println(html.UnescapeString(s))<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&quot;Fran &amp; Freddie&#x27;s Diner&quot; &lt;tasty@example.com&gt;<br></code></pre></td></tr></table></figure><h2 id="我的测试"><a href="#我的测试" class="headerlink" title="我的测试"></a>我的测试</h2><p>如果一个文件 data.html 中的内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>请在输入框内贴入你需要转换的HTML代码<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么用chrome打开这个文件显示结果为：</p><p><img src="http://ww1.sinaimg.cn/large/006gLprLly1gkpm4c93o3j30n2030jro.jpg" alt="QQ20201115-094330@2x.png"></p><p>如果想在浏览器显示&lt; 呢？</p><p>用 go 的EscapeString方法或者<a href="https://www.sojson.com/rehtml">在线html转义工具</a>对&lt;进行转义，得到<code>&amp;lt;</code>，将<code>&amp;lt;</code>加到段落最后，就不会被认为是一个标签的开始了。data.html 改成这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>请在输入框内贴入你需要转换的HTML代码<span class="hljs-symbol">&amp;lt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>chrome 的显示效果为：</p><p><img src="http://ww1.sinaimg.cn/large/006gLprLly1gkpm6o38b5j30l001y3yr.jpg" alt="QQ20201115-094550@2x.png"></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记-第8章 并发</title>
    <link href="/2020/12/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC8%E7%AB%A0%20%E5%B9%B6%E5%8F%91/"/>
    <url>/2020/12/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC8%E7%AB%A0%20%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p><strong>在最开始，首先讲一下 线程，协程，进程的区别和联系。</strong></p><p><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html</a></p><p><a href="http://www.qnx.com/developers/docs/6.4.1/neutrino/getting_started/s1_procs.html">http://www.qnx.com/developers/docs/6.4.1/neutrino/getting_started/s1_procs.html</a></p><p>单个CPU一次只能运行一个任务</p><p><strong>进程：process,是程序的一次执行，每个进程都有独立的内存空间</strong></p><p>线程：thread,是轻量级别线程，一个进程可以由多个线程组成，<strong>线程是CPU调度的基本单位。</strong>线程之间可以共享内存空间。线程之间因为共享内存会实施“锁”机制，有<a href="http://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81">“互斥锁”</a>（Mutual exclusion，Mutex），防止多个线程同时读写某一块内存区域（一次只能一个线程读写一个内存区域）。还有<a href="http://en.wikipedia.org/wiki/Semaphore_(programming)">“信号量”</a>（Semaphore），用来保证多个线程不会互相冲突（也就是允许指定个线程访问某一个内存空间）。</p><p>协程：也叫微线程，coroutine,是人工可控的，可以在调用中中断然后执行其他的调用。协程看上去也是子程序，<strong>但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。内部可以通过yield实现跳转。</strong></p><p>子程序：也叫函数</p><p>关于内存空间：进程的内存空间是独立的，但是线程之间的空间是可以共享的。进程的内存空间的独立是通过操作系统和硬件MMU协作映射到不同的物理地址上的，所以它们是相互独立的。进程的物理地址一般是不可以跨进程访问的。</p><p><strong>一个进程的所有线程是同时执行的。</strong></p><p><strong>对于单核CPU，一次只允许一个线程执行。多少核，就是允许多个个线程同时运行</strong></p><p>操作系统的设计，因此可以归结为三点：</p><p>（1）以多进程形式，允许多个任务同时运行；</p><p>（2）以多线程形式，允许单个任务分成不同的部分运行；</p><p>（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p><p><strong>调度器</strong>：“scheduler”，它关心的只是怎样把单个cpu的运行拆分成一段一段的“运行片”，轮流分给不同的程序去使用，而在宏观上，因为分配切换的速度极快，就制造出多程序并行在一个cpu上的假象。</p><p><strong>8.1 并发的含义</strong></p><p>并发：逻辑上具备同时处理多个任务的能力</p><p>并行：物理上在同一时刻处理多个任务的能力。并行是并发的理想状态，并行的前提条件是多线程或多进程。</p><p>用多线程实现分布式和负载平衡，减轻单进程垃圾回收压力；多线程(LWP)抢夺更多的处理器资源。协程提高处理器时间片效率。</p><p>go中可以使用go 创建一个并发任务单元</p><p><img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0o8ucofdij30gu0g4gms.jpg" alt="Xnip2022-03-27_10-43-04.jpg"></p><p><strong>int的default值为0</strong></p><p>这里的go func(x,y int)启动了一个并发执行单元，当a:&#x3D;100执行结束的时候，执行到go func了，a用的是值传递，相当于go func里的a是个局部变量，这个时候回记录下a和counter()的值，注意这个时候counter()执行完毕c变成1了，然后睡一秒，再执行。在开始睡的时候，main继续向下执行，因为进程退出的时候不会等到并发任务结束，所以需要强制然后睡3秒，在醒来之前可以充分保障go func已经结束了。最后结果是    <img src="http://tva1.sinaimg.cn/large/006gLprLgy1h0o8uy7369j30pc028mx2.jpg" alt="Xnip2022-03-27_10-44-36.jpg"></p><p>注意这里居然可以直接写println…，当然直接写fmt.Println也是可以的</p><p><strong>8.1.1 Wait</strong></p><p><strong>默认只有有限个线程</strong>可以同时运行，这些线程的个数和处理器核数相等。可以通过<strong>runtime.GOMAXPROCS</strong>进行设置，也可以通过环境变量修改。</p><p>runtime.NumCPu可以返回机器的核数</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记-第7章 接口</title>
    <link href="/2020/10/06/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC7%E7%AB%A0%20%E6%8E%A5%E5%8F%A3/"/>
    <url>/2020/10/06/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC7%E7%AB%A0%20%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="第七章-接口"><a href="#第七章-接口" class="headerlink" title="第七章 接口"></a>第七章 接口</h2><p>来源：《Go 语言学习笔记》</p><h3 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1 定义"></a>7.1 定义</h3><p>是一组方法声明的集合。接口运行的时候回有运行期开销。</p><p>接口最常见的使用场景，是对包外提供访问，或者预留空间。</p><p>也可以先写方法然后抽象出接口。<br>接口可以嵌入其他类型接口，那么需要实现这些接口里的所有方法才可以。<br>接口名字通常以er结尾。</p><p>结构体的方法实现接口的时候，结构体的方法不能包含指针。</p><p>实现方法一般写成func (db *Database)funcname(){}这样的形式</p><p>对于一个方法，func(*data)和func(data)，只有形如t&#x3D;&amp;data的形式才可以调用者两个方法，t&#x3D;data是不可以的。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type tester interface&#123;<br>    <span class="hljs-built_in">test</span>()<br>    <span class="hljs-built_in">string</span>() string<br>&#125;<br>type <span class="hljs-built_in">data</span>()<br><span class="hljs-function"><span class="hljs-title">func</span><span class="hljs-params">(*data)</span><span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">func</span><span class="hljs-params">(data)</span><span class="hljs-title">stirng</span><span class="hljs-params">(string)</span></span>&#123;return <span class="hljs-string">&quot;123&quot;</span>&#125;<br>func <span class="hljs-selector-tag">main</span>()&#123;<br>    <span class="hljs-selector-tag">var</span> d data<br>    <span class="hljs-comment">// var t tester=d   <span class="hljs-doctag">FIXME:</span> 这个是不对的，因为data类型没有实现test和string,*data实现了</span><br>    <span class="hljs-selector-tag">var</span> t tester=&amp;d<br>    t<span class="hljs-selector-class">.test</span>()<br>    fmt<span class="hljs-selector-class">.Println</span>(t<span class="hljs-selector-class">.string</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>空接口可以被赋值为任何对象,默认值是nil</strong><br>也可以在结构体里面写接口</p><hr><h1 id="7-1-定义-1"><a href="#7-1-定义-1" class="headerlink" title="7.1 定义"></a>7.1 定义</h1><ol><li>接口变量的默认值是nil</li><li>接口之间是可以进行是否相等的判断的</li><li>可以接口套接口</li><li>空接口可以实现任何接口，比如一个空接口叫test,然后另一个接口叫data，那么可以定义 var d data&#x3D;&amp;test <strong>空接口可以被赋值为任何类型的对象</strong></li><li>如果接口A实现了接口B的所有方法，那么可以直接赋值为 var b B&#x3D;&amp;A，然后可以通过b调用A实现的具体方法了</li><li><strong>Go不是一种典型的OO语言，它在语法上不支持类和继承的概念。</strong><br> 所以接口和结构体非常重要</li></ol><p><a href="https://juejin.im/post/5a6873fd518825734501b3c5">下面来自掘金</a></p><p>~ 补充：<em>方法和函数的区别</em>：方法一般是指某个结构体的方法，类似于 func (a *struct)function(args){}，而函数就是单纯的接收一个输入然后给出一个输出 func funcname(in)out{}.也就是说方法是作用于某个数据类型上的函数。<br>7. Go语言支持的除Interface类型外的任何其它数据类型都可以定义其method（而并非只有struct才支持method），只不过实际项目中，method(s)多定义在struct上而已。<br>8. <strong>只要你实现了我，你就可以调我的方法</strong><br>也就说只要你实现了我，就可以把你看成我。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs autoit">   type MyInterface interface&#123;<br>       Print()<br>   &#125; <span class="hljs-meta"># 接口MyInterface定义，实现这个接口需要Print()方法实现才可以</span><br>   <br>   <span class="hljs-keyword">func</span> <span class="hljs-title function_">TestFunc</span><span class="hljs-params">(x MyInterface)</span> &#123;&#125;<br><span class="hljs-meta"># MyInterface的方法</span><br>   type MyStruct struct &#123;&#125;<br><span class="hljs-meta"># MyStruct接口定义</span><br>   <span class="hljs-keyword">func</span> <span class="hljs-params">(me MyStruct)</span> <span class="hljs-title function_">Print</span><span class="hljs-params">()</span> &#123;&#125;<br><span class="hljs-meta"># MyStruct的Print方法，实现了MyInterface接口</span><br>   <span class="hljs-keyword">func</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>       var me MyStruct<br>       <span class="hljs-meta"># me是一个MyStruct接口，实现了MYInterface接口</span><br>       TestFunc(me)<br>       <span class="hljs-meta"># 因为MyStruct实现了MyInterface接口，所以可以其调用MyInterface的方法</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> sort<br><br><span class="hljs-comment">// A type, typically a collection, that satisfies sort.Interface can be</span><br><span class="hljs-comment">// sorted by the routines in this package.  The methods require that the</span><br><span class="hljs-comment">// elements of the collection be enumerated by an integer index.</span><br><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-comment">// Len is the number of elements in the collection.</span><br>    Len() <span class="hljs-type">int</span><br>    <span class="hljs-comment">// Less reports whether the element with</span><br>    <span class="hljs-comment">// index i should sort before the element with index j.</span><br>    Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span><br>    <span class="hljs-comment">// Swap swaps the elements with indexes i and j.</span><br>    Swap(i, j <span class="hljs-type">int</span>)<br>&#125;<br><br>...<br><br><span class="hljs-comment">// Sort sorts data.</span><br><span class="hljs-comment">// It makes one call to data.Len to determine n, and O(n*log(n)) calls to</span><br><span class="hljs-comment">// data.Less and data.Swap. The sort is not guaranteed to be stable.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span><span class="hljs-params">(data Interface)</span></span> &#123;<br>    <span class="hljs-comment">// Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.</span><br>    n := data.Len()<br>    maxDepth := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := n; i &gt; <span class="hljs-number">0</span>; i &gt;&gt;= <span class="hljs-number">1</span> &#123;<br>        maxDepth++<br>    &#125;<br>    maxDepth *= <span class="hljs-number">2</span><br>    quickSort(data, <span class="hljs-number">0</span>, n, maxDepth)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>调用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type Person struct &#123;<br>Name string<br>Age  int<br>&#125;<br><br>func (<span class="hljs-selector-tag">p</span> Person) <span class="hljs-built_in">String</span>() string &#123;<br>    return fmt<span class="hljs-selector-class">.Sprintf</span>(<span class="hljs-string">&quot;%s: %d&quot;</span>, <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.Name</span>, <span class="hljs-selector-tag">p</span>.Age)<br>&#125;<br><br><span class="hljs-comment">// ByAge implements sort.Interface for []Person based on</span><br><span class="hljs-comment">// the Age field.</span><br>type ByAge <span class="hljs-selector-attr">[]</span>Person <span class="hljs-comment">//自定义</span><br><br>func (<span class="hljs-selector-tag">a</span> ByAge) <span class="hljs-built_in">Len</span>() int           &#123; return <span class="hljs-built_in">len</span>(a) &#125;<br>func (<span class="hljs-selector-tag">a</span> ByAge) <span class="hljs-built_in">Swap</span>(<span class="hljs-selector-tag">i</span>, j int)      &#123; <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i]</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[j]</span> = <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[j]</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i]</span> &#125;<br>func (<span class="hljs-selector-tag">a</span> ByAge) <span class="hljs-built_in">Less</span>(<span class="hljs-selector-tag">i</span>, j int) bool &#123; return <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.Age</span> &lt; <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[j]</span><span class="hljs-selector-class">.Age</span> &#125;<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br>    people := <span class="hljs-selector-attr">[]</span>Person&#123;<br>        &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">31</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">42</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Michael&quot;</span>, <span class="hljs-number">17</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Jenny&quot;</span>, <span class="hljs-number">26</span>&#125;,<br>    &#125;<br><br>    fmt<span class="hljs-selector-class">.Println</span>(people)<br>    sort<span class="hljs-selector-class">.Sort</span>(<span class="hljs-built_in">ByAge</span>(people))<br>    fmt<span class="hljs-selector-class">.Println</span>(people)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因为ByAge实现了Interface的方法，所以可以直接写ByAge(people)，把这个当做Interface传给Sort</p><h2 id="hiding-implementation-detail-（隐藏具体实现）"><a href="#hiding-implementation-detail-（隐藏具体实现）" class="headerlink" title="hiding implementation detail （隐藏具体实现）"></a>hiding implementation detail （隐藏具体实现）</h2><p>是一些源码，读不下去了</p><h2 id="interface的内存布局"><a href="#interface的内存布局" class="headerlink" title="interface的内存布局"></a>interface的内存布局</h2><p><strong>当你实现了我，也可以把你强制转换为我</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>    String() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Binary <span class="hljs-type">uint64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i Binary)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> strconv.Uitob64(i.Get(), <span class="hljs-number">2</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i Binary)</span></span> Get() <span class="hljs-type">uint64</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">uint64</span>(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    b := Binary&#123;&#125;<br>    s := Stringer(b)<br>    fmt.Print(s.String())<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记-第6章 方法</title>
    <link href="/2020/10/05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%20%E6%96%B9%E6%B3%95/"/>
    <url>/2020/10/05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0%20%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h3><p><strong>方法与函数对比</strong></p><p>方法是有关联状态的，也就是和具体的某个对象绑定在一起,go中的方法会包含是谁调用的这个性质，也就是说会在func后面加上()表明receive参数名，表示是谁调用它的。但是函数却是独立的，它接收输入，然后通过逻辑运算转换为对应的结果。</p><p><strong>可以为当前包，以及除了接口和指针之外的任何类型定义方法</strong></p><p><strong>%#v     相应值的Go语法表示 举例：Printf(“#v”, people)  输出： main.Human{Name:”zhangsan”}</strong></p><p><a href="https://studygolang.com/articles/2644">https://studygolang.com/articles/2644</a> 这个是个占位符</p><p><strong>可以使用实例值或者指针调用方法，编译器会自动在指针类型和基础类型直接转换</strong><br>如果func 后的reveive是指针，那么对原有的值会产生影响，也就是说要修改实例状态的话就是<em>T这样的格式。无法确定的情况，也用</em>T。</p><h3 id="6-2-匿名字段"><a href="#6-2-匿名字段" class="headerlink" title="6.2 匿名字段"></a>6.2 匿名字段</h3><p>可以直接访问匿名字段的属性和方法，但是它们不是继承关系。</p><h3 id="6-3-方法集"><a href="#6-3-方法集" class="headerlink" title="6.3 方法集"></a>6.3 方法集</h3>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记-第5章 数据</title>
    <link href="/2020/10/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC5%E7%AB%A0%20%E6%95%B0%E6%8D%AE/"/>
    <url>/2020/10/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC5%E7%AB%A0%20%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h3><p>字&#x3D;&#x3D;结构体后面的struct字段里面的反引号&#96;&#96;括起来的内容就是字段标签，<br>如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span>&#123;<br>    name <span class="hljs-type">string</span> <span class="hljs-string">`名字`</span><br>    sex <span class="hljs-type">bool</span> <span class="hljs-string">`性别`</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   u:=user&#123;<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">1</span>&#125;<br>   v:=reflect.ValueOf(u)<br>   t:=v.Type()<br>   <span class="hljs-keyword">for</span> i,n:=<span class="hljs-number">0</span>,t.NumField();i&lt;n;i++&#123;<br>   fmt.Println(<span class="hljs-string">&quot;%s:%v\n&quot;</span>,t.Field(i).Tag,v.Field(i))<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">姓名:Tom</span><br><span class="hljs-section">性别:1</span><br></code></pre></td></tr></table></figure><p>综上所述，获取结构体值采用的方法是<strong>reflect.ValueOf()</strong><br>获取字段标签的方法是<strong>reflect.ValueOf().Type()</strong></p><h3 id="内存布局-主要利用unsafe包检查内存情况"><a href="#内存布局-主要利用unsafe包检查内存情况" class="headerlink" title="内存布局  主要利用unsafe包检查内存情况"></a>内存布局  主要利用unsafe包检查内存情况</h3><p>golang定义的int类型会根据不同的平台切换成int32或者int64,int32和uint32都是占四个字节。而int64和uint64都是占8个字节 <strong>byte和bool占一个字节</strong></p><p>结构体的内存总是一次性分配的，各个字段在相邻的地址空间内按顺序排列。对于引用类型，字符串和数组，结构体中只包含其基本(头部)数据,所有匿名字段成员也被包含在内。</p><p>unsafe.Alignof返回的是结构体中基础类型的大小，也就是对齐宽度<br>unsafe.Sizeof() 返回对象的大小。以字节为单位<br>unsafe.Pointer(&amp;v) 返回v的地址（也就是v的首地址),可以与unsafe.Sizeof()相加，获得末地址</p><p><strong>输出的时候可以使用%p占指针的位，可以使用%d占数值的位</strong></p><p><strong>分配内存的时候，字段需要做对齐处理，也就是以字段中最长的基础类型宽度为标准</strong></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出MySQL-第18章 SQL优化</title>
    <link href="/2019/06/24/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC18%E7%AB%A0%20SQL%E4%BC%98%E5%8C%96/"/>
    <url>/2019/06/24/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC18%E7%AB%A0%20SQL%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>18.1 优化SQL的一般步骤<br>18.1.1 通过show status了解各种SQL的执行效率</p><ol><li>show session status 显示当前连接的状态</li><li>show global status 显示从数据库启动开始到现在连接的状态</li><li>show status like ‘Com_%s’ 显示类似某种状态的信息</li></ol><p>18.1.2 定位执行效率低的SQL语句<br>4. 定位执行效率低的SQL语句:<br>show processlist 可以查看当前MySQL正在进行的进程<br>18.1.3 通过EXPLAIN分析低效的SQL执行计划</p><ol><li>在sql语句前加上explain可以看到执行的时候的各个信息</li><li>可以通过 explain extended  加上show warnings，查看SQL被执行前优化器做了哪些修改，通过filtered字段查看。</li></ol><p>18.1.4 通过show profile分析SQL</p><ol><li>查看是否支持 profile<br>show @@have_profilling</li><li>查看状态<br>show profiles</li><li>查看查询的状态，查看每个线程的时间<br>show profile for query query_id<br>show profile cpu for query query_id 查看cpu的时间</li><li>mysql设置常量<br>set @name:&#x3D;value;</li><li>改变表的引擎<br>alter table tablename engine &#x3D; ***</li></ol><p>18.1.5 通过trace分析优化器如何选择执行计划</p><ol><li>打开trace，设置格式为json<br>set OPTIMIZER_TRACE &#x3D; ‘enabled&#x3D;on’,END_MARKERS_IN_JSON &#x3D; on;</li><li>设置trace能够使用的最大内存<br>set OPTIMIZER_TRACE_MAX_MEM_SIZE &#x3D; 1000000</li><li>执行完成sql语句，查看INFORMATION_SCHEMA.OPTIMIZER_TRACE，可以看见mysql是如何执行sql语句的。</li></ol><p>18.1.6 确定问题并采取对应的优化措施<br>在一些列上建立索引可以极大提高查询的效率，可以通过explain命令查看受到影响的行数。<br>18.2 索引问题<br>18.2.1 索引的存储分类<br>目前mysql提供四种索引：<br>B-Tree索引<br>HASH索引<br>R-Tree索引（空间索引）<br>Full-Text索引（全文索引）<br>可以对字段前几个进行索引<br>18.2.2 Mysql如何使用索引</p><ol><li><p>三种存储引擎都支持B-Tree索引</p></li><li><p>B-Tree可以进行全关键字，关键字范围和关键字前缀查询。<br><a href="https://www.jianshu.com/p/486a514b0ded">https://www.jianshu.com/p/486a514b0ded</a></p></li><li><p>mysql能够使用引擎的情况<br>匹配全值（Match the full value)<br>匹配值的范围查询(Match a range of values)<br>匹配最左前缀(Match a leftmost prefix)<br>仅仅对索引进行查询(Index only query)<br> 匹配列前缀(Match a column prefix)<br> 索引部分精确匹配而其他部分范围匹配(Match one part exactly and match a range on another part)<br>使用列名为空<br>可以根据explain命令后显示的key判断使用了什么索引<br>type为range说明使用范围查询<br>extra为using where说明除了利用索引加速访问外，还根据索引回表查询数据<br>extra为using index说明只需要查询索引就获得了需要的内容</p></li><li><p>存在索引但是不能使用索引的典型场景</p></li><li><p>例子<br>select * from (select actor_id from actor where last_name like ‘%NI%’)a ,actor b where a.actor_id &#x3D; b.actor_id</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出MySQL-第17章 MySQL分区</title>
    <link href="/2019/05/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC17%E7%AB%A0%20MySQL%E5%88%86%E5%8C%BA/"/>
    <url>/2019/05/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC17%E7%AB%A0%20MySQL%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>分区是指数据库将一个表分为更小，更容易管理的部分。逻辑上仍然只有一个表。<br>每个分区都是独立的对象，可以独自处理，也可以作为表的一部分处理。分区对于应用来说是透明的，不影响应用的业务逻辑。<br>17.1 分区概述</p><ol><li>分区引入了分区键（partition key）的概念，分区键根据某个区间值（或者范围值），特定列表或者HASH函数执行数据的聚集，让数据根据规则分布在不同的分区中，让一个大对象变成一些小对象。</li><li>查看是否可以分区:  show variables like ‘%partition%’</li><li>对同一个分区表的所有分区都必须使用同一个存储引擎<br>同一个数据库中不同分区表可以使用不同的存储引擎</li><li>每个分区表也要设置存储引擎<br>create table temp (id int,birthday DATE)<br>engine &#x3D; innodb #分区表存储引擎为InnoDB，必须在create table 语句之后才可以出现<br>paritition by hash(month(birthday)) # 数据聚集方法<br>partitions 6; # 指定6个分区</li></ol><p>17.2 分区类型</p><ol><li>几种分区类型<br>RANGE 分区:给定一个连续区间范围，把数据分配到不同的分区<br>LIST 分区：类似于RANGE分区，区别是LIST分区是基于枚举出的值列表分区，RANGE是基于给定的连续区间范围分区<br>HASH 分区：基于给定的分区个数，将数据分配到不同的分区<br>KEY 分区：类似于HASH分区<br>如果一个表有主键的话，那么分区应该基于该主键。如果没有的话，就随便基于哪个字段。</li></ol><p>17.2.1 Range分区</p><ol><li>分区创建语句<br>create table tem(<br>id int not null,<br>ename varchar(30),<br>hired DATE NOT NULL DEFAULT ‘1970-01-01’,<br>job varchar(30) NOT NULL,<br>stored_id INT NOT NULL<br>)<br>partition by range(stored_id){<br>partition p0 values less than (10),<br>partition p1 values less than (20),<br>partition p2 values less than (30),<br>);<br>就像java 的switch case 语句。<br>也可以指定当小于某个值（maxvalue）的时候就到指定的分区<br>alter table tem add paritition (partition p3 values less than maxvalue)</li><li>删除分区<br>alter table emp drop paritition p0</li></ol><p>17.2.2 List分区</p><ol><li>List分区与Range分区类似，List分区是从属一个枚举列表的值的集合，range是从属一个连续区间值的集合。</li><li>语法<br>create table tem(<br>id int not null,<br>ename varchar(30),<br>hired DATE NOT NULL DEFAULT ‘1970-01-01’,<br>job varchar(30) NOT NULL,<br>stored_id INT NOT NULL<br>)<br>partition by list(id){<br>partition p0 values in(3,5),<br>partition p1 values in(4),  # in 里面的东西也可以不是整数<br>partition p2 values in(8),<br>);<br>如果插入的值不在范围内，那么会报错，毕竟没有什么 values less than 等等的写法。</li></ol><p>17.2.3 Columns分区</p><ol><li>columns分区可以细分为 RANGE Columns 分区和 LIST Columns分区， RANGE Columns 分区和 LIST Columns分区都支持整数，日期时间，字符串三种数据类型。</li><li>columns分区支持多列分区，是基于元组的比较<br>create table tem(<br>id int not null,<br>ename varchar(30),<br>hired DATE NOT NULL DEFAULT ‘1970-01-01’,<br>job varchar(30) NOT NULL,<br>stored_id INT NOT NULL<br>)<br>partition by columns(id,stored_id){<br>partition p01 values less than (0,10),<br>partition p02 values less than (10,10),  # in 里面的东西也可以不是整数<br>partition p03 values less than (10,maxvalue),<br>partition p03 values less than (maxvalue,maxvalue)<br>);</li></ol><p>17.2.4 Hash分区</p><ol><li>Hash 分区主要用来分散热点读，确保数据在预先确定个数的分区中尽可能平均分布。</li><li>有两种Hash算法：常规Hash分区和线性Hash分区(LINEAR HASH分区），常规HASH使用取模算法，线性HASH分区使用一个线性的2的幂的运算法则。<br>常规Hash分区算法：<br>使用 N&#x3D;MOD(expr,num) N为几就去第几个分区<br>create table tem(<br>id int not null,<br>ename varchar(30),<br>hired DATE NOT NULL DEFAULT ‘1970-01-01’,<br>job varchar(30) NOT NULL,<br>stored_id INT NOT NULL<br>)<br>partition by hash (stored_id) partitions 4; # 有4个分区<br>线性Hash分区算法：<br>create table tem(<br>id int not null,<br>ename varchar(30),<br>hired DATE NOT NULL DEFAULT ‘1970-01-01’,<br>job varchar(30) NOT NULL,<br>stored_id INT NOT NULL<br>)<br>partition by linear hash (stored_id) partitions 4; # 有4个分区<br>（TODO: 线性Hash算法的计算看不懂）</li></ol><p>17.2.5 Key分区<br>hash分区允许用户使用自定义的表达式，但是Key分区不允许用户使用自定义的表达式，需要使用MySQL提供的HASH函数。<br>同时Hash分区只支持整数分区，而Key分区支持使用除了BLOB or Text类型外的其他类型的列作为分区键。<br>create table tem(<br>id int not null,<br>ename varchar(30),<br>hired DATE NOT NULL DEFAULT ‘1970-01-01’,<br>job varchar(30) NOT NULL,<br>stored_id INT NOT NULL<br>)<br>partition by key  (stored_id) partitions 4; # 有4个分区<br>如果没有指定分区键，那么会默认使用主键，没有主键会选择非空唯一键。<br>17.2.6 子分区<br>1.子分区(subpartitioning)是分区表对每个分区的再次分割，又称为复合分区（composite partitioning）。<br>支持对range或者list分区在进行子分区，子分区也是list或者range分区。<br>例子：<br>create table ts (id int,purchased date)<br>partition by range(year(purchased))<br>subpartition by hash(to_year(purchased))<br>subpartitions 2<br>(<br>partition p0 values less than (1900),<br>partition p0 values less than (2000),<br>partition p0 values less than maxvalue<br>);<br>17.2.7 MySQL分区处理NULL值的方式</p><ol><li>range分区中，null会被当做最小值处理<br>list分区中，null必须出现在枚举值列表中<br>hash&#x2F;key分区中，null会被当做零值来处理</li><li>例子<br>创建分区：<br>create table tb_range(<br>id int,<br>name varchar(5)<br>)<br>partition by range(id){<br>partition p0 values less than (-6)，<br>partition p0 values less than (1)，<br>partition p0 values less than maxvalue  #这个maxvalue是mysql系统自定义的，不是用户自定义的，所以直接写就可以了。<br>);<br>查看分区：<br>select<br>partition_name part,<br>partition_expression expr,<br>partition_description descr,<br>table rows<br>from<br>information_schema.partitions<br>where<br>table_schema &#x3D; schema()<br>and table_name &#x3D; ‘tb_range’;</li></ol><p>17.3 分区管理<br>17.3.1 RANGE&amp;LIST分区管理<br>1.删除分区：alter table drop partition partitionname<br>2.删除完分区之后可以看一下： show create table tablename<br>3.增加range分区，只能从最大端增加： alter table tablename add partition(partition  partitionname values less than (xxx))<br>也就是partitionname必须是连续的，比如p0,p1,p2,然后如果要增加的话就写p3<br>4.增加list分区：也只能从最大端增加： alter table tablename add partition(partition  partitionname values in (xxx))<br>5.修改分区：alter table reorganize partition into<br>重新定义range分区的时候，只能重新定义相邻的分区，不能跳过分区定义。且新分区必须和旧分区覆盖相同的区间。更不能改变分区的类型。<br>拆分range分区：<br>alter table tablename reorganize partition p3 into (<br>partition p2 values less than (2005),<br>partition p3 values less than (2010));<br>对于list分区，如果想要在里面加上枚举值，就需要先加上一个分区，然后再修改。具体可以见书上的例子。<br>17.3.1 HASH&amp;KEY分区管理<br>不可以执行像上面这样的直接删除的方式，删除分区。可以通过alter table coalesce partition 语句来合并hash分区或者key分区。<br>alter table tablename coalesce partition 2; # 可以用来减少分区的数量<br>不可以增加分区，如果要增加分区的话，alter table add pattition 数量<br>就是在原有分区的数量上加上</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出MySQL-第16章 SQL Mode及相关问题</title>
    <link href="/2019/04/06/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC16%E7%AB%A0%20SQL%20Mode%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2019/04/06/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC16%E7%AB%A0%20SQL%20Mode%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>MySQL可以运行在不同的SQL Mode（SQL模式）下面。<br>SQL Mode定义了MySQL应支持的SQL语法，数据校验等等。<br>16.1 MySQL SQL Mode简介</p><ol><li>查看SQL Mode<br>@@sql_mode</li><li>如果SQL Mode为STRICT_TRANS_TABLES（严格模式），那么当插入的时候插入的字段长度超过规定，会报错Error。<br>如果不用这个模式，插入的时候即执行insert的时候，会给出警告warning。但是数据库存的是截断之后的字符串。<br>设置SQL Mode<br>set session sql_mode &#x3D; ‘STRICT_TRANS_TABLES’<br>session表示只在本次连接中生效，也可以替换为global选项，global 表示在本次不生效，但是在新连接生效。</li></ol><p>16.1 MySQL SQL Mode简介<br>16.1 校验日期数据的合法性<br>如果当前SQL Mode为ANSI,插入非法日期会给出警告，然后实际上数据库存进去的是0000-00-00 00:00:00。<br>如果更改模式为TRADITIONAL，会直接提示日期格式非法error，拒绝插入。<br>16.2 MOD(x,0)<br>更改模式为TRADITIONAL，此时仍然是严格模式，那么会直接给出error。<br>非严格模式会返回NULL。<br>16.3 反斜杠\变为普通字符<br>在ANSI模式中添加NO_BACKSLASH_ESCAPES模式后，可以使得当要插入的字符串中含有反斜杠\时，反斜杠可以被看做为普通字符，不需要在反斜杠前面加上\来进行转义了。具体可以看书上的例子。<br>16.4 ||视为字符串连接操作符<br>设置SQL Mode为PIPES_AS_CONCAT,可以将||看做是字符串连接符。<br>16.2 常用的SQL Mode<br>sql_mode为ANSI时，等同于READ_AS_FLOAT,PIPES_AS_CONCAT,ANSI_QUOQTES,IGNORE_SPACE,ANSI的组合模式，该模式使得语法和行为更符合标准的MySQL。<br>sql_mode为STRICT_TRANS_TABLESI时，是严格模式，适用于事务表和非事务表，不允许非法日期，不允许超过长度的字符串，会直接给出错误Error。<br>sql_mode为TRADITIONAL时，等同于 STRICT_TRANS_TABLES,STRICT_ALL_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,TRADITIONAL,NO_AUTO_CREATE_USER等等模式的集合，是严格模式，插入不正确的值的时候会报错。用在事务表中，只要出现错误会立刻回滚。<br>16.3 SQL在迁移中如何使用<br>可以设置SQL Mode为NO_TABLE_OPTIONS模式，这样当输入show create table的时候，就会不显示最后的ENGINE关键字。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出MySQL-第14章 事务控制和锁定语句</title>
    <link href="/2019/04/03/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC14%E7%AB%A0%20%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%92%8C%E9%94%81%E5%AE%9A%E8%AF%AD%E5%8F%A5/"/>
    <url>/2019/04/03/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC14%E7%AB%A0%20%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%92%8C%E9%94%81%E5%AE%9A%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>MySQL默认对InnoDB进行行级锁定，对MyISAM和MEMORY进行表级锁定。<br>有时候用户需要明确的进行锁表或者事务的控制，来保证事务的完整性，需要事务控制语句和锁定语句。<br>14.1 LOCK TABLE和UNLOCK TABLE</p><ol><li>LOCK TABLE 可以锁定当前线程的表。<br>语法：<br>LOCK  TABLES<br>tbl_name [AS alias] {READ [LOCAL] \ [LOW_PRIORITY] WRITE}<br>[,tbl_name [AS alias] {READ [LOCAL] \ [LOW_PRIORITY] WRITE}]<br>(这里的tbl_name 指的是表名）</li><li>UNLOCK  TABLE 可以释放当前线程的任何锁定。<br>UNLOCK TABLES （线程释放锁）<br>如果当前表被一个线程锁定，那么其他线程会一直等待，直到该表被释放。<br>书上有个非常生动形象的表</li></ol><p>14.2 事务控制</p><ol><li>默认自动提交(Autocommit)</li><li>常用表达<br>START TRANSACTION | BEGIN [WORK]<br>COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]<br>ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]<br>SET AUTOCOMMIT &#x3D; {0,1}<br>其中： CHAIN和RELEASE 定义事务提交或者回滚结束之后的操作。CHAIN会立即启动一个事务，并且和刚刚的事务具有相同的隔离级别。RELEASE 会断开和客户端的连接。</li><li>如果进行数据库的操作，比如插入数据的时候，写了start transaction了，那么就必须等写commit才提交事务，这个事务结束。这个时候就是不自动提交的，但是如果不写start transaction的话，就表示自动提交，在插入数据结束之后就会自动提交了。<br>也就是说：start transaction会开始一个新事务，造成一个隐含的unlock tables被执行，也就是说这个时候表被释放了，没有被锁了。</li><li>关于日志记录<br>通常情况下，只对提交的事务记录到二进制日志里面，但是如果一个事务包含非事务类型的表，那么回滚操作也会被记录到二进制日志中，以确保非事务类型表的更新可以被复制到从(Slave）数据库中。<br>所以的DDL都不能回滚。</li><li>savepoint<br>可以定义SAVEPOINT,指定回滚事务的一部分，但是不能指定提交事务的一部分。<br>对于不需要的SAVEPOINT，可以使用 RELEASE SAVEPOINT 来删除 SAVEPOINT，最后删除的SAVEPOINT不能再执行ROLLBAK TO SAVEPOINT.<br>命令执行：<br>savepoint savepointname  # 定义savepoint<br>rollback savepoint savepointname  #回滚到刚才定义的savepoing，也就是说一直往上，到savepoint savepointname的这一段都被撤销了。</li></ol><p>14.3 分布式事务的使用<br>只有InnoDB支持分布式事务，一个分布式事务设计多个行动。每个行动是一个单独的事务。这些个事务要么一起成功，要么一起失败。<br>14.3.1 分布式事务的原理</p><ol><li>分布式事务需要一个或者多个资源管理器（RM）或者事务管理器（TM）<br>数据库服务器是一种资源管理器</li><li>分布式事务的提交需要两个阶段<br>第一阶段：所有的分支事务都准备好，也就是说这些事务被TM告知要提交。用于管理分支事务的RM会记录被稳定保存的分支的行动。分支事务指示是否他们可以这么做，这些结果会被用于第二阶段。<br>第二阶段：TM告知RMs是否要提交或者回滚。如果预备阶段，所有的分支指示他们能够提交，则所有的分支都被告知要提交。如预备阶段有一个分支说不能提交，则TM告知所有分支要回滚。</li></ol><p>14.3.2 分布式事务的语法<br>1,。两个阶段的语法<br>针对14.3.1.2 的两个阶段，只要使用下面的语法：<br>第一阶段：<br> XA {ATART|BEGIN} xid {JOIN|RESUME}<br>启动一个带xid值的XA事务。每个事务都有一个唯一的xid值，是XA事务表示符。由客户端生成，或者MySQL服务器生成。<br>xid 包含以下部分：xid：gtrid[.bequal[,firmatID]]<br>grid是事务表示符，相同的分布式事务应该使用相同的事务表示符。<br>bequal 分支限定符，默认为空串，相同的分布式事务中各个分支事务的bequal不应该有一样的。<br>formatID 表示grid和bequal值的格式，默认为1.<br>XA END xid [SUSPEND [FOR MIGRATE]]<br>XA PREPARE xid 事务进入prepare状态<br>XA RECOVER 可以查看当前状态<br>第二阶段：<br>XA COMMIT xid [ONE PHASE] 或者XA ROLLBACK xid<br>14.3.3 存在的问题</p><ol><li>主要的一个例子：<br>如果一个分支事务已经进入了prepare阶段，这个时候数据库异常启动，启动后虽然可以通过 xa recover看到当前有prepare状态的事务。但是因为该事务还没有提交，写入binlog（二进制日志），所以重启后无法根据binlog恢复之前被修改的数据。对于其他分支事务来说，可能已经提交成功，这将导致分布式事务的不完整性，会丢失部分内容。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出MySQL-第12章 存储过程和函数</title>
    <link href="/2019/03/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC12%E7%AB%A0%20%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/"/>
    <url>/2019/03/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC12%E7%AB%A0%20%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>12.1 定义</p><ol><li>存储过程（procedure）和函数（function）是事先经过编译并且存储在数据库的一段SQL语句的集合。<br>调用存储过程可以减少数据库和应用服务器之间的传输，对于提高数据的处理的效率很有好处。</li><li>区别：<br>函数必须有返回值，参数可以使用IN类型<br>存储过程没有，参数可以使用 IN,OUT,INOUT类型<br>IN参数表示这个参数只是作为输入传进来的<br>OUT表明这个参数是作为输出<br>INOUT表示参数既可以作为输入也可以作为输出</li></ol><p>12.2 存储过程和函数的相关操作</p><ol><li>存储过程和函数<br>创建需要权限：CREATE ROUTINE<br>修改或者删除： ALTER ROUTINE<br>执行：EXECUTE</li></ol><p>12.2.1 创建，修改存储过程或者函数<br>CREATE ROUTINE sp_name (proc_parameter[…])<br>[characteristic ..] routine_body<br>补充： load data infile用法<br>用于导入数据<br><a href="https://www.cnblogs.com/weiyiming007/p/8125432.html">https://www.cnblogs.com/weiyiming007/p/8125432.html</a><br>load data infile语句从一个文本文件中以很高的速度读入一个表中。使用这个命令之前，mysqld进程（服务）必须已经在运行。由于安全原因，当读取位于服务器上的文件时，文件必须处于数据库目录或可被所有人读取。另外，为了对服务器上文件使用load data infile，在服务器主机上必须有file的权限。<br>补充：FOUND ROWS用法<br>ysql 的FOUND_ROWS()<br>例如需要取出一张表的前10行，同时又需要取出符合条件的总数。这在某些翻页操作中很常见<br>SELECT SQL_CALC_FOUND_ROWS * FROM tbl_name<br>WHERE id &gt; 100 LIMIT 10;<br>在上一查询之后，你只需要用FOUND_ROWS()就能获得查询总数，这个数目是抛掉了LIMIT之后的结果数:<br>SELECT FOUND_ROWS();<br>其中第一个sql里面的SQL_CALC_FOUND_ROWS不可省略，它表示需要取得结果数，也是后面使用FOUND_ROWS()函数的铺垫。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出MySQL-第8章 选择合适的数据类型</title>
    <link href="/2019/01/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC8%E7%AB%A0%20%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/01/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC8%E7%AB%A0%20%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>8.1 char与varchar</p><ol><li>char是固定字节大小的，严格模式下：<br>如果长度超过这个大小，存进去的时候回直接截断，超过varchar的指定最大大小也直接截断。<br>char类型读取的时候会去掉末尾的空格，char适用于长度变化不大且对读取速度要求高的数据<br>InnoDB 建议使用varchar，因为平均上，char比varchar代价大，且InnoDB实际上使用的是指针指向数据值的头。</li></ol><p>8.2 text与blob</p><ol><li>相对于char与varchar，text和blob保存较大文本。</li><li>blod能保存二进制数据，如照片等等。<br>删除操作会在表里面留下“空洞”，这些“空洞”的记录在后续插入性能上会有影响，为了提高性能，应该使用optimize table功能对表进行碎片整理（输入命令 optimize table table1)<br>补充： MySQL碎片（Fragmentation）<br><a href="https://www.databasejournal.com/features/mysql/article.php/3927871/MySQL-Data-Fragmentation---What-When-and-How.htm">https://www.databasejournal.com/features/mysql/article.php/3927871/MySQL-Data-Fragmentation---What-When-and-How.htm</a></li><li>加快文本的查询速度的方法：使用散列值，可以用hash计算后将散列值存在单独的列中。这种方法只适用于精确查找。</li><li>如果文本太大，不妨将他们放到单独的表</li></ol><p>8.3 浮点数(float)和定点数(decimal)</p><ol><li>浮点数插入的精度超过定义的精度，会四舍五入到实际定义的精度，然后插入。</li><li>定点数实际上是以字符串形式存储的，精度超过规定后会按照实际精度四舍五入。</li><li>decimal与浮点数相似，都是(M,N)形式</li><li>精度要求高的时候使用定点数</li><li>编程中尽量避免浮点数的比较，多用范围比较为而不是&#x3D;&#x3D;</li></ol><p>8.4 日期类型<br>TIMSTAMP范围没有DATETIME大，但是保存了时区信息。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出MySQL-第7章 表类型（存储引擎）的选择</title>
    <link href="/2019/01/22/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC7%E7%AB%A0%20%E8%A1%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%89%E7%9A%84%E9%80%89%E6%8B%A9/"/>
    <url>/2019/01/22/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC7%E7%AB%A0%20%E8%A1%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%89%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<p>7.1 MySQL存储引擎概述</p><ol><li>MySQL用户可以自定义功能，因为MySQL存储引擎是插件式存储引擎</li><li>默认引擎(default-table-type)：InnoDB</li><li>查看引擎 show engines</li><li>表的引擎也是可以修改的</li></ol><p>7.2 各种存储引擎的特点</p><ol><li>现有的几种存储引擎对比：<br>MyISAM：适用于读操作和插入操作为主，更新删除少，对事务的完整性并发性要求不高<br> InnoDB：用于事务处理应用程序，更新删除多<br>MEMORY：对表的大小有限制，用于更新少的小表<br> MERGE NDB<br>只有InnoDB支持事务安全</li><li>MyISAM<br>默认表的存储格式是静态表，如果需要保存到表的内容本来就有空格，那么返回的时候空格也会被去掉<br>动态表会产生碎片在频繁的更新和删除记录的时候</li><li>InnoDB<br>具有提交，回滚和奔溃恢复能力的事务安全<br>支持自动增长列<br>支持外键约束，可以用show create table或者show table status 查看外键信息<br>存储方式：<br>InnoDB存储表和索引有如下两种方式：<br>使用共享表空间存储，表结构保存在.frm文件中，<br>或者使用多表空间存储，创建的表结构仍然保存在.frm文件中，每个表的数据和索引单独保存在.ibd中。如果是分区表，则每个分区保存单独的.ibd文件，文件名字是表名+分区名。多表空间的参数，只对新建的表有效。多表空间的数据文件没有大小限制，可以方便的进行单表的备份和恢复操作。</li><li>MEMORY<br>使用存在于内存中的内容创建表，每个MEMORY表只实际上对应一个磁盘文件，格式为.frm。MEMORY默认使用HASH索引，因为存在内存，服务关闭后，表中的数据会丢失。</li><li>MERGE<br>是MyISAM表的组合。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出MySQL-第3章 MySQL支持的数据类型</title>
    <link href="/2019/01/21/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC3%E7%AB%A0%20MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/01/21/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC3%E7%AB%A0%20MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<ol><li>数值类型<br>整数： tinyint,smallint,mediumint, int ,bigint (medium 居然是介质的意思），int默认为int(11)，不满11位用zerofill填充，多了也不截断，传什么就存什么，不会有精度影响。<br>zerofill 反映在sql语句里面比如：   alter table table1 modify column1 int zerofill<br>指定为zerofill的列自动加上UNSIGNED属性<br>AUTO_INCREMENT属性，自增，一般从1开始，一个表最多有一个AUTO_INCREMENT,定义时对应的列为NOT NULL，      primary key 或者 UNIQUE。<br>小数：浮点数和定点数(decimal)<br>小数可以用(M,D）表示，M表示整数位，D表示小数位，比如 column float(5,2)，这里如果标度超过D的限制会截断。<br>BIT（位类型），BIT(M)表示存放多少位二进制，select 的时候写成 bin() （二进制显示）或者 hex() （十六进制显示），不然看不出来</li><li>日期时间类型<br>年月日 DATE<br>时分秒 TIME<br>年月日时分秒 DATETIME （默认1970年开始），是DATE和TIME的组合<br>可以用now（）直接赋值给以上三种类型<br>MySQL只给第一个TIMESTAMP字段设置默认值为系统日期，第二个TIMESTAMP类型为默认就是0000-00-00了<br>插入日期的时候会先转换为本地的时区，取出的时候也会转换为本地时区再显示<br>例子： column1 timestamp not null default current_timestamp<br>修改当前系统时区： set time_zone &#x3D; ‘+9:00’ ，会影响timestamp类型的字段<br>datatime范围比timestamp大<br>YEAR类型表示年份</li><li>字符串类型<br>检索时候，char删除了尾部的空格，而varchar保留了这些空格。<br>binary和varbinary与上面两个类型类似，但是它们只包含二进制字符串<br>枚举值enum忽略大小写，存的时候都是大写，默认存第一个<br>SET与enum类似，但是set一次性可以选取多个成员，enum只能选一个。<br>create table table1(column1 set (‘a’,’b’,’c’))<br>insert into table1 values (‘a’,’b’)<br>不在范围内会报错，重复存如values (‘a’,’b’,’c’)存进去会过滤掉重复值</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出MySQL-第2章 SQL基础</title>
    <link href="/2019/01/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC2%E7%AB%A0%20SQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/01/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL-%E7%AC%AC2%E7%AB%A0%20SQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<ol><li>SQL语句的分类<br>DDL：数据定义语言，关键词包括create，drop,alter<br>DML:数据操纵语言，关键词包括 insert,delete,update,select<br>DCL:数据控制语言，控制不同的数据段直接许可和访问的级别的语句。grant,revoke<br>所有的DDL和DML（不包括select），执行成功之后都显示”Query OK”</li></ol><p>2.一些命令（DDL与DML)<br>create database databasename<br>use databasename<br>show tables<br>drop database databasename<br>alter table tablename modify [column] column_definition [first | after col_name]<br>字段修改名字： alter table change [column] old_column_name new_column_name new_column_type<br>查询不重复的记录使用distinct    select distinct col_name from tablename<br>mysql排序默认降序<br>聚合操作：group by ,having<br>内连接：选出两张表相同的部分<br>外连接：会选出其他不匹配的部分（左连接：包含所有左边表的记录，右连接：包含所有右边表的记录）<br>            left join tablename on table1.column&#x3D;table2.column (或选出所有满足条件的table1的列值）<br>子查询：<br>  关键词包括： in ,not in , &#x3D; , !&#x3D;, exists, not exists<br>select <em>from table1 where column1 in (select column1 from table2)<br>select</em> from table1 where column1&#x3D; (select column1 from table2)#此时子查询记录唯一<br>记录联合 select column1 from table1 union [all] select column1 from table2<br>UNION 是将结果去重后显示<br>union all 是将结果不去重直接显示<br>3. DCL命令<br>grant select,insert on sakila.<em>to ‘z1‘@’localhost’ idenfied by ‘123’<br>revoke insert on sakila.</em> from ‘z1‘@’localhost’<br>4. 帮助文档<br>? 需要帮助的东西即可<br>5. 查询元数据信息<br>MySQL5.0后，出现新数据库information_schema，用来记录MySQL的元数据信息。<br>元数据：数据的数据，比如表名，列名，索引名(statistics)等，实际上物理并不存在， show database 或产生该结果（显示元数据）</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
